#include "russian.h"
#include <fcntl.h>

namespace russian {
namespace {

class alert : public protocol {
public:

waiter<void> m_waiter;

alert(impl* parent, json5deserializer2& s) : protocol(parent, 0)
{
	string path;
	SER_ENTER(s)
	{
		s.item("path", path);
	}
	path = file::resolve(file::exedir(), path);
	mkfifo(path, 0644);
	my_coro(path).then(&m_waiter);
}

async<void> my_coro(string path)
{
	fd_t fd = open(path, O_RDONLY|O_NONBLOCK);
	co_await runloop2::await_read(fd);
	autoptr<group> m_channel = mkgroup("Alert", chanbase::f_no_logs|chanbase::f_no_users, 0);
	
	while (true)
	{
		uint8_t buf[512];
		ssize_t n = read(fd, buf, sizeof(buf));
		if (n > 0)
		{
			string text = bytesr(buf, n);
			if (text.endswith("\n"))
				text = text.substr(0, ~1);
			span sp[] = { { text } };
			m_channel->message(chanbase::imp_highlight, time(NULL), sp);
		}
		if (n == 0)
		{
			// fifos are a little crazy - if the write side is closed, there's no way to clear the POLLHUP condition from the read fd
			// the only solution is create a new fd
			// https://stackoverflow.com/questions/52015639/linux-named-fifo-non-blocking-read-select-returns-bogus-read-fds
			int fd2 = open(path, O_RDONLY|O_NONBLOCK);
			fd.close();
			fd = fd2;
		}
		co_await runloop2::await_read(fd);
	}
}

void action(chanbase& at, cstrnul text) override
{
	span sp[] = { { "* Can't do that here" } };
	at.message(chanbase::imp_scrollback, time(NULL), sp);
}
void close_chan(chanbase& at) override {} // only one channel, and groups can't be closed anyways

};

}
protocol*
protocol::create_alert(impl* parent, json5deserializer2& s) { return new alert(parent, s); }
}
