#pragma once
#include "arlib.h"

//don't know if this is guaranteed stable, but I'd rather not include the gtk header here
typedef struct _GtkScrolledWindow GtkScrolledWindow;
typedef struct _GtkTreeStore GtkTreeStore;
typedef struct _GtkTreeView GtkTreeView;
typedef struct _GtkTreeModel GtkTreeModel;
typedef struct _GtkTreePath GtkTreePath;
typedef struct _GtkTreeRowReference GtkTreeRowReference;
typedef struct _GtkTreeSelection GtkTreeSelection;
typedef struct _GtkWidget GtkWidget;
typedef struct _PangoAttrList PangoAttrList;

class chanview : nocopy {
	GtkTreeStore* store;
	GtkTreeView* view;
	GtkScrolledWindow* scrollview;
	
	function<void(void* userdata)> focus_cb;
	map<uint32_t, PangoAttrList*> color_attrs;
	
	float scroll_accum; // always in the range (-1..+1)
	
	chanview();
	
	PangoAttrList* attrs_for_color(uint32_t xrgb);
	
	bool onfocus_sig(GtkTreeSelection* selection, GtkTreeModel* model, GtkTreePath* path, bool path_currently_selected);
	
public:
	void _priv_scrolled_px(float delta);
	
	class chanbase : nocopy {
		friend class chanview;
	protected:
		chanview* parent;
		GtkTreeRowReference* row;
		bool can_focus;
		
		chanbase(chanview* parent, GtkTreeRowReference* parentrow, cstring name, bool can_focus, void* userdata);
		
	public:
		void rename(cstring name);
		void color(uint32_t xrgb); // -1 is default; color remains until changed (clearing in onfocus would generally be a good idea)
		void focus(); // will fire the onfocus callback
		
	protected:
		~chanbase();
	};
	
	class channel : public chanbase {
		friend class chanview;
		channel(chanview* parent, GtkTreeRowReference* parentrow, cstring name, bool can_focus, void* userdata)
			: chanbase(parent, parentrow, name, can_focus, userdata)
		{}
		
	public:
		~channel() {}
	};
	
	//A group is a collection of related channels that roughly corresponds to an IRC server or a Discord guild.
	class group : public chanbase {
		friend class chanview;
		group(chanview* parent, GtkTreeRowReference* parentrow, cstring name, bool can_focus, void* userdata)
			: chanbase(parent, parentrow, name, can_focus, userdata)
		{}
		
	public:
		channel* child(cstring name, bool can_focus, void* userdata) { return new channel(parent, row, name, can_focus, userdata); }
		~group() {}
	};
	
	friend class chanbase;
	friend class channel;
	friend class group;
	
	static chanview* create() { return new chanview(); }
	//it's safe to not use GTK_WIDGET(foo), defining G_DISABLE_CAST_CHECKS replaces it with a straight cast
	GtkWidget* gtkwidget() { return (GtkWidget*)scrollview; }
	
	//There's only one onfocus function per channel view object, but the userdata can vary per group/channel.
	//Can be called on the active channel.
	void onfocus(function<void(void* userdata)> callback) { focus_cb = callback; }
	
	//Moves focus up or down one step (dir must be -1 or +1). Calls the onfocus callback.
	void move_focus(int dir);
	
	group* child(cstring name, bool can_focus, void* userdata)
	{
		return new group(this, NULL, name, can_focus, userdata);
	}
	
	~chanview();
	
private:
	// Channel/group constructors call this for focusable children.
	// If the widget has no focused row, this one gets focused. (This means the first focusable row gets focused.)
	void focus_if_needed(GtkTreePath* path);
};
