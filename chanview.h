#pragma once
#include "arlib.h"

//don't know if this is guaranteed stable, but I'd rather not include the gtk header here
typedef struct _GtkScrolledWindow GtkScrolledWindow;
typedef struct _GtkTreeRowReference GtkTreeRowReference;
typedef struct _GtkTreeIter GtkTreeIter;
typedef struct _GtkTreeModel GtkTreeModel;
typedef struct _GtkTreeStore GtkTreeStore;
typedef struct _GtkTreeView GtkTreeView;
typedef struct _GtkWidget GtkWidget;
typedef struct _PangoAttrList PangoAttrList;

class chanview : nocopy {
	struct fmt_t {
#define FMT_ATTRS \
		FMT_ATTR(uint32_t, fg, -1, 7) \
		FMT_ATTR(uint32_t, bg, -1, 0) \
		FMT_ATTR(uint32_t, strike, -1, 3) /* -1 = no, -2 = yes, <16777216 = yes, and override fg color */ \
		FMT_ATTR(bool, bold, false, 20) \
		FMT_ATTR(bool, italic, false, 13) \
		
#define FMT_ATTR(type, name, def, bit) type name = def;
		FMT_ATTRS
#undef FMT_ATTR
		
		size_t hash() const
		{
			return 0
#define FMT_ATTR(type, name, def, bit) ^ name<<bit
		FMT_ATTRS
#undef FMT_ATTR
			;
		}
		
		bool operator==(const fmt_t& other) const
		{
			return true // Clang optimizes this to memcmp, gcc doesn't (though it flattens the bools to 32bit AND 0xFFFFFF)
#define FMT_ATTR(type, name, def, bit) && name == other.name
		FMT_ATTRS
#undef FMT_ATTR
			;
		}
#undef FMT_ATTRS
	} fmt;
	
	GtkTreeStore* store;
	GtkTreeView* view;
	GtkScrolledWindow* scrollview;
	
	function<void(void* userdata)> focus_cb;
	function<void(void* userdata)> close_cb;
	map<fmt_t, PangoAttrList*> fmt_attrs;
	
	float scroll_accum = 0; // always in the range (-1..+1)
	
	chanview();
	
	int sort_func(GtkTreeModel* model, GtkTreeIter* a, GtkTreeIter* b);
	
public:
	class group;
	class channel;
	
	class chanbase : nocopy {
		friend class chanview;
		
	protected:
		chanview* cv;
		GtkTreeRowReference* row;
		
		string name;
		void* userdata;
		
		string sort2;
		bool has_sort2 = false;
		
		int sort1 = 0;
		
		fmt_t fmt;
		
		bool focusable;
		
		chanbase(chanview* cv, group* parent, cstring name, bool can_focus, void* userdata);
		
		void set_hidden(group* parent, bool hidden, bool is_dtor = false);
		void set_fmt();
		
	public:
		// -1 is default; anything other than -1 or 0..16777215 is undefined behavior
		// all formatting remains until changed (in onfocus, for example)
		void color_fg(uint32_t xrgb) { this->fmt.fg = xrgb; set_fmt(); }
		void color_bg(uint32_t xrgb) { this->fmt.bg = xrgb; set_fmt(); }
		void set_bold(  bool bold  ) { this->fmt.bold   = bold;   set_fmt(); }
		void set_italic(bool italic) { this->fmt.italic = italic; set_fmt(); }
		void set_strike(bool strike) { this->fmt.strike = strike ? -2 : -1; set_fmt(); }
		void set_strike(bool strike, uint32_t xrgb) { this->fmt.strike = strike ? xrgb : -1; set_fmt(); }
		
		void rename(cstring name) { rename(name, name); }
		void rename(cstring name_show, cstring name_sort);
		void focus(); // will fire the onfocus callback
		
		//key1 defaults to zero, key2 defaults to the channel's name
		void sort_as(int key1, cstring key2);
		
		~chanbase();
	};
	
	class channel : public chanbase {
		group* parent;
		
		friend class chanview;
		channel(chanview* cv, group* parent, cstring name, bool can_focus, void* userdata)
			: chanbase(cv, parent, name, can_focus, userdata), parent(parent)
		{}
		
	public:
		void set_hidden(bool hidden) { chanbase::set_hidden(parent, hidden); }
		
		~channel() {}
	};
	
	//A group is a collection of related channels that roughly corresponds to an IRC server or a Discord guild.
	class group : public chanbase {
		friend class chanview;
		group(chanview* cv, cstring name, bool can_focus, void* userdata)
			: chanbase(cv, NULL, name, can_focus, userdata)
		{}
		
	public:
		// Channels start out hidden. Groups cannot be hidden.
		channel* child(cstring name, bool can_focus, void* userdata) { return new channel(cv, this, name, can_focus, userdata); }
		~group() {}
	};
	
	friend class chanbase;
	friend class channel;
	friend class group;
	
	static chanview* create() { return new chanview(); }
	//it's safe to not use GTK_WIDGET(foo), defining G_DISABLE_CAST_CHECKS replaces it with a straight cast
	GtkWidget* gtkwidget() { return (GtkWidget*)scrollview; }
	
	//There's only one onfocus function per channel view object, but the userdata can vary per group/channel.
	//Can be called on the active channel. The callback is responsible for discarding duplicates.
	void onfocus(function<void(void* userdata)> callback) { focus_cb = callback; }
	void onclose(function<void(void* userdata)> callback) { close_cb = callback; }
	
	//Moves focus up or down one step (dir must be -1 or +1). Calls the onfocus callback.
	void move_focus(int dir);
	
	group* child(cstring name, bool can_focus, void* userdata)
	{
		return new group(this, name, can_focus, userdata);
	}
	
	~chanview();
};
