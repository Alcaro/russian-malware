#include "russian.h"

namespace russian { namespace {

class testp : public protocol {
public:
	textview::image* img = NULL;
	textview::image* img2 = NULL;
	
	void fill(chanbase* chan, int n)
	{
		if (!img)
		{
			static const uint8_t bytes[] = {
				0x47,0x49,0x46,0x38,0x39,0x61,0x10,0x00,0x10,0x00,0xf2,0x00,0x00,0x00,0x00,0x00,
				0x8c,0x59,0x18,0xde,0xa2,0x39,0xff,0xfb,0x00,0xff,0xdb,0x21,0xef,0xf3,0xff,0x00,
				0x00,0x00,0x00,0x00,0x00,0x21,0xf9,0x04,0x01,0x00,0x00,0x06,0x00,0x2c,0x00,0x00,
				0x00,0x00,0x10,0x00,0x10,0x00,0x00,0x03,0x45,0x08,0xb6,0xdc,0x0d,0xd0,0x49,0x03,
				0x41,0x51,0x73,0x59,0x78,0xb1,0xdc,0xd0,0x50,0x7d,0x62,0x04,0x94,0x1e,0x85,0x6a,
				0x44,0x85,0x01,0xed,0xc8,0xba,0xb0,0xfb,0xd0,0xb8,0x83,0xdb,0xdf,0xee,0x04,0x40,
				0x8d,0x0c,0x18,0x30,0x04,0x06,0x03,0x42,0xf1,0xd4,0x32,0x12,0x90,0xc5,0x00,0x41,
				0xa0,0x94,0x56,0xa7,0x4a,0x06,0x11,0x8b,0x25,0x4e,0x88,0xde,0x46,0x02,0x00,0x3b
			};
			img = textview::image::create(bytes, 16, 16);
			
			static const uint8_t bytes2[] = {
				0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a,0x00,0x00,0x00,0x0d,0x49,0x48,0x44,0x52,
				0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x10,0x04,0x03,0x00,0x00,0x00,0xed,0xdd,0xe2,
				0x52,0x00,0x00,0x00,0x15,0x50,0x4c,0x54,0x45,0x6f,0x72,0x6d,0x00,0x00,0x00,0x8c,
				0x59,0x18,0xff,0xdb,0x21,0xff,0xfb,0x00,0xde,0xa2,0x39,0xef,0xf3,0xff,0x46,0xd6,
				0x66,0xee,0x00,0x00,0x00,0x01,0x74,0x52,0x4e,0x53,0x00,0x40,0xe6,0xd8,0x66,0x00,
				0x00,0x00,0x50,0x49,0x44,0x41,0x54,0x78,0x01,0x63,0x00,0x02,0x46,0x01,0x06,0x08,
				0x10,0x13,0x44,0x63,0x30,0x26,0x0a,0x0a,0x40,0x18,0x8e,0x50,0x86,0xa0,0xa3,0x20,
				0x44,0x4e,0x58,0x10,0x9d,0x21,0x88,0xc1,0x60,0x14,0x04,0xeb,0x62,0x52,0x02,0x31,
				0x94,0x14,0x18,0x54,0x9c,0x15,0x04,0x05,0x99,0x4c,0x9c,0x18,0x98,0x4c,0x8d,0x44,
				0x0c,0x95,0x83,0x15,0x18,0x18,0x94,0x94,0x83,0x4d,0x8d,0x94,0x18,0xc0,0xaa,0x94,
				0x80,0x7c,0x00,0x7c,0x39,0x07,0x86,0xbe,0xb4,0x05,0xda,0x00,0x00,0x00,0x00,0x49,
				0x45,0x4e,0x44,0xae,0x42,0x60,0x82
			};
			img2 = textview::image::create(bytes2, 16, 16);
		}
		
		while (n--)
		{
			textview::span msgparts[13];
			msgparts[0].text = "mun";
			msgparts[1].img = img;
			msgparts[1].text = "https://floating.muncher.se/muncher.png";
			msgparts[2].text = "cher" + tostring(n);
			msgparts[3].text = "https://www.reddit.com/r/StartledCats/comments/9rkq4p/a_new_player_has_joined_the_game";
			
			msgparts[0].bold = true;
			msgparts[0].strike = true;
			msgparts[0].fgcol = 0xFF0000;
			msgparts[1].bgcol = 0x0000FF;
			msgparts[2].underline = true;
			msgparts[2].bold = true;
			msgparts[2].italics = true;
			msgparts[2].bgcol = 0xFFFF00;
			msgparts[3].monospace = (n&1);
			msgparts[3].hyperlink = !(n&1);
			
			msgparts[4].text = "y";
			msgparts[5].text = "y";
			msgparts[6].text = "y";
			msgparts[7].text = "y";
			msgparts[8].text = "y";
			msgparts[9].text = "y";
			msgparts[4].monospace = true;
			msgparts[6].monospace = true;
			msgparts[8].monospace = true;
			
			msgparts[10].img = img;
			msgparts[11].img = img;
			msgparts[12].img = img;
			
			chan->message(tostring(n), chanbase::imp_none, time(NULL), msgparts);
			
			chan->user_add("nerd"+tostring(n));
		}
	}
	
	group*   chan1;
	channel* chan2;
	group*   chan3;
	channel* chan4;
	channel* chan8;
	
	DECL_G_TIMER(timer, testp);
	
	testp(impl* parent, bmldeserializer& s, cstring name) : protocol(parent, 0)
	{
		// no parameters
		
		(void)       mkgroup("0 Munchers", chanbase::f_no_focus,                      0);
		chan1 =      mkgroup("1 Muncher",  chanbase::f_no_logs|chanbase::f_no_users,  0);
		chan2 = chan1->child("2 Munchers", chanbase::f_no_logs,                       0); fill(chan2, 2);
		chan3 =      mkgroup("3 Munchers", chanbase::f_no_logs,                       0); fill(chan3, 50);
		(void)  chan3->child("7 Munchers", chanbase::f_no_focus,                      0);
		(void)  chan3->child("5 Munchers", chanbase::f_no_focus,                      0);
		(void)  chan3->child("9 Munchers", chanbase::f_no_focus,                      0);
		chan8 = chan3->child("8 Munchers", chanbase::f_no_focus,                      0);
		(void)  chan3->child("6 Munchers", chanbase::f_no_focus,                      0);
		chan4 = chan3->child("4 Munchers", chanbase::f_no_logs,                       0);
		
		for (int i=0;i<4;i++)
		{
			span msg[3];
			msg[0].text = "<nerd> ";
			msg[2].text = chan1_names[i]+cstring("\naaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa\naaa\n\n\n\naaa\naaa\naaa");
			//msg[2].monospace = true;
			chan1->message(chan1_names[i], chanbase::imp_none, time(NULL), msg);
			chan1->message_edit(chan1_names[i], time(NULL), msg, 1);
		}
		
		auto msg = [this](cstring prev, bool after, cstring newid) {
			span sp[] = { { newid }, { "\n" }, { "\n" }, { "\n" }, { newid } };
			chan4->message_at(prev, after, newid, chanbase::imp_none, time(NULL), sp);
		};
		msg("", true, "h");
		msg("h", false, "a");
		msg("h", true, "n");
		msg("h", false, "b");
		msg("h", true, "m");
		msg("", true, "o");
		msg("h", false, "c");
		msg("h", false, "d");
		msg("h", true, "l");
		msg("", true, "p");
		msg("h", false, "e");
		msg("h", true, "j");
		msg("h", false, "f");
		msg("h", true, "i");
		msg("", true, "q");
		msg("h", false, "g");
		msg("j", true, "k");
		msg("k", true, "???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????");
		
		timer.set_repeat(1000, bind_this(&testp::timer_cb));
	}
	
	const char * chan1_names[4] = { "a:", "b:", "c:", "d:" };
	int chan1_n = 0;
	void action(cstring text, uintptr_t userdata) override
	{
		if (text == "+") { chan2->set_hidden(false); return; }
		if (text == "-") { chan2->set_hidden(true);  return; }
		
		span msg[3];
		msg[0].text = "<nerd> ";
		msg[2].text = chan1_names[chan1_n]+text;
		if (text == ".")
		{
			chan1->message_delete(chan1_names[chan1_n], time(NULL));
			chan1->message(chan1_names[chan1_n], chanbase::imp_none, time(NULL), msg);
		}
		else
		{
			chan1->message_edit(chan1_names[chan1_n], time(NULL), msg, 1);
		}
		
		chan1_n = (chan1_n+1)%4;
		
		chan8->sort_as(0, text);
		chan2->set_hidden(false);
		
		if (chan1_n&1)
			chan3->message_replace_image("7", img, img2);
		else
			chan3->message_replace_image("7", img2, img);
		chan3->message_edit("5", time(NULL), msg, 1);
	}
	
	void begin_private(cstring name) override
	{
		puts(name.c_str());
	}
	
	void close_chan(uintptr_t userdata) override
	{
		chan4->set_hidden(true);
	}
	
	void timer_cb()
	{
		if ((chan1_n&1) == 0)
		{
			span msg[2];
			msg[0].text = "<nerd> x";
			chan2->message(chanbase::imp_none, time(NULL), msg);
		}
	}
};
}
russian::protocol* russian::protocol::create_testp(impl* parent, bmldeserializer& s, cstring name) { return new testp(parent, s, name); }
}
