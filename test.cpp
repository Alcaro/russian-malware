#include "russian.h"

#ifndef ARGUI_NONE
namespace russian { namespace {

class testp : public protocol {
public:
	/*private*/ void fill(chanbase* chan, int n)
	{
		static textview::image* img = NULL;
		if (!img)
		{
			static const uint8_t bytes[] = {
				0x47,0x49,0x46,0x38,0x39,0x61,0x10,0x00,0x10,0x00,0xf2,0x00,0x00,0x00,0x00,0x00,
				0x8c,0x59,0x18,0xde,0xa2,0x39,0xff,0xfb,0x00,0xff,0xdb,0x21,0xef,0xf3,0xff,0x00,
				0x00,0x00,0x00,0x00,0x00,0x21,0xf9,0x04,0x01,0x00,0x00,0x06,0x00,0x2c,0x00,0x00,
				0x00,0x00,0x10,0x00,0x10,0x00,0x00,0x03,0x45,0x08,0xb6,0xdc,0x0d,0xd0,0x49,0x03,
				0x41,0x51,0x73,0x59,0x78,0xb1,0xdc,0xd0,0x50,0x7d,0x62,0x04,0x94,0x1e,0x85,0x6a,
				0x44,0x85,0x01,0xed,0xc8,0xba,0xb0,0xfb,0xd0,0xb8,0x83,0xdb,0xdf,0xee,0x04,0x40,
				0x8d,0x0c,0x18,0x30,0x04,0x06,0x03,0x42,0xf1,0xd4,0x32,0x12,0x90,0xc5,0x00,0x41,
				0xa0,0x94,0x56,0xa7,0x4a,0x06,0x11,0x8b,0x25,0x4e,0x88,0xde,0x46,0x02,0x00,0x3b
			};
			img = new textview::image(bytes, 16, 16);
		}
		
		while (n--)
		{
			textview::span msgparts[4];
			msgparts[0].text = "mun";
			msgparts[1].img = img;
			msgparts[1].text = "https://floating.muncher.se/muncher.png";
			msgparts[2].text = "cher" + tostring(n);
			msgparts[3].text = "https://floating.muncher.se/muncher.png";
			
			msgparts[0].bold = true;
			msgparts[0].strike = true;
			msgparts[0].fgcol = 0xFF0000;
			msgparts[1].bgcol = 0x0000FF;
			msgparts[2].underline = true;
			msgparts[2].bold = true;
			msgparts[2].italics = true;
			msgparts[2].bgcol = 0xFFFF00;
			msgparts[3].hyperlink = true;
			
			chan->message(chanbase::imp_none, time(NULL), msgparts);
			
			chan->user_add("nerd"+tostring(n));
		}
	}
	
	group*   chan1;
	channel* chan2;
	group*   chan3;
	channel* chan8;
	
	testp(impl* parent, bmlunserialize_impl& s) : protocol(parent)
	{
		ser_enter(s) {}
		
		(void)       mkgroup("0 Munchers", chanbase::f_no_focus,                      NULL);
		chan1 =      mkgroup("1 Muncher",  chanbase::f_no_logs|chanbase::f_no_users,  NULL);
		chan2 = chan1->child("2 Munchers", chanbase::f_no_logs,                       NULL); fill(chan2, 2);
		chan3 =      mkgroup("3 Munchers", chanbase::f_no_logs,                       NULL); fill(chan3, 50);
		(void)  chan3->child("7 Munchers", chanbase::f_no_focus,                      NULL);
		(void)  chan3->child("5 Munchers", chanbase::f_no_focus,                      NULL);
		(void)  chan3->child("9 Munchers", chanbase::f_no_focus,                      NULL);
		chan8 = chan3->child("8 Munchers", chanbase::f_no_focus,                      NULL);
		(void)  chan3->child("6 Munchers", chanbase::f_no_focus,                      NULL);
		(void)  chan3->child("4 Munchers", chanbase::f_no_focus,                      NULL);
		
		for (int i=0;i<4;i++)
		{
			span msg[2];
			msg[0].text = "<nerd> ";
			msg[1].text = chan1_names[i];
			chan1->message(chan1_names[i], chanbase::imp_none, time(NULL), msg);
		}
		
		runloop::global()->set_timer_rel(1000, bind_this(&testp::timer_cb));
	}
	
	const char * chan1_names[4] = { "a:", "b:", "c:", "d:" };
	int chan1_n = 0;
	/*virtual*/ void action(cstring text, void* userdata)
	{
		if (text == "+") { chan2->set_hidden(false); return; }
		if (text == "-") { chan2->set_hidden(true);  return; }
		
		span msg[3];
		msg[0].text = "<nerd> ";
		msg[2].text = chan1_names[chan1_n]+text;
		if (text == ".")
		{
			chan1->message_delete(chan1_names[chan1_n], time(NULL));
			chan1->message(chan1_names[chan1_n], chanbase::imp_none, time(NULL), msg);
		}
		else
		{
			chan1->message_edit(chan1_names[chan1_n], time(NULL), msg, 1);
		}
		
		chan1_n = (chan1_n+1)%4;
		
		chan8->sort_as(0, text);
	}
	
	/*virtual*/ russian::chanbase* begin_private(cstring name)
	{
		puts(name.c_str());
		return NULL;
	}
	
	bool timer_cb()
	{
		if ((chan1_n&1) == 0)
		{
			span msg[2];
			msg[0].text = "<nerd> x";
			chan2->message(chanbase::imp_none, time(NULL), msg);
		}
		return true;
	}
};
}
russian::protocol* russian::protocol::create_testp(impl* parent, bmlunserialize_impl& s) { return new testp(parent, s); }
}
#endif
