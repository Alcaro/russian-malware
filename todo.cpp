#include "russian.h"

namespace russian { namespace {

class todo : public protocol {
public:
struct item {
	time_t expiry;
	time_t created = 0; // not serialized
	time_t repeat = 0; // 0 for oneshots
	bool exact = false;
	int8_t sound = -1;
	bool active = false; // not serialized
	uint32_t id = 0; // not serialized
	string text;
	
	template<typename T> void serialize(T& s)
	{
		string at2 = delay_to_time_short(expiry-time(NULL));
		s.items(
			"at2", ser_include_if(s.serializing && at2, at2),
			"at", expiry,
			"repeat", ser_include_if_true(repeat),
			"exact", ser_include_if_true(exact),
			"sound", ser_include_if(sound!=-1, sound),
			"text", text);
	}
};

string m_store_path;
array<item> m_items;
uint32_t m_next_id;
uint32_t m_n_msg = 0xFFFFFFFF;
time_t m_next_msg = 0;

string m_soundplayer;
array<string> m_sounds;

autoptr<group> m_channel;

struct waiter_t : public waiter_fn<void, waiter_t> {
	void complete() { container_of<&todo::m_next>(this)->update(false, true); }
} m_next;

todo(impl* parent, bmldeserializer& s, cstring name) : protocol(parent, 0)
{
	m_channel = mkgroup(name, chanbase::f_no_logs|chanbase::f_no_users|chanbase::f_less_indent, 0);
	span sp[1] = {};
	m_channel->message("ctrl", chanbase::imp_scrollback, 0, sp);
	
	s.items(
		"store", m_store_path,
		"soundplayer", m_soundplayer,
		"sound", m_sounds);
	
	reload_timers();
}
bool reload_timers()
{
	array<item> items_new;
	
	if (!jsondeserialize(file::readallt(file::resolve(file::exedir(), m_store_path)), items_new))
		return false;
	
	m_items = std::move(items_new);
	
	m_next_id = 0;
	for (item& m : m_items)
		m.id = ++m_next_id;
	
	update(false, false);
	return true;
}

array<span> parse(const item& m, uint32_t color, bool can_dismiss = true)
{
	span fmt;
	fmt.fgcol = color;
	array<span> sp;
	parse_irc(sp, fmt, m.text);
	if (can_dismiss)
	{
		bool has_link = false;
		for (size_t n=0;n<sp.size();n++)
		{
			if (sp[n].hyperlink)
			{
				sp.insert(n);
				sp[n].i_link = true;
				sp[n].hidden = true;
				sp[n].text = tostring(m.id)+" "+sp[n+1].text;
				sp[n+1].hyperlink = false;
				sp[n+1].i_link = true;
				has_link = true;
			}
		}
		
		span& sp1 = sp.append();
		sp1.text = " ";
		span& sp2 = sp.append();
		sp2.text = tostring(m.id);
		sp2.hidden = true;
		sp2.i_link = true;
		span& sp3 = sp.append();
		sp3.text = "[Dismiss]";
		sp3.i_link = true;
	}
	return sp;
}

void update(bool changed = true, bool sound = true)
{
	// always sort even if unchanged, in case json is user edited
	m_items.ssort([](const item& a, const item& b){ return a.expiry < b.expiry; });
	
	if (changed)
		file::writeall(file::resolve(file::exedir(), m_store_path), jsonserialize<2>(ser_compact(m_items, 1)));
	
	time_t now = time(NULL);
	time_t next_msg = 0;
	m_next.cancel();
	
	for (size_t i=0;i<m_items.size();i++)
	{
		item& m = m_items[i];
		
		if (m.active) {} // ignore until dismissed
		else if (m.expiry <= now)
		{
			bool important = (m.exact || i>=9999);
			uint32_t color = (m.exact ? 0xFF0000 : 0x000000);
			m_channel->message_before("ctrl", tostring(m.id), important ? chanbase::imp_msg : chanbase::imp_none, 0, parse(m, color));
			m.active = true;
			if (sound && (size_t)m.sound < m_sounds.size())
				system(m_soundplayer.replace("{}", "'"+m_sounds[m.sound].replace("'","'\"'\"'")+"'")+" &");
		}
		else
		{
			next_msg = m.expiry;
			runloop2::await_timeout({ next_msg, 0}).then(&m_next);
			break;
		}
	}
	
	size_t n_msg = 0;
	size_t n_link = 0;
	size_t n_link_limit = 0;
	for (size_t i=0;i<m_items.size();i++)
	{
		item& m = m_items[i];
		if (!m.active) break;
		n_msg++;
		array<span> sp = parse(m, 0, false);
		for (const span& s : sp)
		{
			if (s.hyperlink)
				n_link++;
		}
		if (n_link_limit < 10)
			n_link_limit = n_link;
	}
	
	if (n_msg != m_n_msg || next_msg != m_next_msg)
	{
		m_n_msg = n_msg;
		m_next_msg = next_msg;
		
		span sp[] = { { "openless" }, { format("Open ",n_link_limit," links") }, { " " },
		              { "open" }, { format("Open ",tostring(n_link)," link",((n_link!=1)?"s":"")) }, { " " },
		              { "dismiss" }, { format("Dismiss ",tostring(n_msg)," notification",((n_msg!=1)?"s":"")) },
		              { "" } };
		
		sp[0].hidden = true;
		sp[0].i_link = true;
		sp[1].i_link = true;
		if (n_link == n_link_limit)
		{
			sp[0].text = "";
			sp[1].text = "";
			sp[2].text = "";
		}
		
		sp[3].hidden = true;
		if (n_link == 0)
		{
			sp[4].strike = true;
		}
		else
		{
			sp[3].i_link = true;
			sp[4].i_link = true;
		}
		
		sp[6].hidden = true;
		if (n_msg == 0)
		{
			sp[7].strike = true;
		}
		else
		{
			sp[6].i_link = true;
			sp[7].i_link = true;
		}
		
		if (next_msg)
			sp[8].text = " Next timer at "+time_to_str(next_msg);
		
		m_channel->message_delete_true("ctrl");
		m_channel->message("ctrl", chanbase::imp_scrollback, 0, sp);
	}
}

void status(chanbase& at, cstring text)
{
	if (&at == m_channel)
	{
		span sp[] = { { text } };
		sp[0].fgcol = 0x666666;
		at.message_before("ctrl", "", chanbase::imp_scrollback, 0, sp);
	}
	else
	{
		span sp[] = { { "* "+text } };
		at.message(chanbase::imp_scrollback, time(NULL), sp);
	}
}

static string delay_to_time_short(time_t t)
{
	if (t >= 60*60*24*7)   return tostring(t/(60*60*24*7))+"w";
	if (t >= 60*60*24)     return tostring(t/(60*60*24))+"d";
	else                   return "";
}

static string delay_to_time(time_t t)
{
	if (t <= 0) return "(expired)";
	string ret;
	if (t >= 60*60*24*365) { ret += tostring(t/(60*60*24*365))+"y"; t %= 60*60*24*365; }
	if (t >= 60*60*24*7)   { ret += tostring(t/(60*60*24*7))+"w";   t %= 60*60*24*7; }
	if (t >= 60*60*24)     { ret += tostring(t/(60*60*24))+"d";     t %= 60*60*24; }
	if (t >= 60*60)        { ret += tostring(t/(60*60))+"h";        t %= 60*60; }
	if (t >= 60)           { ret += tostring(t/(60))+"m";           t %= 60; }
	if (t >= 1)            { ret += tostring(t/1)+"s";              t %= 1; }
	return ret;
}

bool try_handle_command(chanbase& at, cstring text, bool is_homechannel)
{
	array<cstring> parts = text.csplit<1>(" ");
	if (!parts[0]) return false;
	cstring cmd = parts[0];
	cstring arg = "";
	if (parts.size() == 2) arg = parts[1];
	
	if (isdigit(cmd[0]) || cmd[0] == '-')
	{
		time_t t = 0;
		int is_bulk = -1;
		bool with_sound = true;
		
		size_t i=0;
		while (i < cmd.length())
		{
			if (i > cmd.length()-2) return false;
			char first = cmd[i];
			char second = cmd[i+1];
			
			if (isdigit(first) || (first == '-' && isdigit(second)))
			{
				size_t start = i;
				while (i < cmd.length() && !isalpha(cmd[i])) i++;
				if (i == cmd.length()) return false;
				
				time_t n;
				if (!fromstring(cmd.substr(start, i), n)) return false;
				
				char type = cmd[i++];
				time_t mul;
				if(0);
				else if (type == 's') mul = 1;
				else if (type == 'm') mul = 60;
				else if (type == 'h') mul = 60*60;
				else if (type == 'd') mul = 60*60*24;
				else if (type == 'w') mul = 60*60*24*7;
				else if (type == 'y') mul = 60*60*24*365;
				else return false;
				
				if (is_bulk == -1 && mul < 60*60*24)
					is_bulk = false;
				
				t += n*mul;
			}
			else if ((first == '-' || first == '+') && (second == 's' || second == 'b' || second == 'e'))
			{
				bool newval = (first == '+');
				if (second == 's')
					with_sound = newval;
				if (second == 'b')
					is_bulk = newval;
				if (second == 'e')
					is_bulk = !newval;
				i += 2;
			}
			else return false;
		}
		if (is_bulk == -1)
			is_bulk = true;
		
		item& m = m_items.append();
		m.created = time(NULL);
		m.expiry = m.created + t;
		m.id = ++m_next_id;
		
		string text;
		if (is_bulk)
		{
			text = "Bulk timer set for "+time_to_str(m.expiry);
		}
		else
		{
			text = "Exact timer set for "+time_to_str(m.expiry);
			m.exact = true;
			
			if (m_sounds && with_sound)
			{
				if (t <= 60*60*4)
				{
					uint32_t used = 0;
					for (const item& m2 : m_items)
					{
						if (!m2.active && m2.sound >= 0 && m2.sound < 32 && m2.expiry < m.created+60*60*4)
							used |= 1 << m2.sound;
					}
					for (size_t i=0;i<32 && i<m_sounds.size();i++)
					{
						if (!(used&(1<<i)))
						{
							m.sound = i;
							goto sound_done;
						}
					}
				}
				m.sound = g_rand(m_sounds.size());
			sound_done:
				if (m.sound >= 0)
				{
					text += " using "+file::basename(m_sounds[m.sound]);
				}
			}
		}
		m.text = cmd;
		if (arg) m.text += " "+arg;
		status(at, text);
		update();
		
		return true;
	}
	
	if (is_homechannel && cmd == "ls")
	{
		time_t now = time(NULL);
		string ret;
		for (item& m : m_items)
		{
			if (!m.active && m.text.icontains(arg))
			{
				ret += "("+tostring(m.id)+") "+delay_to_time(m.expiry-now)+" "+m.text+"\n";
			}
		}
		if (!ret) ret = "No matches\n";
		status(at, ret.substr(0, ~1));
		return true;
	}
	if (is_homechannel && cmd == "rm")
	{
		uint32_t id;
		if (fromstring(arg, id))
		{
			for (size_t i=0;i<m_items.size();i++)
			{
				if (m_items[i].id == id)
				{
					m_items.remove(i);
					update();
					status(at, "Removed");
					return true;
				}
			}
			status(at, "Not found");
			return true;
		}
		else
		{
			size_t match;
			size_t n_match = 0;
			for (size_t i=0;i<m_items.size();i++)
			{
				if (m_items[i].text.icontains(arg))
				{
					match = i;
					n_match++;
				}
			}
			if (n_match == 1)
			{
				dismiss(match);
				update();
				status(at, "Removed");
			}
			else
			{
				status(at, tostring(n_match)+" matches");
			}
			return true;
		}
	}
	if (is_homechannel && cmd == "reload")
	{
		for (size_t i=0;i<m_items.size() && m_items[i].active;i++)
		{
			m_channel->message_delete_true(tostring(m_items[i].id));
		}
		if (reload_timers())
			status(at, "Done");
		else
			status(at, "Invalid JSON");
		return true;
	}
	
	return false;
}

void dismiss(size_t i)
{
	item& m = m_items[i];
	m_channel->message_edit_true(tostring(m.id), 0, parse(m, 0x666666, false));
	
	if (m_items[i].repeat)
	{
		m_items[i].active = false;
		m_items[i].expiry += m_items[i].repeat;
		m_items[i].id = ++m_next_id;
	}
	else
	{
		m_items.remove(i);
	}
}

ga_handle_t global_action(chanbase& at, uint32_t serial, cstrnul text) override
{
	bool is_homechannel = (&at == m_channel);
	bool has_slash = (text.startswith("/"));
	bool is_set_timer = (text.length() >= 2 && text[0] == '/' && (isdigit(text[1]) || text[1] == '-'));
	if (is_homechannel || is_set_timer)
	{
		if (try_handle_command(at, text.substr((has_slash?1:0), ~0), is_homechannel))
			return ga_handled;
	}
	return ga_not_handled;
}
void action(chanbase& at, cstrnul text) override
{
	status(at, "Unknown or invalid command");
}

void ilink(string text) override
{
	if (text == "open" || text == "openless")
	{
		size_t limit = (text == "open" ? SIZE_MAX : 10);
		size_t i = 0;
		array<string> links;
		
		while (i < m_items.size() && m_items[i].active && links.size() < limit)
		{
			bool has_link = false;
			array<span> sp = parse(m_items[i], 0, false);
			for (const span& s : sp)
			{
				if (s.hyperlink)
				{
					links.append(s.text);
					has_link = true;
				}
			}
			if (has_link)
				dismiss(i);
			else
				i++;
		}
		open_links(links.cast<cstring>());
		update();
		return;
	}
	if (text == "dismiss")
	{
		while (m_items && m_items[0].active)
			dismiss(0);
		update();
		return;
	}
	
	array<cstring> parts = text.csplit<1>(" ");
	if (parts.size() == 2)
		open_link(parts[1]);
	size_t id = try_fromstring<size_t>(parts[0]);
	for (size_t i=0;i<m_items.size();i++)
	{
		if (m_items[i].id == id)
		{
			dismiss(i);
			update();
			break;
		}
	}
}

void begin_private(chanbase& at, cstrnul name) override {} // no users on this protocol
void close_chan(chanbase& at) override {} // only one channel, and groups can't be closed anyways
};

}
protocol*
protocol::create_todo(impl* parent, bmldeserializer& s, cstring name) { return new todo(parent, s, name); }
}
