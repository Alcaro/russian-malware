#include "russian.h"

namespace russian {
namespace {

static string shellescape(cstring in)
{
	// unix only
	// it's safe to return input unchanged if it matches [A-Za-z0-9.-_/]+, but no real point
	return "'"+in.replace("'","'\"'\"'")+"'";
}

class todo : public protocol {
public:
struct item {
	time_t expiry;
	time_t created = 0; // not serialized
	time_t repeat = 0; // 0 for oneshots
	bool exact = false;
	int8_t sound = -1;
	bool active = false; // not serialized
	uint32_t id = 0; // not serialized
	string text;
	
	template<typename T> void serialize(T& s)
	{
		s.items(
			"at", expiry,
			"repeat", ser_include_if(repeat, repeat),
			"exact", ser_include_if(exact, exact),
			"sound", ser_include_if(sound!=-1, sound),
			"text", text);
	}
};

string m_store_path;
array<item> m_items;
uint32_t m_next_id = 0;
bool m_any_active_has_link = false;

string m_soundplayer;
array<string> m_sounds;

autoptr<group> m_channel;
DECL_G_TIMER(m_next, todo);

todo(impl* parent, bmldeserializer& s, cstring name) : protocol(parent, 0)
{
	m_channel = mkgroup(name, chanbase::f_no_logs|chanbase::f_no_users|chanbase::f_less_indent, 0);
	span sp[] = { { "a" } };
	m_channel->message("ctrl", chanbase::imp_none, 0, sp);
	
	s.items(
		"store", m_store_path,
		"soundplayer", m_soundplayer,
		"sound", m_sounds);
	
	jsondeserialize(file::readallt(file::resolve(file::exedir(), m_store_path)), m_items);
	
	for (item& m : m_items)
		m.id = ++m_next_id;
	
	update(false, false, true, false);
}

array<span> parse(const item& m, uint32_t color, bool can_dismiss = true)
{
	span fmt;
	fmt.fgcol = color;
	array<span> sp;
	parse_irc(sp, fmt, m.text);
	if (can_dismiss)
	{
		bool has_link = false;
		for (size_t n=0;n<sp.size();n++)
		{
			if (sp[n].hyperlink)
			{
				sp.insert(n);
				sp[n].i_link = true;
				sp[n].hidden = true;
				sp[n].text = tostring(m.id)+" "+sp[n+1].text;
				sp[n+1].hyperlink = false;
				sp[n+1].i_link = true;
				has_link = true;
			}
		}
		
		span& sp1 = sp.append();
		sp1.text = " ";
		span& sp2 = sp.append();
		sp2.text = tostring(m.id);
		sp2.hidden = true;
		sp2.i_link = true;
		span& sp3 = sp.append();
		sp3.text = "[Dismiss]";
		sp3.i_link = true;
	}
	return sp;
}

void update(bool sort, bool write, bool ctrl, bool sound)
{
	if (sort)
		m_items.ssort([](const item& a, const item& b){ return a.expiry < b.expiry; });
	if (write)
		file::writeall(file::resolve(file::exedir(), m_store_path), jsonserialize<2>(ser_compact(m_items, 1)));
	
	time_t now = time(NULL);
	time_t next_msg = 0;
	m_next.reset();
	
	for (size_t i=0;i<m_items.size();i++)
	{
		item& m = m_items[i];
		
		if (m.active) {} // ignore until dismissed
		else if (m.expiry <= now)
		{
			bool important = (m.exact || i>=14);
			uint32_t color = (m.exact ? 0xFF0000 : 0x000000);
			m_channel->message_before("ctrl", tostring(m.id), important ? chanbase::imp_msg : chanbase::imp_none, 0, parse(m, color));
			m.active = true;
			if (sound && (size_t)m.sound < m_sounds.size())
				system(m_soundplayer.replace("{}", shellescape(m_sounds[m.sound])));
		}
		else
		{
			next_msg = m.expiry;
			m_next.set_abs(next_msg, [this](){ update(false, false, true, true); });
			break;
		}
	}
	
	if (ctrl)
	{
		size_t n_msg = 0;
		size_t n_link = 0;
		for (size_t i=0;i<m_items.size();i++)
		{
			item& m = m_items[i];
			if (!m.active) break;
			n_msg++;
			array<span> sp = parse(m, 0, false);
			for (const span& s : sp)
			{
				if (s.hyperlink)
					n_link++;
			}
		}
		
		span sp[] = { { "open" }, { "Open "+tostring(n_link)+" link"+((n_link!=1)?"s":"") }, { " " },
		              { "dismiss" }, { "Dismiss "+tostring(n_msg)+" notification"+((n_msg!=1)?"s":"") },
		              { "" } };
		
		sp[0].hidden = true;
		if (n_link == 0)
		{
			sp[1].strike = true;
		}
		else
		{
			sp[0].i_link = true;
			sp[1].i_link = true;
		}
		
		sp[3].hidden = true;
		if (n_msg == 0)
		{
			sp[4].strike = true;
		}
		else
		{
			sp[3].i_link = true;
			sp[4].i_link = true;
		}
		
		if (next_msg)
			sp[5].text = " Next timer at "+time_to_str(next_msg);
		
		m_channel->message_edit_true("ctrl", 0, sp);
	}
}

void status(chanbase& at, cstring text)
{
	if (&at == m_channel)
	{
		span sp[] = { { text } };
		sp[0].fgcol = 0x666666;
		at.message_before("ctrl", "", chanbase::imp_scrollback, 0, sp);
	}
	else
	{
		span sp[] = { { "* "+text } };
		at.message(chanbase::imp_scrollback, time(NULL), sp);
	}
}

string delay_to_time(time_t t)
{
	if (t <= 0) return "(expired)";
	string ret;
	if (t >= 60*60*24*365) { ret += tostring(t/(60*60*24*365))+"y"; t %= 60*60*24*365; }
	if (t >= 60*60*24*7)   { ret += tostring(t/(60*60*24*7))+"w";   t %= 60*60*24*7; }
	if (t >= 60*60*24)     { ret += tostring(t/(60*60*24))+"d";     t %= 60*60*24; }
	if (t >= 60*60)        { ret += tostring(t/(60*60))+"h";        t %= 60*60; }
	if (t >= 60)           { ret += tostring(t/(60))+"m";           t %= 60; }
	if (t >= 1)            { ret += tostring(t/1)+"s";              t %= 1; }
	return ret;
}

bool try_handle_command(chanbase& at, cstring text)
{
	array<cstring> parts = text.csplit<1>(" ");
	if (!parts[0]) return false;
	cstring cmd = parts[0];
	cstring arg = "";
	if (parts.size() == 2) arg = parts[1];
	
	if (isdigit(cmd[0]) || cmd[0] == '-')
	{
		time_t t = 0;
		bool is_bulk = true;
		
		size_t i=0;
		while (i < cmd.length())
		{
			size_t start = i;
			while (i < cmd.length() && !isalpha(cmd[i])) i++;
			if (i == cmd.length()) return false;
			
			time_t n;
			if (!fromstring(cmd.substr(start, i), n)) return false;
			
			char type = cmd[i++];
			time_t mul;
			if(0);
			else if (type == 's') mul = 1;
			else if (type == 'm') mul = 60;
			else if (type == 'h') mul = 60*60;
			else if (type == 'd') mul = 60*60*24;
			else if (type == 'w') mul = 60*60*24*7;
			else if (type == 'y') mul = 60*60*24*365;
			else return false;
			
			if (mul < 60*60*24) is_bulk = false;
			if (i != cmd.length()) is_bulk = false;
			
			t += n*mul;
		}
		
		item& m = m_items.append();
		m.created = time(NULL);
		m.expiry = m.created + t;
		m.id = ++m_next_id;
		
		string text;
		if (is_bulk)
		{
			text = "Bulk timer set for "+time_to_str(m.expiry);
		}
		else
		{
			text = "Exact timer set for "+time_to_str(m.expiry);
			m.exact = true;
			
			if (m_sounds)
			{
				if (t <= 60*60*4)
				{
					uint32_t used = 0;
					for (const item& m2 : m_items)
					{
						if (!m2.active && m2.sound >= 0 && m2.sound < 32 && m2.expiry < m.created+60*60*4)
							used |= 1 << m2.sound;
					}
					for (size_t i=0;i<32 && i<m_sounds.size();i++)
					{
						if (!(used&(1<<i)))
						{
							m.sound = i;
							goto sound_done;
						}
					}
				}
				m.sound = g_rand(m_sounds.size());
			sound_done:
				if (m.sound >= 0)
				{
					text += " using "+file::basename(m_sounds[m.sound]);
				}
			}
		}
		// TODO: bulk/exact override, sound override, repeat
		m.text = cmd;
		if (arg) m.text += " "+arg;
		status(at, text);
		update(true, true, true, true);
		
		return true;
	}
	
	if (cmd == "ls")
	{
		time_t now = time(NULL);
		string ret;
		for (item& m : m_items)
		{
			if (!m.active && m.text.contains(arg))
			{
				ret += "("+tostring(m.id)+") "+delay_to_time(m.expiry-now)+" "+m.text+"\n";
			}
		}
		if (!ret) ret = "No matches\n";
		status(at, ret.substr(0, ~1));
		return true;
	}
	if (cmd == "rm")
	{
		uint32_t id;
		if (!fromstring(arg, id)) return false;
		for (size_t i=0;i<m_items.size();i++)
		{
			if (m_items[i].id == id)
			{
				m_items.remove(i);
				update(true, true, true, true);
				status(at, "Removed");
				return true;
			}
		}
		return false;
	}
	
	return false;
}

void dismiss(size_t i, bool sync = true)
{
	item& m = m_items[i];
	m_channel->message_edit_true(tostring(m.id), 0, parse(m, 0x666666, false));
	
	if (m_items[i].repeat)
	{
		m_items[i].active = false;
		m_items[i].expiry += m_items[i].repeat;
		m_items[i].id = ++m_next_id;
		sync = true;
	}
	else
	{
		m_items.remove(i);
	}
	if (sync)
		update(true, true, true, true);
}

void action(chanbase& at, cstring text) override
{
	if (!text) return;
	if (text[0] == '/') text = text.substr(1, ~0);
	if (!try_handle_command(at, text))
		status(at, "Unknown or invalid command");
}

ga_handle_t global_action(chanbase& at, uint32_t serial, cstring text) override
{
	if (text.length() >= 2 && text[0] == '/' && (isdigit(text[1]) || text[1] == '-'))
	{
		if (try_handle_command(at, text.substr(1, ~0)))
			return ga_handled;
	}
	return ga_not_handled;
}

void ilink(string text) override
{
	if (text == "open")
	{
		size_t i = 0;
		string command = "x-www-browser";
		
		while (i < m_items.size() && m_items[i].active)
		{
			bool has_link = false;
			array<span> sp = parse(m_items[i], 0, false);
			for (const span& s : sp)
			{
				if (s.hyperlink)
				{
					//textview::open_link(s.text); // this function gives a 10 second delay for some links if many are opened too quickly
					command += " "+shellescape(s.text);
					has_link = true;
				}
			}
			if (has_link)
				dismiss(i, false);
			else
				i++;
		}
		system(command);
		update(true, true, true, true);
		return;
	}
	if (text == "dismiss")
	{
		while (m_items && m_items[0].active)
			dismiss(0, false);
		update(true, true, true, true);
		return;
	}
	
	array<cstring> parts = text.csplit<1>(" ");
	if (parts.size() == 2)
		textview::open_link(parts[1]);
	size_t id = try_fromstring<size_t>(parts[0]);
	for (size_t i=0;i<m_items.size();i++)
	{
		if (m_items[i].id == id)
		{
			dismiss(i);
			break;
		}
	}
}

void begin_private(chanbase& at, cstring name) override {} // no users on this protocol
void close_chan(chanbase& at) override {} // only one channel, and groups can't be closed anyways
};

}
protocol*
protocol::create_todo(impl* parent, bmldeserializer& s, cstring name) { return new todo(parent, s, name); }
}
