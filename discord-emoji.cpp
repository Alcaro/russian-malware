#include "discord.h"

namespace russian {

namespace {
class discord_emoji_impl : public discord_emoji
{
public:

unsigned imgsize;

zip z;

struct emoji {
	string unicode; // "üí©"
	string name; // ":poop:"
	
	size_t zipidx; // index to the zip, or -1 if no image
	mutable autoptr<textview::image> img; // image; null for most entries, non-null for anything that's been used
};
array<emoji> uniq_emoji;
map<string, emoji*> from_name; // [":poop:"] and [":hankey:"] point to the same item
map<string, emoji*> from_unicode; // grapheme cluster to emoji, nothing tricky

array<emoji*> avatars; // always sorted same way each run (same order as emoji.json), but the exact order is arbitrary and nonsensical
array<cstring> emoji_names; // points to emoji::name, sorted alphabetically

static string delete_fe0f(cstring in)
{
	if (in.contains(u8"\u200d")) return in;
	else return in.replace(u8"\ufe0f","");
}
static bool can_delete_fe0f(cstring in)
{
	return (in.contains(u8"\ufe0f") && !in.contains(u8"\u200d"));
}

struct emoji_raw_t {
	string unicode;
	array<string> names;
	string file;
	
	SERIALIZE(unicode, names, file);
};

discord_emoji_impl(arrayview<uint8_t> data, unsigned imgsize)
{
	this->imgsize = imgsize;
	
	z.init(data);
	
	map<string, size_t> zip_fname_id;
	for (size_t i=0;i<z.files().size();i++)
	{
		zip_fname_id.insert(z.files()[i], i);
	}
	
	auto emoji_raw = jsondeserialize<array<emoji_raw_t>>(cstring(z.read_idx(zip_fname_id.get_or("emoji.json", -1))));
	if (!emoji_raw) return;
	
	// pre-size this array, so pointers to it can be created
	// this is also why the entire json is processed before compiling it to proper structs
	uniq_emoji.resize(emoji_raw.size());
	
	size_t id = 0;
	for (emoji_raw_t& item : emoji_raw)
	{
		emoji* em = &uniq_emoji[id++];
		em->unicode = item.unicode;
		em->name = item.names[0];
		
		cstring fname = item.file;
		if (fname)
			em->zipidx = zip_fname_id[fname];
		else
			em->zipidx = (size_t)-1;
		
		for (cstring subname : item.names)
			from_name.insert(subname, em);
		
		from_unicode.insert(em->unicode, em);
		if (can_delete_fe0f(em->unicode))
			from_unicode.insert(delete_fe0f(em->unicode), em);
		
		if (em->zipidx != (size_t)-1) // if it has an image...
		{
			uint32_t n = 0;
			// and is not a ligature (most of them are duplicates (skin color) or likely provably inaccurate (flags)),
			// then it's usable as avatar
			// exceptions: the keycaps are allowed, 23 of the 24 clocks are duplicates, and fe0f doesn't count as ligature
			uint32_t firstcp = em->unicode.codepoint_at(n);
			if (firstcp >= 0x1F551 && firstcp <= 0x1F567) {}
			else if (n == em->unicode.length() || firstcp <= 0x7F ||
				(n == em->unicode.length()-3 && em->unicode.endswith(u8"\ufe0f")))
			{
				avatars.append(em);
			}
		}
		
		emoji_names.append(em->name);
	}
	
	emoji_names.sort(&string::less);
}

arrayview<cstring> names() const override
{
	return emoji_names;
}

bool insert(array<span>& out, const span& fmt, cstring name) const override
{
	const emoji* em = from_name.get_or(name, NULL);
	if (!em) return false;
	
	if (em->zipidx == (size_t)-1)
	{
		out.append(fmt).text = delete_fe0f(em->unicode);
		return true;
	}
	
	if (!em->img)
		em->img = textview::image::create(z.read_idx(em->zipidx), imgsize, imgsize);
	
	span& sp = out.append(fmt);
	sp.img = em->img;
	sp.text = name;
	
	return true;
}

// returns the new position in the string
// input must be utf8 without surrogates, prefixed with one optional continuation character
// matches https://github.com/lodash/lodash/blob/6018350ac10d5ce6a5b7db625140b82aeab804df/.internal/unicodeToArray.js
static uint32_t next_grapheme_cluster(cstring in, uint32_t at)
{
	enum cclass_t {
		cc_combo, // various combining characters, like U+0303
		cc_var, // variation selectors, FE0E-FE0F
		cc_zwj, // zero width joiner, 200D
		cc_low, // 0000-FFFF
		// keep the order, <= cc_low must work
		
		cc_fitz, // fitzpatrick skin tones, 1F3FB-1F3FF
		cc_regional, // regional indicator letters, 1F1E6-1F1FF
		cc_high, // 10000-10FFFF
		
		cc_any, // 0000-10FFFF
		cc_eof
	};
	auto classify = [](int32_t codepoint)->cclass_t {
		if (LIKELY(codepoint >= 0x00 && codepoint <= 0xFF)) return cc_low;
		if (codepoint == -1) return cc_eof;
		if (codepoint >= 0x0300 && codepoint <= 0x036f) return cc_combo;
		if (codepoint >= 0xfe20 && codepoint <= 0xfe2f) return cc_combo;
		if (codepoint >= 0x20d0 && codepoint <= 0x20ff) return cc_combo;
		if (codepoint >= 0x1ab0 && codepoint <= 0x1aff) return cc_combo;
		if (codepoint >= 0x1dc0 && codepoint <= 0x1dff) return cc_combo;
		if (codepoint >= 0xfe0e && codepoint <= 0xfe0f) return cc_var;
		if (codepoint >= 0x1f3fb && codepoint <= 0x1f3ff) return cc_fitz;
		if (codepoint >= 0x1f1e6 && codepoint <= 0x1f1ff) return cc_regional;
		if (codepoint == 0x200d) return cc_zwj;
		if (codepoint <= 0xffff) return cc_low;
		return cc_high;
	};
	
	uint32_t ia, ib, ic;
	cclass_t ca, cb;
	// ia points to the start of ca, ib to cb, ic to after cb
	
	auto match = [](cclass_t cc, cclass_t accept)->bool {
		if (accept == cc_any) return true;
		if (accept == cc_low && cc <= cc_low) return true;
		if (accept == cc) return true;
		return false;
	};
	auto shift = [&]() {
		ia = ib;
		ca = cb;
		ib = ic;
		cb = classify(in.codepoint_at(ic));
	};
	auto include = [&](cclass_t a, cclass_t b = cc_eof)->bool {
		if (match(ca, a))
		{
			if (b == cc_eof)
			{
				shift();
				return true;
			}
			if (match(cb, b))
			{
				shift();
				shift();
				return true;
			}
		}
		return false;
	};
	
	ic = at;
	shift();
	shift();
	
	// [FITZ](?=[FITZ])|(?:[LOW][COMBO]?|[COMBO]|(?:[REGIONAL]){2}|[HIGH]|[ASTRAL])[VAR]?(?:[COMBO]|[FITZ])?
	// (?:[ZWJ](?:[LOW]|(?:[REGIONAL]){2}|[HIGH])[VAR]?(?:[COMBO]|[FITZ])?)*
	if (ca == cc_fitz && cb == cc_fitz) return ib;
	if (!include(cc_low, cc_combo))
	{
	zwj_loop:
		include(cc_regional, cc_regional) || include(cc_any);
	}
	include(cc_var);
	include(cc_combo) || include(cc_fitz);
	if (include(cc_zwj))
	{
		if (ca == cc_eof) return ia-3; // strlen(zwj)
		goto zwj_loop;
	}
	
	return ia;
}

string translate(cstring in) const override
{
	string out;
	uint32_t pos = 0;
	bool skip_flag_check = false;
	while (pos < in.length())
	{
		uint32_t next = next_grapheme_cluster(in, pos);
		cstring clust = in.substr(pos, next);
		
		if (clust == "üè¥" && !skip_flag_check) // the flag is U+1F3F4
		{
			uint32_t flag_start = pos;
			
		again:
			if (next == in.length()) return out; // no really, this is what discord does
			
			pos = next;
			next = next_grapheme_cluster(in, pos);
			
			if (next-pos == 4) // if next cluster starts with a Tags character, but contains something else too, ignore it
			{
				uint32_t tmp = pos;
				uint32_t cp = in.codepoint_at(tmp);
				if (cp >= 0xE0061 && cp <= 0xE007A) goto again;
				if (cp == 0xE007F)
				{
					clust = in.substr(flag_start, next);
					goto done;
				}
			}
			
			skip_flag_check = true;
			clust = in.substr(flag_start, pos);
			next = pos;
		}
		else skip_flag_check = false;
	done:
		pos = next;
		
		const emoji * em = from_unicode.get_or(clust, nullptr);
		if (em) out += em->name;
		else out += clust;
	}
	
	return out;
}

textview::image* pick_avatar(uint64_t seed) const override
{
	if (!avatars.size())
		return NULL;
	const emoji* em = avatars[seed % avatars.size()];
	if (!em->img)
		em->img = textview::image::create(z.read_idx(em->zipidx), imgsize, imgsize); // zipidx is known set if it's in avatars
	return em->img;
}

};
}

discord_emoji* discord_emoji::create(arrayview<uint8_t> data, unsigned imgsize)
{
	return new discord_emoji_impl(data, imgsize);
}

#ifdef ARLIB_TEST
discord_emoji* discord_emoji_get_test();
discord_emoji* discord_emoji_get_test()
{
	static discord_emoji* emoji = nullptr;
	if (!emoji)
	{
		array<uint8_t> zip = file::readall("discord-emoji.zip");
		if (!zip) test_fail("emoji library not found");
		
		emoji = discord_emoji::create(zip, 16);
		assert_eq(emoji->names().size(), 3038+3); // 3038 images + r/c/tm
	}
	return emoji;
}

test("Discord emoji - init", "", "d-emoji-preload") { discord_emoji_get_test(); } // in a separate test, it's slow
test("Discord emoji - translate", "d-emoji-preload", "d-emoji")
{
	discord_emoji* emoji = discord_emoji_get_test();
	
	assert_eq(emoji->translate("üí© üëåüèª üëå üèª üèªüèª üëåüí© ¬©"),
	          ":poop: :ok_hand_tone1: :ok_hand: üèª üèª:skin-tone-1: :ok_hand::poop: :copyright:");
	assert_eq(emoji->translate("3 üè≥Ô∏è‚Äçüåà üá∑üá∫ üá∑""üáª üá∑"), "3 :rainbow_flag: :flag_ru: üá∑""üáª :regional_indicator_r:");
	assert_eq(emoji->translate("üè≥Ô∏è‚Äçüåà üá∑üá∫ üá∑""üáª 3"), ":rainbow_flag: :flag_ru: üá∑""üáª 3");
	assert_eq(emoji->translate(u8"3\u20e3 3\ufe0f\u20e3"), ":three: :three:");
	
#define t_g u8"\U000e0067"
#define t_e u8"\U000e007f"
#define t_gbsct u8"\U000e0067\U000e0062\U000e0073\U000e0063\U000e0074"
#define t_gbsct_e t_gbsct t_e
#define zwj u8"\u200d"
	assert_eq(emoji->translate("üè¥" t_gbsct_e), ":scotland:");
	assert_eq(emoji->translate("üè¥" t_g t_g t_g t_e), "üè¥" t_g t_g t_g t_e);
	assert_eq(emoji->translate("üè¥" t_e), "üè¥" t_e);
	assert_eq(emoji->translate("üè¥"), "");
	assert_eq(emoji->translate("üè¥" t_g "üè¥"), "üè¥" t_g ":flag_black:");
	assert_eq(emoji->translate("üè¥" t_gbsct), "");
	assert_eq(emoji->translate("üè¥üè¥"), ":flag_black::flag_black:");
	assert_eq(emoji->translate("üè¥üè¥" t_gbsct_e), ":flag_black::flag_black:" t_gbsct_e);
	assert_eq(emoji->translate("üî•" zwj "üî•"), "üî•" zwj "üî•");
	assert_eq(emoji->translate("üî•" zwj), ":fire:" zwj);
	assert_eq(emoji->translate("üè¥" t_gbsct_e zwj "üî•"), "üè¥" t_gbsct_e zwj "üî•");
#undef t_g
#undef t_gbsct
#undef t_e
#undef zwj
}
test("Discord emoji - insert", "d-emoji-preload", "d-emoji")
{
	discord_emoji* emoji = discord_emoji_get_test();
	
	span fmt;
	fmt.bgcol = 0x123456;
	
	array<span> spans;
	assert(emoji->insert(spans, fmt, ":poop:"));
	assert(emoji->insert(spans, fmt, ":ok_hand_tone1:"));
	assert(emoji->insert(spans, fmt, ":ok_hand::skin-tone-1:"));
	assert(emoji->insert(spans, fmt, ":hankey:"));
	assert(emoji->insert(spans, fmt, ":copyright:"));
	assert(!emoji->insert(spans, fmt, ":not_emoji:"));
	
	assert_eq(spans.size(), 5);
	assert_eq(spans[0].text, ":poop:");
	assert_eq(spans[1].text, ":ok_hand_tone1:");
	assert_eq(spans[2].text, ":ok_hand::skin-tone-1:");
	assert_eq(spans[3].text, ":hankey:");
	assert_eq(spans[4].text, "¬©");
	assert(spans[0].img == spans[3].img);
	assert(spans[0].img != spans[1].img);
	assert(spans[1].img == spans[2].img);
	assert(!spans[4].img);
	
	assert_eq(spans[0].bgcol, 0x123456);
	assert_eq(spans[1].bgcol, 0x123456);
	assert_eq(spans[2].bgcol, 0x123456);
	assert_eq(spans[3].bgcol, 0x123456);
	assert_eq(spans[4].bgcol, 0x123456);
}
#endif

}
