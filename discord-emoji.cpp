#include "discord.h"

namespace russian {

namespace {
class discord_emoji_impl : public discord_emoji
{
public:

unsigned imgsize;

zip z;

array<emoji> uniq_emoji;
map<cstring, emoji*> from_name; // [":poop:"] and [":hankey:"] point to the same item (keys point to their names array)
map<string, emoji*> from_unicode; // grapheme cluster to emoji, nothing tricky (not cstring, since unicode contains fe0f)

array<const emoji*> emoji_pointers;

static string delete_fe0f(const emoji * em)
{
	if (em->delete_fe0f) return em->unicode.replace(u8"\ufe0f","");
	else return em->unicode;
}

// should be in the function, but that throws an 'invalid declaration of member template in local class' error
struct emoji_raw_t {
	string unicode;
	array<string> names;
	string file;
	bool fe0f_only = false;
	
	SERIALIZE(unicode, names, file, fe0f_only);
};

discord_emoji_impl(bytesr data, unsigned imgsize)
{
	this->imgsize = imgsize;
	
	z.init(data);
	
	map<string, size_t> zip_fname_id;
	zip_fname_id.insert("", (size_t)-1);
	for (size_t i=0;i<z.files().size();i++)
	{
		zip_fname_id.insert(z.files()[i], i);
	}
	
	auto emoji_raw = jsondeserialize<array<emoji_raw_t>>(cstring(z.read_idx(zip_fname_id.get_or("emoji.json", -1))));
	if (!emoji_raw) return;
	
	// pre-size this array, so pointers to it can be created
	// this is also why the entire json is processed before compiling it to proper structs
	uniq_emoji.resize(emoji_raw.size());
	
	size_t id = 0;
	for (emoji_raw_t& item : emoji_raw)
	{
		emoji* em = &uniq_emoji[id++];
		em->unicode = std::move(item.unicode);
		em->names = std::move(item.names);
		em->zipidx = zip_fname_id[item.file];
		em->delete_fe0f = (!item.fe0f_only && em->unicode.contains(u8"\ufe0f") && !em->unicode.contains(u8"\u200d"));
		
		for (cstring subname : em->names)
			from_name.insert(subname, em);
		
		from_unicode.insert(em->unicode, em);
		if (em->delete_fe0f)
			from_unicode.insert(delete_fe0f(em), em);
		
		emoji_pointers.append(em);
	}
	emoji_pointers.sort([](const emoji* a, const emoji* b) { return string::less(a->names[0].substr(1, ~1), b->names[0].substr(1, ~1)); });
}

arrayview<const emoji*> list() const override { return emoji_pointers; }

textview::image* get_image(const emoji* em) const override
{
	if (!em->has_image()) return NULL;
	if (!em->img)
		em->img = textview::image::create(z.read_idx(em->zipidx), imgsize, imgsize);
	return em->img;
}

bool insert_by_name(array<span>& out, const span& fmt, cstring name) const override
{
	const emoji* em = from_name.get_or(name, NULL);
	if (!em) return false;
	
	if (em->zipidx == (size_t)-1)
	{
		out.append(fmt).text = delete_fe0f(em);
		return true;
	}
	
	if (!em->img)
		em->img = textview::image::create(z.read_idx(em->zipidx), imgsize, imgsize);
	
	span& sp = out.append(fmt);
	sp.img = em->img;
	sp.text = name;
	
	return true;
}

// returns the new position in the string
// input must be utf8 (surrogates aren't utf8), prefixed with one optional continuation character
// matches https://github.com/lodash/lodash/blob/6018350ac10d5ce6a5b7db625140b82aeab804df/.internal/unicodeToArray.js
static uint32_t next_grapheme_cluster(cstring in, uint32_t at)
{
	enum cclass_t {
		cc_combo, // various combining characters, like U+0303
		cc_var, // variation selectors, FE0E-FE0F
		cc_zwj, // zero width joiner, 200D
		cc_low, // 0000-FFFF
		// keep the order, <= cc_low must work
		
		cc_fitz, // fitzpatrick skin tones, 1F3FB-1F3FF
		cc_regional, // regional indicator letters, 1F1E6-1F1FF
		cc_high, // 10000-10FFFF
		
		cc_any, // 0000-10FFFF
		cc_eof
	};
	auto classify = [](int32_t codepoint)->cclass_t {
		if (LIKELY(codepoint >= 0x00 && codepoint <= 0xFF)) return cc_low;
		if (codepoint >= 0x0300 && codepoint <= 0x036f) return cc_combo;
		if (codepoint >= 0xfe20 && codepoint <= 0xfe2f) return cc_combo;
		if (codepoint >= 0x20d0 && codepoint <= 0x20ff) return cc_combo;
		if (codepoint >= 0x1ab0 && codepoint <= 0x1aff) return cc_combo;
		if (codepoint >= 0x1dc0 && codepoint <= 0x1dff) return cc_combo;
		if (codepoint >= 0xfe0e && codepoint <= 0xfe0f) return cc_var;
		if (codepoint >= 0x1f3fb && codepoint <= 0x1f3ff) return cc_fitz;
		if (codepoint >= 0x1f1e6 && codepoint <= 0x1f1ff) return cc_regional;
		if (codepoint == 0x200d) return cc_zwj;
		if (codepoint <= 0xffff) return cc_low;
		return cc_high;
	};
	
	uint32_t ia, ib, ic;
	cclass_t ca, cb;
	// ia points to the start of ca, ib to cb, ic to after cb
	
	auto match = [](cclass_t cc, cclass_t accept)->bool {
		if (accept == cc_any) return true;
		if (accept == cc_low && cc <= cc_low) return true;
		if (accept == cc) return true;
		return false;
	};
	auto shift = [&]() {
		ia = ib;
		ca = cb;
		ib = ic;
		if (ic == in.length()) cb = cc_eof;
		else cb = classify(in.codepoint_at(ic));
	};
	auto include = [&](cclass_t a, cclass_t b = cc_eof)->bool {
		if (match(ca, a))
		{
			if (b == cc_eof)
			{
				shift();
				return true;
			}
			if (match(cb, b))
			{
				shift();
				shift();
				return true;
			}
		}
		return false;
	};
	
	ic = at;
	shift();
	shift();
	
	// [FITZ](?=[FITZ])|(?:[LOW][COMBO]?|[COMBO]|(?:[REGIONAL]){2}|[HIGH]|[ASTRAL])[VAR]?(?:[COMBO]|[FITZ])?
	// (?:[ZWJ](?:[LOW]|(?:[REGIONAL]){2}|[HIGH])[VAR]?(?:[COMBO]|[FITZ])?)*
	if (ca == cc_fitz && cb == cc_fitz) return ib;
	if (!include(cc_low, cc_combo))
	{
	zwj_loop:
		include(cc_regional, cc_regional) || include(cc_any);
	}
	include(cc_var);
	include(cc_combo) || include(cc_fitz);
	if (include(cc_zwj))
	{
		if (ca == cc_eof) return ia-3; // strlen(zwj)
		goto zwj_loop;
	}
	
	return ia;
}

const emoji* find_by_unicode(cstring text) const override { return from_unicode.get_or(text, nullptr); }

void insert_by_unicode(array<span>& out, const span& fmt, cstring text) const override
{
	uint32_t pos = 0;
	bool skip_flag_check = false;
	while (pos < text.length())
	{
		// just a speedhack
		uint32_t fast_end = pos;
		while (LIKELY(fast_end < text.length() && (uint8_t)text[fast_end] < 0x80)) fast_end++;
		if (fast_end > pos+1)
		{
			if (fast_end == text.length())
			{
				out.append(fmt).text = text.substr(pos, fast_end);
				return;
			}
			fast_end--; // so 3 followed by zwj or enclosing keycap doesn't end up fastened and glitchy
			out.append(fmt).text = text.substr(pos, fast_end);
			pos = fast_end;
		}
		
		uint32_t next = next_grapheme_cluster(text, pos);
		cstring clust = text.substr(pos, next);
		
		if (clust == "🏴" && !skip_flag_check) // the flag is U+1F3F4
		{
			uint32_t flag_start = pos;
			
		again:
			if (next == text.length())
			{
				clust = text.substr(flag_start, next);
				goto done;
			}
			
			pos = next;
			next = next_grapheme_cluster(text, pos);
			
			if (next-pos == 4) // if next cluster starts with a Tags character, but contains something else too, ignore it
			{
				uint32_t tmp = pos;
				uint32_t cp = text.codepoint_at(tmp);
				if (cp >= 0xE0061 && cp <= 0xE007A) goto again;
				if (cp == 0xE007F)
				{
					clust = text.substr(flag_start, next);
					goto done;
				}
			}
			
			skip_flag_check = true;
			clust = text.substr(flag_start, pos);
			next = pos;
		}
		else skip_flag_check = false;
	done:
		pos = next;
		
		const emoji * em = from_unicode.get_or(clust, nullptr);
		if (em)
		{
			textview::span& sp = out.append(fmt);
			sp.img = get_image(em);
			if (sp.img) sp.text = em->names[0];
			else sp.text = em->unicode;
		}
		else out.append(fmt).text = clust;
	}
}

};
}

discord_emoji* discord_emoji::create(bytesr data, unsigned imgsize)
{
	return new discord_emoji_impl(data, imgsize);
}

#ifdef ARLIB_TEST
discord_emoji* discord_emoji_get_test();
discord_emoji* discord_emoji_get_test()
{
	static discord_emoji* emoji = nullptr;
	if (!emoji)
	{
		bytearray zip = file::readall("discord-emoji.zip");
		if (!zip) test_fail("emoji library not found");
		
		emoji = discord_emoji::create(zip, 16);
		assert_eq(emoji->list().size(), 3652+3); // 3652 images + r/c/tm
	}
	return emoji;
}

test("Discord emoji - init", "", "d-emoji-preload")
{
	discord_emoji_get_test();
	if (RUNNING_ON_VALGRIND) test_expfail("this setup takes ten seconds");
}
static void test1_unicode(discord_emoji* emoji, cstring in, cstring expected)
{
	array<textview::span> spans;
	emoji->insert_by_unicode(spans, textview::span(), in);
	string out;
	for (textview::span& sp : spans) out += sp.text;
	testctx(in)
		assert_eq(out, expected);
}
test("Discord emoji - unicode", "d-emoji-preload", "d-emoji")
{
#define assert_unicode(in, out) testcall(test1_unicode(emoji, in, out))
	discord_emoji* emoji = discord_emoji_get_test();
	
	assert_unicode("💩 👌🏻 👌 🏻 🏻🏻 👌💩 ©️", ":poop: :ok_hand_tone1: :ok_hand: 🏻 🏻:skin-tone-1: :ok_hand::poop: ©️");
	assert_unicode("3 🏳️‍🌈 🇷🇺 🇷""🇻 🇷", "3 :rainbow_flag: :flag_ru: 🇷""🇻 :regional_indicator_r:");
	assert_unicode("🏳️‍🌈 🇷🇺 🇷""🇻 3", ":rainbow_flag: :flag_ru: 🇷""🇻 3");
	assert_unicode(u8"3\u20e3 3\ufe0f\u20e3", ":three: :three:");
	
#define t_g u8"\U000e0067"
#define t_e u8"\U000e007f"
#define t_gbsct u8"\U000e0067\U000e0062\U000e0073\U000e0063\U000e0074"
#define t_gbsct_e t_gbsct t_e
#define zwj u8"\u200d"
	assert_unicode("🏴" t_gbsct_e, ":scotland:");
	assert_unicode("🏴" t_gbsct_e t_g, ":scotland:" t_g);
	assert_unicode("🏴" t_g t_g t_g t_e, "🏴" t_g t_g t_g t_e);
	assert_unicode("🏴" t_e, "🏴" t_e);
	assert_unicode("🏴", ":flag_black:");
	assert_unicode("🏴" t_g "🏴", "🏴" t_g ":flag_black:");
	assert_unicode("🏴" t_gbsct, "🏴" t_gbsct);
	assert_unicode("🏴🏴", ":flag_black::flag_black:");
	assert_unicode("🏴🏴" t_gbsct_e, ":flag_black::flag_black:" t_gbsct_e);
	assert_unicode("🏴" t_gbsct_e "🏴", ":scotland::flag_black:");
	assert_unicode("🏴" t_gbsct_e "🏴" t_gbsct_e, ":scotland::scotland:");
	assert_unicode("🏴🏴" t_gbsct_e, ":flag_black::flag_black:" t_gbsct_e);
	assert_unicode("🔥" zwj "🔥", "🔥" zwj "🔥");
	assert_unicode("🔥" zwj, ":fire:" zwj);
	assert_unicode("🏴" t_gbsct_e zwj "🔥", "🏴" t_gbsct_e zwj "🔥");
#undef t_g
#undef t_gbsct
#undef t_e
#undef zwj
#undef assert_unicode
}
test("Discord emoji - insert", "d-emoji-preload", "d-emoji")
{
	discord_emoji* emoji = discord_emoji_get_test();
	
	span fmt;
	fmt.bgcol = 0x123456;
	
	array<span> spans;
	assert(emoji->insert_by_name(spans, fmt, ":poop:"));
	assert(emoji->insert_by_name(spans, fmt, ":ok_hand_tone1:"));
	assert(emoji->insert_by_name(spans, fmt, ":ok_hand::skin-tone-1:"));
	assert(emoji->insert_by_name(spans, fmt, ":hankey:"));
	assert(emoji->insert_by_name(spans, fmt, ":copyright:"));
	assert(!emoji->insert_by_name(spans, fmt, ":not_emoji:"));
	
	assert_eq(spans.size(), 5);
	assert_eq(spans[0].text, ":poop:");
	assert_eq(spans[1].text, ":ok_hand_tone1:");
	assert_eq(spans[2].text, ":ok_hand::skin-tone-1:");
	assert_eq(spans[3].text, ":hankey:");
	assert_eq(spans[4].text, "©️");
	assert(spans[0].img == spans[3].img);
	assert(spans[0].img != spans[1].img);
	assert(spans[1].img == spans[2].img);
	assert(!spans[4].img);
	
	assert_eq(spans[0].bgcol, 0x123456);
	assert_eq(spans[1].bgcol, 0x123456);
	assert_eq(spans[2].bgcol, 0x123456);
	assert_eq(spans[3].bgcol, 0x123456);
	assert_eq(spans[4].bgcol, 0x123456);
}
test("Discord emoji - order", "d-emoji-preload", "d-emoji")
{
	discord_emoji* emoji = discord_emoji_get_test();
	
	bool cat = false;
	bool cat2 = false;
	for (const discord_emoji::emoji* em : emoji->list())
	{
		if (em->names[0] == ":cat:") cat = true;
		if (em->names[0] == ":cat2:") { assert(cat); cat2 = true; }
	}
	assert(cat);
	assert(cat2);
}
#endif

}
