#include "discord.h"

namespace russian {

namespace {
class discord_emoji_impl : public discord_emoji
{
public:

unsigned imgsize;

zip z;

struct emoji {
	string unicode; // "ğŸ’©"
	string name; // ":poop:"
	
	size_t zipidx; // index to the zip, or -1 if no image
	mutable autoptr<textview::image> img; // image; null for most entries, non-null for anything that's been used
};
array<emoji> uniq_emoji;
map<string, emoji*> from_name; // [":poop:"] and [":hankey:"] point to the same item

// ["ğŸ’©"] = entry for :poop:
// ["3âƒ£"] = entry for :three:
// ["foo"] = unset
// ["3"] = NULL - prefixes of existing emoji exist, with blank value; if not found, stop the scan (valid utf8 only)
// [""] = NULL (never read)
map<string, emoji*> from_unicode;

array<emoji*> avatars; // always sorted same way each run (same order as emoji.json), but the exact order is arbitrary and nonsensical
array<cstring> emoji_names; // points to emoji::name, sorted alphabetically

discord_emoji_impl(arrayview<byte> data, unsigned imgsize)
{
	this->imgsize = imgsize;
	
	z.init(data);
	
	map<string, size_t> zip_fname_id;
	for (size_t i=0;i<z.files().size();i++)
	{
		zip_fname_id.insert(z.files()[i], i);
	}
	
	JSON json(cstring(z.read_idx(zip_fname_id.get_or("emoji.json", -1))));
	if (!json) return;
	
	uniq_emoji.resize(json.list().size()); // pre-size the array, so pointers to it can be created
	
	size_t id = 0;
	for (JSON& item : json.list())
	{
		emoji* em = &uniq_emoji[id++];
		em->unicode = item["unicode"];
		em->name = item["names"][0];
		
		cstring fname = item["file"];
		if (fname)
			em->zipidx = zip_fname_id[fname];
		else
			em->zipidx = (size_t)-1;
		
		for (cstring subname : item["names"].list())
			from_name.insert(subname, em);
		
		from_unicode.insert(em->unicode, em);
		size_t i = em->unicode.length();
		while (i)
		{
			while ((em->unicode[i-1]&0xC0) == 0x80) i--;
			i--;
			from_unicode.get_create(em->unicode.substr(0, i)); // create key if it doesn't exist; if it does, leave unchanged
		}
		
		if (em->zipidx != (size_t)-1) // if it has an image...
		{
			uint32_t n = 0;
			// and is not a ligature (most of them are duplicates (skin color) or likely provably inaccurate (flags))
			// exception: 0-9 are allowed
			uint32_t firstcp = em->unicode.codepoint_at(n);
			if (firstcp >= 0x1F551 && firstcp <= 0x1F567) {} // ban 23 of 24 clocks, they're duplicate
			else if (n == em->unicode.length() || firstcp <= '9')
			{
				avatars.append(em);
			}
		}
		
		emoji_names.append(em->name);
	}
	
	emoji_names.sort(&string::less);
}

arrayview<cstring> names() const override
{
	return emoji_names;
}

bool insert(array<span>& out, const span& fmt, cstring name) const override
{
	const emoji* em = from_name.get_or(name, NULL);
	if (!em) return false;
	
	if (em->zipidx == (size_t)-1)
	{
		out.append(fmt).text = em->unicode;
		return true;
	}
	
	if (!em->img)
		em->img = textview::image::create(z.read_idx(em->zipidx), imgsize, imgsize);
	
	span& sp = out.append(fmt);
	sp.img = em->img;
	sp.text = em->name;
	
	return true;
}

string translate(cstring in) const override
{
	string out;
	
	uint32_t emoji_start = 0;
	uint32_t emoji_end = 0;
	const emoji* em KNOWN_INIT(NULL);
	
	uint32_t at = 0;
	while (at <= in.length())
	{
		const emoji * const * newem = NULL;
		if (at < in.length())
		{
			in.codepoint_at(at);
			newem = from_unicode.get_or_null(in.substr(emoji_start, at));
		}
		if (newem)
		{
			if (*newem)
			{
				emoji_end = at;
				em = *newem;
			}
		}
		else
		{
			if (emoji_start == emoji_end)
			{
				at = emoji_start;
				in.codepoint_at(at);
				out += in.substr(emoji_start, at);
				emoji_start = at;
				emoji_end = at;
			}
			else
			{
				out += em->name;
				
				at = emoji_end;
				emoji_start = at;
			}
			
			if (at == in.length()) break;
		}
	}
	
	return out;
}

textview::image* pick_avatar(uint64_t seed) const override
{
	if (!avatars.size())
		return NULL;
	const emoji* em = avatars[seed % avatars.size()];
	if (!em->img)
		em->img = textview::image::create(z.read_idx(em->zipidx), imgsize, imgsize); // zipidx known set if it's in avatars
	return em->img;
}

};
}

discord_emoji* discord_emoji::create(arrayview<byte> data, unsigned imgsize)
{
	return new discord_emoji_impl(data, imgsize);
}

#ifdef ARLIB_TEST
test("Discord emoji", "", "")
{
	array<byte> zip = file::readall("discord-emoji.zip");
	if (!zip) test_fail("emoji library not found");
	
	autoptr<discord_emoji> emoji = discord_emoji::create(zip, 20);
	assert_eq(emoji->names().size(), 1832+3); // 1832 images + r/c/tm
	
	assert_eq(emoji->translate("ğŸ’© ğŸ‘ŒğŸ» ğŸ‘Œ ğŸ» ğŸ‘ŒğŸ’©"),
	          ":poop: :ok_hand::skin-tone-1: :ok_hand: :skin-tone-1: :ok_hand::poop:");
	assert_eq(emoji->translate("3 ğŸ³ï¸â€ğŸŒˆ ğŸ‡·ğŸ‡º ğŸ‡·ğŸ‡» ğŸ‡·"), // RV ensures it keeps R even if half of the U exists
	          "3 :gay_pride_flag: :flag_ru: :regional_indicator_r::regional_indicator_v: :regional_indicator_r:");
	assert_eq(emoji->translate("ğŸ³ï¸â€ğŸŒˆ ğŸ‡·ğŸ‡º ğŸ‡·ğŸ‡» 3"), // 3, and R above, test that it doesn't go out of bounds if a prefix of an emoji is found
	          ":gay_pride_flag: :flag_ru: :regional_indicator_r::regional_indicator_v: 3");
	
	span fmt;
	fmt.bgcol = 0x123456;
	
	array<span> spans;
	assert(emoji->insert(spans, fmt, ":poop:"));
	assert(emoji->insert(spans, fmt, ":ok_hand::skin-tone-1:"));
	assert(emoji->insert(spans, fmt, ":hankey:"));
	assert(emoji->insert(spans, fmt, ":copyright:"));
	assert(!emoji->insert(spans, fmt, ":not_emoji:"));
	
	assert_eq(spans[0].text, ":poop:");
	assert_eq(spans[1].text, ":ok_hand::skin-tone-1:");
	assert_eq(spans[2].text, ":poop:");
	assert_eq(spans[3].text, "Â©");
	assert(spans[0].img == spans[2].img);
	assert(spans[0].img != spans[1].img);
	assert(!spans[3].img);
	
	assert_eq(spans[0].bgcol, 0x123456);
	assert_eq(spans[1].bgcol, 0x123456);
	assert_eq(spans[2].bgcol, 0x123456);
	assert_eq(spans[3].bgcol, 0x123456);
}
#endif

}
