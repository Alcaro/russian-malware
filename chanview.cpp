#include "chanview.h"
#include <gtk/gtk.h>

#if !GTK_CHECK_VERSION(3,16,0)
//this is somewhat glitchy (textview works fine, but channel list gets scrollbar), but there's no better option for old gtks
#define GTK_POLICY_EXTERNAL GTK_POLICY_AUTOMATIC
#endif

enum {
	col_name,      // GString
	col_name_html, // GString, for tooltips
	col_attr,      // PangoAttrList
	col_channel,   // channel*
	col_count // (not a column)
	//if editing this, also edit the gtk_tree_store_new call
};

static const float px_per_step = 1.5;

chanview::chanview()
{
	store = gtk_tree_store_new(col_count, G_TYPE_STRING, G_TYPE_STRING, PANGO_TYPE_ATTR_LIST, G_TYPE_POINTER);
	
	auto change_event = [](GtkTreeModel* model, GtkTreeIter* a, GtkTreeIter* b, void* userdata) -> gint {
			chanview* self = (chanview*)userdata;
			return self->sort_func(model, a, b);
		};
	gtk_tree_sortable_set_default_sort_func(GTK_TREE_SORTABLE(store), change_event, this, NULL);
	gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(store), GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID, GTK_SORT_ASCENDING);
	
	view = GTK_TREE_VIEW(gtk_tree_view_new());
	
	GtkTreeViewColumn* col = gtk_tree_view_column_new();
	GtkCellRenderer* renderer = gtk_cell_renderer_text_new();
	gtk_tree_view_append_column(view, col);
	gtk_tree_view_column_pack_start(col, renderer, TRUE);
	gtk_tree_view_column_add_attribute(col, renderer, "text", col_name);
	gtk_tree_view_column_add_attribute(col, renderer, "attributes", col_attr);
	gtk_cell_renderer_text_set_fixed_height_from_font(GTK_CELL_RENDERER_TEXT(renderer), 1);
	g_object_set(G_OBJECT(renderer), "ypad", 0, NULL);
	
	gtk_tree_view_set_model(view, GTK_TREE_MODEL(store));
	gtk_tree_selection_set_mode(gtk_tree_view_get_selection(view), GTK_SELECTION_BROWSE);
	gtk_tree_view_set_headers_visible(view, false);
	
	gtk_tree_selection_set_select_function(gtk_tree_view_get_selection(this->view),
		[](GtkTreeSelection* selection, GtkTreeModel* model, GtkTreePath* path,
		   gboolean path_currently_selected, void* userdata) -> gboolean
		{
			chanview* cv = (chanview*)userdata;
			if (path_currently_selected) return true; // deselecting is always fine
			
			GtkTreeIter iter;
			gtk_tree_model_get_iter(model, &iter, path);
			
			channel* chan;
			gtk_tree_model_get(model, &iter, col_channel, &chan, -1);
			if (!chan->focusable) return false;
			cv->focus_cb(chan->userdata);
			
			return true;
		},
		this, NULL);
	
	//gtk_tree_view_set_enable_tree_lines(view, true);
	gtk_tree_view_expand_all(view);
	
	gtk_tree_view_set_show_expanders(view, false);
	gtk_tree_view_set_level_indentation(view, 10);
	
	gtk_tree_view_set_tooltip_column(view, col_name_html);
	
	
	scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(
#ifdef ARLIB_GUI_GTK3
NULL, NULL
#endif
	));
	gtk_scrolled_window_set_policy(scrollview, GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC);
#ifdef ARLIB_GUI_GTK3
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(view));
#else
	gtk_scrolled_window_set_has_frame(scrollview, true);
	gtk_scrolled_window_set_child(scrollview, GTK_WIDGET(view));
#endif
	
#ifdef ARLIB_GUI_GTK3
	GtkEventController* scroll_ev = gtk_event_controller_scroll_new(GTK_WIDGET(scrollview), GTK_EVENT_CONTROLLER_SCROLL_VERTICAL);
#else
	GtkEventController* scroll_ev = gtk_event_controller_scroll_new(GTK_EVENT_CONTROLLER_SCROLL_VERTICAL);
	gtk_widget_add_controller(GTK_WIDGET(scrollview), scroll_ev);
#endif
	gtk_event_controller_set_propagation_phase(GTK_EVENT_CONTROLLER(scroll_ev), GTK_PHASE_CAPTURE);
	auto scroll_cb = decompose_lambda([this](double dx, double dy, GtkEventControllerScroll* self) -> gboolean
	{
		if (dy == 1 || dy == -1)
			scroll_accum += dy;
		else
			scroll_accum += dy / px_per_step;
		
		while (scroll_accum < -0.5) // while to ensure it's smooth if a scroll event goes further than ±1
		{
			move_focus(-1);
			scroll_accum += 1;
		}
		while (scroll_accum >= 0.5) // >= to ensure one tick of the wheel always moves, even if scroll_accum is exactly ±0.5
		{
			move_focus(+1);
			scroll_accum -= 1;
		}
		
		return true;
	});
	g_signal_connect_swapped(scroll_ev, "scroll", G_CALLBACK(scroll_cb.fp), scroll_cb.ctx);
	
#ifdef ARLIB_GUI_GTK3
	gboolean(*button_press_cb)(GtkWidget* widget, GdkEvent* event, void* user_data) =
	                        [](GtkWidget* widget, GdkEvent* event, void* user_data) -> gboolean
	{
		chanview* cv = (chanview*)user_data;
		
		if (event->type == GDK_BUTTON_PRESS &&
		    event->button.button == 1 &&
		    (event->button.state & GDK_SHIFT_MASK))
		{
			GtkTreePath* path;
			if (gtk_tree_view_get_path_at_pos(cv->view, event->button.x, event->button.y, &path, 0, 0, 0))
			{
				GtkTreeIter iter;
				gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &iter, path);
				
				channel* ch;
				gtk_tree_model_get(GTK_TREE_MODEL(cv->store), &iter, col_channel, &ch, -1);
				if (ch->focusable)
					cv->close_cb(ch->userdata);
				gtk_tree_path_free(path);
				return TRUE;
			}
			return FALSE;
		}
		return FALSE;
	};
	g_signal_connect(G_OBJECT(this->view), "button-press-event", G_CALLBACK(button_press_cb), this);
#else
	GtkGesture* click_ctrl = gtk_gesture_click_new();
	gtk_event_controller_set_propagation_phase(GTK_EVENT_CONTROLLER(click_ctrl), GTK_PHASE_CAPTURE);
	gtk_widget_add_controller(GTK_WIDGET(scrollview), GTK_EVENT_CONTROLLER(click_ctrl));
	auto click_press_cb = decompose_lambda([this](int n_press, double x, double y, GtkGestureClick* self) {
		GdkEventSequence* seq = gtk_gesture_single_get_current_sequence(GTK_GESTURE_SINGLE(self));
		GdkEvent* ev = gtk_gesture_get_last_event(GTK_GESTURE(self), seq);
		
		GdkModifierType mods = gdk_event_get_modifier_state(ev);
		if (mods & GDK_SHIFT_MASK)
		{
			GtkTreePath* path;
			if (gtk_tree_view_get_path_at_pos(this->view, x, y, &path, 0, 0, 0))
			{
				GtkTreeIter iter;
				gtk_tree_model_get_iter(GTK_TREE_MODEL(this->store), &iter, path);
				
				chanbase* ch;
				gtk_tree_model_get(GTK_TREE_MODEL(this->store), &iter, col_chanbase, &ch, -1);
				if (ch->focusable)
					this->close_cb(ch->userdata);
				gtk_tree_path_free(path);
				
				gtk_gesture_set_sequence_state(GTK_GESTURE(self), seq, GTK_EVENT_SEQUENCE_CLAIMED);
			}
		}
		//if (gtk_gesture_single_get_current_button(GTK_GESTURE_SINGLE(self)) != GDK_BUTTON_PRIMARY)
			//return;
		//link_click = false;
	});
	g_signal_connect_swapped(click_ctrl, "pressed", G_CALLBACK(click_press_cb.fp), click_press_cb.ctx);
#endif
	
	gtk_widget_set_name(GTK_WIDGET(scrollview), "chanview");
}

void chanview::set_indent(int indent)
{
	gtk_tree_view_set_level_indentation(view, indent);
}


chanview::channel::channel(chanview* cv, channel* parent, cstring name, bool can_focus, void* userdata)
{
	this->cv = cv;
	this->name = name;
	this->focusable = can_focus;
	this->userdata = userdata;
	
	this->row = NULL;
	this->parent = parent;
}


void chanview::channel::focus()
{
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_selection_select_path(gtk_tree_view_get_selection(cv->view), path);
	gtk_tree_path_free(path);
}

void chanview::channel::rename(cstring name_show, cstring name_sort)
{
	this->name = name_show; // set this before gtk_tree_store_set, that one may call sort_func
	this->name_sort = name_sort;
	if (!row) return; // hidden?
	
	GtkTreeIter iter;
	
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &iter, path);
	gtk_tree_path_free(path);
	
	gchar* name_html = g_markup_escape_text(name_show.c_str(), -1);
	gtk_tree_store_set(cv->store, &iter,
	                   col_name, (const char*)this->name,
	                   col_name_html, name_html,
	                   -1);
	g_free(name_html);
}

void chanview::channel::sort_idx(int key)
{
	this->sort_key = key;
	
	if (!row) return;
	
	GtkTreeIter iter;
	
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &iter, path);
	gtk_tree_path_free(path);
	
	//yes, this is silly, but the obvious one (gtk_tree_model_row_changed) doesn't update sorting
	gtk_tree_store_set(cv->store, &iter, -1);
}

void chanview::channel::set_hidden(bool hidden, bool is_dtor)
{
	if (!hidden)
	{
		if (row) return;
		
		GtkTreeIter parentiter;
		
		if (parent)
		{
			GtkTreePath* path = gtk_tree_row_reference_get_path(parent->row);
			gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &parentiter, path);
			gtk_tree_path_free(path);
		}
		
		GtkTreeIter iter;
		gtk_tree_store_append(cv->store, &iter, parent ? &parentiter : NULL);
		
		GtkTreePath* path = gtk_tree_model_get_path(GTK_TREE_MODEL(cv->store), &iter);
		this->row = gtk_tree_row_reference_new(GTK_TREE_MODEL(cv->store), path);
		gtk_tree_view_expand_to_path(cv->view, path);
		
		gtk_tree_store_set(cv->store, &iter,
		                   col_channel, this,
		                   -1);
		
		rename(this->name);
		
		GtkTreeSelection* sel = gtk_tree_view_get_selection(cv->view);
		if (this->focusable && !gtk_tree_selection_get_selected(sel, NULL, NULL)) // can happen if this is the first channel created
			gtk_tree_selection_select_path(sel, path);
		
		gtk_tree_path_free(path);
	}
	else
	{
		if (!row) return;
		
		GtkTreeIter iter;
		
		GtkTreePath* path = gtk_tree_row_reference_get_path(row);
		// if it's a channel being destroyed, and the group was already destroyed, this can happen; just return
		// if not a destructor, let gtk_tree_model_get_iter throw its path!=NULL assertion
		if (!path && is_dtor) return;
		gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &iter, path);
		gtk_tree_path_free(path);
		
		GtkTreeSelection* sel = gtk_tree_view_get_selection(cv->view);
		if (gtk_tree_selection_iter_is_selected(sel, &iter)) // deleting the current one? select something else
			cv->move_focus(+1); // ideally, this would pick the closest focusable node, but yawn. and simple and predictable is good too
		
		gtk_tree_store_remove(cv->store, &iter);
		gtk_tree_row_reference_free(row);
		
		this->row = NULL;
	}
}

void chanview::channel::set_fmt()
{
	if (!row) return;
	
	GtkTreeIter iter;
	
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &iter, path);
	gtk_tree_path_free(path);
	
	if (!cv->fmt_attrs.contains(fmt))
	{
		PangoAttrList* attrs = pango_attr_list_new();
#define XRGB_TO_PANGO(arg) ((((arg)>>16)&0xFF)*257), ((((arg)>>8)&0xFF)*257), ((((arg)>>0)&0xFF)*257)
		if (fmt.fg != (uint32_t)-1)
			pango_attr_list_insert(attrs, pango_attr_foreground_new(XRGB_TO_PANGO(fmt.fg)));
		if (fmt.bg != (uint32_t)-1)
			pango_attr_list_insert(attrs, pango_attr_background_new(XRGB_TO_PANGO(fmt.bg)));
		if (fmt.bold)
			pango_attr_list_insert(attrs, pango_attr_weight_new(PANGO_WEIGHT_BOLD));
		if (fmt.italic)
			pango_attr_list_insert(attrs, pango_attr_style_new(PANGO_STYLE_ITALIC));
		if (fmt.strike != (uint32_t)-1)
		{
			pango_attr_list_insert(attrs, pango_attr_strikethrough_new(true));
			if (fmt.strike <= 0xFFFFFF)
				pango_attr_list_insert(attrs, pango_attr_strikethrough_color_new(XRGB_TO_PANGO(fmt.strike)));
		}
#undef XRGB_TO_PANGO
		cv->fmt_attrs.insert(fmt, attrs);
	}
	
	gtk_tree_store_set(cv->store, &iter,
	                   col_attr, cv->fmt_attrs.get(fmt),
	                   -1);
}


chanview::channel::~channel()
{
	set_hidden(true, true);
}


static GtkTreeIter iter_next(GtkTreeModel* mod, GtkTreeIter node)
{
	//extra scopes to tell GCC it's fine to reuse the iterators' storage
	{
		GtkTreeIter child;
		if (gtk_tree_model_iter_children(mod, &child, &node)) return child;
	}
	
again:
	{
		GtkTreeIter sibling = node;
		if (gtk_tree_model_iter_next(mod, &sibling)) return sibling;
	}
	
	{
		GtkTreeIter parent;
		if (gtk_tree_model_iter_parent(mod, &parent, &node))
		{
			node = parent;
			goto again;
		}
	}
	
	GtkTreeIter first;
	gtk_tree_model_get_iter_first(mod, &first);
	return first;
}

static GtkTreeIter iter_prev(GtkTreeModel* mod, GtkTreeIter node)
{
	GtkTreeIter descend = node;
	if (gtk_tree_model_iter_previous(mod, &descend))
	{
		goto do_descend;
	}
	
	{
		GtkTreeIter parent;
		if (gtk_tree_model_iter_parent(mod, &parent, &node)) return parent;
	}
	
	gtk_tree_model_iter_nth_child(mod, &descend, NULL, gtk_tree_model_iter_n_children(mod, NULL)-1);
do_descend:
	
	while (gtk_tree_model_iter_n_children(mod, &descend) > 0)
	{
		GtkTreeIter child;
		gtk_tree_model_iter_nth_child(mod, &child, &descend, gtk_tree_model_iter_n_children(mod, &descend)-1);
		descend = child;
	}
	return descend;
}

void chanview::move_focus(int dir)
{
	//hexchat does this via some kinda linear channel-to-number and number-to-channel functions, each of which is O(channel count)
	//O(~30) is perfectly fine, but I'd rather do it better anyways
	
	GtkTreeSelection* sel = gtk_tree_view_get_selection(this->view);
	GtkTreeModel* mod;
	GtkTreeIter it;
	gtk_tree_selection_get_selected(sel, &mod, &it);
	
	GtkTreeIter newsel = it;
	channel* chan;
	do {
		newsel = (dir>0 ? iter_next(mod, newsel) : iter_prev(mod, newsel));
		
		gtk_tree_model_get(mod, &newsel, col_channel, &chan, -1);
	} while (!chan->focusable);
	gtk_tree_selection_select_iter(sel, &newsel);
	
	//why do most GtkTreeModel functions use iterators but GtkTreeView prefers paths
	GtkTreePath* path = gtk_tree_model_get_path(mod, &newsel);
	gtk_tree_view_scroll_to_cell(this->view, path, NULL, false, 0.0, 0.0);
	gtk_tree_path_free(path);
}


int chanview::sort_func(GtkTreeModel* model, GtkTreeIter* a, GtkTreeIter* b)
{
	channel* chan_a;
	gtk_tree_model_get(model, a, col_channel, &chan_a, -1);
	channel* chan_b;
	gtk_tree_model_get(model, b, col_channel, &chan_b, -1);
	
	if (chan_a->sort_key < chan_b->sort_key) return -1;
	if (chan_a->sort_key > chan_b->sort_key) return  1;
	
	return string::icompare3(chan_a->name_sort, chan_b->name_sort);
}


chanview::~chanview()
{
	for (auto& pair : fmt_attrs) { pango_attr_list_unref(pair.value); }
	g_object_unref(store);
	g_object_unref(view);
}
