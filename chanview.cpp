#include "chanview.h"
#include <gtk/gtk.h>

#if !GTK_CHECK_VERSION(3,16,0)
//this is somewhat glitchy (textview works fine, but channel list gets scrollbar), but there's no better option for old gtks
#define GTK_POLICY_EXTERNAL GTK_POLICY_AUTOMATIC
#endif

enum {
	col_name,      // GString
	col_name_html, // GString, for tooltips
	col_attr,      // PangoAttrList
	col_chanbase,  // chanbase*
	col_count // (not a column)
	//if editing this, also edit the gtk_tree_store_new call
};

static const float px_per_step = 1.5;

chanview::chanview()
{
	store = gtk_tree_store_new(col_count, G_TYPE_STRING, G_TYPE_STRING, PANGO_TYPE_ATTR_LIST, G_TYPE_POINTER);
	
	gint(*sort_func)(GtkTreeModel* model, GtkTreeIter* a, GtkTreeIter* b, void* user_data) =
	              [](GtkTreeModel* model, GtkTreeIter* a, GtkTreeIter* b, void* user_data)
	{
		return ((chanview*)user_data)->sort_func(model, a, b);
	};
	gtk_tree_sortable_set_default_sort_func(GTK_TREE_SORTABLE(store), sort_func, this, NULL);
	gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(store), GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID, GTK_SORT_ASCENDING);
	
	view = GTK_TREE_VIEW(gtk_tree_view_new());
	
	GtkTreeViewColumn* col = gtk_tree_view_column_new();
	GtkCellRenderer* renderer = gtk_cell_renderer_text_new();
	gtk_tree_view_append_column(view, col);
	gtk_tree_view_column_pack_start(col, renderer, TRUE);
	gtk_tree_view_column_add_attribute(col, renderer, "text", col_name);
	gtk_tree_view_column_add_attribute(col, renderer, "attributes", col_attr);
	gtk_cell_renderer_text_set_fixed_height_from_font(GTK_CELL_RENDERER_TEXT(renderer), 1);
	g_object_set(G_OBJECT(renderer), "ypad", 0, NULL);
	
	gtk_tree_view_set_model(view, GTK_TREE_MODEL(store));
	gtk_tree_selection_set_mode(gtk_tree_view_get_selection(view), GTK_SELECTION_BROWSE);
	gtk_tree_view_set_headers_visible(view, false);
	
	gtk_tree_selection_set_select_function(gtk_tree_view_get_selection(this->view),
		[](GtkTreeSelection* selection, GtkTreeModel* model, GtkTreePath* path,
		   gboolean path_currently_selected, void* userdata) -> gboolean
		{
			chanview* cv = (chanview*)userdata;
			if (path_currently_selected) return true; // deselecting is always fine
			
			GtkTreeIter iter;
			gtk_tree_model_get_iter(model, &iter, path);
			
			chanbase* chan;
			gtk_tree_model_get(model, &iter, col_chanbase, &chan, -1);
			if (!chan->focusable) return false;
			cv->focus_cb(chan->userdata);
			
			return true;
		},
		this, NULL);
	
	gtk_tree_view_set_enable_tree_lines(view, true);
	gtk_tree_view_expand_all(view);
	
	gtk_tree_view_set_show_expanders(view, false);
	gtk_tree_view_set_level_indentation(view, 19);
	
	gtk_tree_view_set_tooltip_column(view, col_name_html);
	
	
	scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	gtk_scrolled_window_set_policy(scrollview, GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(view));
	
	gboolean(*any_event_cb)(GtkWidget* widget, GdkEvent* event, void* user_data) =
	                     [](GtkWidget* widget, GdkEvent* event, void* user_data) -> gboolean
	{
		//Gtk (via its XInput2 dependency) likes to mangle some scroll events
		//there is no bug in this function
		//(XI2 is disabled, so this is mostly harmless, but it could resurface under some contexts)
		
		if (event->type == GDK_SCROLL)
		{
			chanview* cv = (chanview*)user_data;
			
			if (event->scroll.direction == GDK_SCROLL_UP) cv->scroll_accum -= 1;
			if (event->scroll.direction == GDK_SCROLL_DOWN) cv->scroll_accum += 1;
			if (event->scroll.direction == GDK_SCROLL_SMOOTH)
			{
				// evil code, but gives the results I want (one wheel tick should be one channel, but touchpads should be slowed down)...
				if (event->scroll.delta_y == 1 || event->scroll.delta_y == -1)
					cv->scroll_accum += event->scroll.delta_y;
				else
					cv->scroll_accum += event->scroll.delta_y / px_per_step;
			}
			
			while (cv->scroll_accum < -0.5) // while to ensure it's smooth if a scroll event goes further than ±1
			{
				cv->move_focus(-1);
				cv->scroll_accum += 1;
			}
			while (cv->scroll_accum >= 0.5) // >= to ensure one tick of the wheel always moves, even if scroll_accum is exactly ±0.5
			{
				cv->move_focus(+1);
				cv->scroll_accum -= 1;
			}
			
			return GDK_EVENT_STOP;
		}
		
		return GDK_EVENT_PROPAGATE;
	};
	g_signal_connect(scrollview, "event", G_CALLBACK(any_event_cb), this);
	
	gboolean(*button_press_cb)(GtkWidget* widget, GdkEvent* event, void* user_data) =
	                        [](GtkWidget* widget, GdkEvent* eventraw, void* user_data) -> gboolean
	{
		GdkEventButton* event = &eventraw->button;
		chanview* cv = (chanview*)user_data;
		
		if (event->type == GDK_BUTTON_PRESS && event->button == 1 && (event->state & GDK_SHIFT_MASK))
		{
			GtkTreePath* path;
			if (gtk_tree_view_get_path_at_pos(cv->view, event->x, event->y, &path, 0, 0, 0))
			{
				GtkTreeIter iter;
				gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &iter, path);
				
				chanbase* ch;
				gtk_tree_model_get(GTK_TREE_MODEL(cv->store), &iter, col_chanbase, &ch, -1);
				if (ch->focusable)
					cv->close_cb(ch->userdata);
				gtk_tree_path_free(path);
				return TRUE;
			}
			return FALSE;
		}
		return FALSE;
	};
	g_signal_connect(G_OBJECT(this->view), "button-press-event", G_CALLBACK(button_press_cb), this);
	
	gtk_widget_set_name(GTK_WIDGET(scrollview), "chanview");
}


chanview::chanbase::chanbase(chanview* cv, group* parent, cstring name, bool can_focus, void* userdata)
{
	this->cv = cv;
	this->name = name;
	this->focusable = can_focus;
	this->userdata = userdata;
	
	this->row = NULL;
	set_hidden(parent, false);
}


//Will fire the onfocus callback.
void chanview::chanbase::focus()
{
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_selection_select_path(gtk_tree_view_get_selection(cv->view), path);
	gtk_tree_path_free(path);
}

void chanview::chanbase::rename(cstring name_show, cstring name_sort)
{
	this->name = name_show; // set this before gtk_tree_store_set, that one may call sort_func
	if (!has_sort2) this->sort2 = name_sort;
	if (!row) return; // hidden?
	
	GtkTreeIter iter;
	
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &iter, path);
	gtk_tree_path_free(path);
	
	gchar* name_html = g_markup_escape_text(name_show.c_str(), -1);
	gtk_tree_store_set(cv->store, &iter,
	                   col_name, (const char*)this->name,
	                   col_name_html, name_html,
	                   -1);
	g_free(name_html);
}

void chanview::chanbase::sort_as(int key1, cstring key2)
{
	sort1 = key1;
	sort2 = key2;
	has_sort2 = true;
	
	if (!row) return;
	
	GtkTreeIter iter;
	
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &iter, path);
	gtk_tree_path_free(path);
	
	//yes, this is silly, but the obvious one (gtk_tree_model_row_changed) doesn't update sorting
	gtk_tree_store_set(cv->store, &iter, -1);
}

void chanview::chanbase::set_hidden(group* parent, bool hidden, bool is_dtor)
{
	if (!hidden)
	{
		if (row) return;
		
		GtkTreeIter parentiter;
		
		if (parent)
		{
			GtkTreePath* path = gtk_tree_row_reference_get_path(parent->row);
			gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &parentiter, path);
			gtk_tree_path_free(path);
		}
		
		GtkTreeIter iter;
		gtk_tree_store_append(cv->store, &iter, parent ? &parentiter : NULL);
		
		GtkTreePath* path = gtk_tree_model_get_path(GTK_TREE_MODEL(cv->store), &iter);
		this->row = gtk_tree_row_reference_new(GTK_TREE_MODEL(cv->store), path);
		gtk_tree_view_expand_to_path(cv->view, path);
		
		gtk_tree_store_set(cv->store, &iter,
		                   col_chanbase, this,
		                   -1);
		
		rename(this->name);
		
		GtkTreeSelection* sel = gtk_tree_view_get_selection(cv->view);
		if (this->focusable && !gtk_tree_selection_get_selected(sel, NULL, NULL)) // can happen if this is the first channel created
			gtk_tree_selection_select_path(sel, path);
		
		gtk_tree_path_free(path);
	}
	else
	{
		if (!row) return;
		
		GtkTreeIter iter;
		
		GtkTreePath* path = gtk_tree_row_reference_get_path(row);
		// if it's a channel being destroyed, and the group was already destroyed, this can happen; just return
		// if not a destructor, let gtk_tree_model_get_iter throw its path!=NULL assertion
		if (!path && is_dtor) return;
		gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &iter, path);
		gtk_tree_path_free(path);
		
		GtkTreeSelection* sel = gtk_tree_view_get_selection(cv->view);
		if (gtk_tree_selection_iter_is_selected(sel, &iter)) // deleting the current one? select something else
			cv->move_focus(+1); // ideally, this would pick the closest focusable node, but yawn. and simple and predictable is good too
		
		gtk_tree_store_remove(cv->store, &iter);
		gtk_tree_row_reference_free(row);
		
		this->row = NULL;
	}
}

void chanview::chanbase::set_fmt()
{
	if (!row) return;
	
	GtkTreeIter iter;
	
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &iter, path);
	gtk_tree_path_free(path);
	
	if (!cv->fmt_attrs.contains(fmt))
	{
		PangoAttrList* attrs = pango_attr_list_new();
#define XRGB_TO_PANGO(arg) ((((arg)>>16)&0xFF)*257), ((((arg)>>8)&0xFF)*257), ((((arg)>>0)&0xFF)*257)
		if (fmt.fg != (uint32_t)-1)
			pango_attr_list_insert(attrs, pango_attr_foreground_new(XRGB_TO_PANGO(fmt.fg)));
		if (fmt.bg != (uint32_t)-1)
			pango_attr_list_insert(attrs, pango_attr_background_new(XRGB_TO_PANGO(fmt.bg)));
		if (fmt.bold)
			pango_attr_list_insert(attrs, pango_attr_weight_new(PANGO_WEIGHT_BOLD));
		if (fmt.italic)
			pango_attr_list_insert(attrs, pango_attr_style_new(PANGO_STYLE_ITALIC));
		if (fmt.strike != (uint32_t)-1)
		{
			pango_attr_list_insert(attrs, pango_attr_strikethrough_new(true));
			if (fmt.strike <= 0xFFFFFF)
				pango_attr_list_insert(attrs, pango_attr_strikethrough_color_new(XRGB_TO_PANGO(fmt.strike)));
		}
#undef XRGB_TO_PANGO
		cv->fmt_attrs.insert(fmt, attrs);
	}
	
	gtk_tree_store_set(cv->store, &iter,
	                   col_attr, cv->fmt_attrs.get(fmt),
	                   -1);
}


chanview::chanbase::~chanbase()
{
	set_hidden(NULL, true, true);
}


static GtkTreeIter iter_next(GtkTreeModel* mod, GtkTreeIter node)
{
	//extra scopes to tell GCC it's fine to reuse the iterators' storage
	{
		GtkTreeIter child;
		if (gtk_tree_model_iter_children(mod, &child, &node)) return child;
	}
	
again:
	{
		GtkTreeIter sibling = node;
		if (gtk_tree_model_iter_next(mod, &sibling)) return sibling;
	}
	
	{
		GtkTreeIter parent;
		if (gtk_tree_model_iter_parent(mod, &parent, &node))
		{
			node = parent;
			goto again;
		}
	}
	
	GtkTreeIter first;
	gtk_tree_model_get_iter_first(mod, &first);
	return first;
}

static GtkTreeIter iter_prev(GtkTreeModel* mod, GtkTreeIter node)
{
	GtkTreeIter descend = node;
	if (gtk_tree_model_iter_previous(mod, &descend))
	{
		goto do_descend;
	}
	
	{
		GtkTreeIter parent;
		if (gtk_tree_model_iter_parent(mod, &parent, &node)) return parent;
	}
	
	gtk_tree_model_iter_nth_child(mod, &descend, NULL, gtk_tree_model_iter_n_children(mod, NULL)-1);
do_descend:
	
	while (gtk_tree_model_iter_n_children(mod, &descend) > 0)
	{
		GtkTreeIter child;
		gtk_tree_model_iter_nth_child(mod, &child, &descend, gtk_tree_model_iter_n_children(mod, &descend)-1);
		descend = child;
	}
	return descend;
}

void chanview::move_focus(int dir)
{
	//hexchat does this via some kinda linear channel-to-number and number-to-channel functions, each of which is O(channel count)
	//O(~30) is perfectly fine, but I'd rather do it better anyways
	
	GtkTreeSelection* sel = gtk_tree_view_get_selection(this->view);
	GtkTreeModel* mod;
	GtkTreeIter it;
	gtk_tree_selection_get_selected(sel, &mod, &it);
	
	GtkTreeIter newsel = it;
	chanbase* chan;
	do {
		newsel = (dir>0 ? iter_next(mod, newsel) : iter_prev(mod, newsel));
		
		gtk_tree_model_get(mod, &newsel, col_chanbase, &chan, -1);
	} while (!chan->focusable);
	gtk_tree_selection_select_iter(sel, &newsel);
	
	//why do most GtkTreeModel functions use iterators but GtkTreeView prefers paths
	GtkTreePath* path = gtk_tree_model_get_path(mod, &newsel);
	gtk_tree_view_scroll_to_cell(this->view, path, NULL, false, 0.0, 0.0);
	gtk_tree_path_free(path);
}


int chanview::sort_func(GtkTreeModel* model, GtkTreeIter* a, GtkTreeIter* b)
{
	chanbase* chan_a;
	gtk_tree_model_get(model, a, col_chanbase, &chan_a, -1);
	chanbase* chan_b;
	gtk_tree_model_get(model, b, col_chanbase, &chan_b, -1);
	
	if (chan_a->sort1 < chan_b->sort1) return -1;
	if (chan_a->sort1 > chan_b->sort1) return  1;
	
	return string::icompare3(chan_a->sort2, chan_b->sort2);
}


chanview::~chanview()
{
	for (auto& pair : fmt_attrs) { pango_attr_list_unref(pair.value); }
	g_object_unref(store);
	gtk_widget_destroy(GTK_WIDGET(view));
}
