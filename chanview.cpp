#ifndef ARGUI_NONE
#include "russian.h"
#include <gtk/gtk.h>

#if !GTK_CHECK_VERSION(3,16,0)
//this is somewhat glitchy (textview works fine, but channel list gets scrollbar), but there's no better option for old gtks
#define GTK_POLICY_EXTERNAL GTK_POLICY_AUTOMATIC
#endif

enum {
	col_name,      // char*
	col_name_html, // char*, for tooltips
	col_attr,      // PangoAttrList
	col_chanbase,  // chanbase*
	col_count // (not a column)
	//if editing this, also edit the gtk_tree_store_new call
};

static const float px_per_step = 3;

chanview::chanview()
{
	store = gtk_tree_store_new(col_count, G_TYPE_STRING, G_TYPE_STRING, PANGO_TYPE_ATTR_LIST, G_TYPE_POINTER);
	
	gint(*sort_func)(GtkTreeModel* model, GtkTreeIter* a, GtkTreeIter* b, void* user_data) =
	              [](GtkTreeModel* model, GtkTreeIter* a, GtkTreeIter* b, void* user_data)
	{
		return ((chanview*)user_data)->sort_func(model, a, b);
	};
  gtk_tree_sortable_set_default_sort_func(GTK_TREE_SORTABLE(store), sort_func, this, NULL);
	gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(store), GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID, GTK_SORT_ASCENDING);
	
	view = GTK_TREE_VIEW(gtk_tree_view_new());
	
	GtkTreeViewColumn* col = gtk_tree_view_column_new();
	GtkCellRenderer* renderer = gtk_cell_renderer_text_new();
	gtk_tree_view_append_column(view, col);
	gtk_tree_view_column_pack_start(col, renderer, TRUE);
	gtk_tree_view_column_add_attribute(col, renderer, "text", col_name);
	gtk_tree_view_column_add_attribute(col, renderer, "attributes", col_attr);
	gtk_cell_renderer_text_set_fixed_height_from_font(GTK_CELL_RENDERER_TEXT(renderer), 1);
	
	gtk_tree_view_set_model(view, GTK_TREE_MODEL(store));
	gtk_tree_selection_set_mode(gtk_tree_view_get_selection(view), GTK_SELECTION_BROWSE);
	gtk_tree_view_set_headers_visible(view, false);
	
	gtk_tree_view_set_enable_tree_lines(view, true);
	gtk_tree_view_expand_all(view);
	
	gtk_tree_view_set_show_expanders(view, false);
	gtk_tree_view_set_level_indentation(view, 19);
	
	gtk_tree_view_set_tooltip_column(view, col_name_html);
	
	
	scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	gtk_scrolled_window_set_policy(scrollview, GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(view));
	
	gboolean(*any_event_cb)(GtkWidget* widget, GdkEvent* event, void* user_data) =
	                     [](GtkWidget* widget, GdkEvent* event, void* user_data) -> gboolean
	{
		//Gtk somehow likes to eat the first scroll event on the application (or window?)
		//there is no bug in this function
		
		if (event->type == GDK_SCROLL)
		{
			chanview* cv = (chanview*)user_data;
			
			if (event->scroll.direction == GDK_SCROLL_UP) cv->move_focus(-1);
			if (event->scroll.direction == GDK_SCROLL_DOWN) cv->move_focus(1);
			if (event->scroll.direction == GDK_SCROLL_SMOOTH)
			{
				cv->scroll_accum += event->scroll.delta_y / px_per_step;
				if ((int)cv->scroll_accum != 0)
				{
					cv->move_focus((int)cv->scroll_accum);
					cv->scroll_accum -= (int)cv->scroll_accum;
				}
			}
			
			return GDK_EVENT_STOP;
		}
		
		return GDK_EVENT_PROPAGATE;
	};
	g_signal_connect(scrollview, "event", G_CALLBACK(any_event_cb), this);
	
	gtk_widget_set_name(GTK_WIDGET(scrollview), "chanview");
}


chanview::chanbase::chanbase(chanview* cv, group* parent, cstring name, bool can_focus, void* userdata)
{
	this->cv = cv;
	this->name = name;
	this->focusable = can_focus;
	this->userdata = userdata;
	
	this->row = NULL;
	set_hidden(parent, false);
}


//Will fire the onfocus callback.
void chanview::chanbase::focus()
{
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_selection_select_path(gtk_tree_view_get_selection(cv->view), path);
	gtk_tree_path_free(path);
}

void chanview::chanbase::rename(cstring name)
{
	this->name = name; // set this before gtk_tree_store_set, that one may call sort_func
	
	GtkTreeIter iter;
	
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &iter, path);
	gtk_tree_path_free(path);
	
	gchar* name_html = g_markup_escape_text(name.c_str(), -1);
	gtk_tree_store_set(cv->store, &iter,
	                   col_name, (const char*)this->name,
	                   col_name_html, name_html,
	                   -1);
	g_free(name_html);
}

void chanview::chanbase::sort_as(int key1, cstring key2)
{
	sort1 = key1;
	sort2 = key2;
	
	if (!row) return;
	
	GtkTreeIter iter;
	
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &iter, path);
	gtk_tree_path_free(path);
	
	//yes, this is silly, but the obvious one (gtk_tree_model_row_changed) doesn't update sorting
	gtk_tree_store_set(cv->store, &iter, -1);
}

void chanview::chanbase::set_hidden(group* parent, bool hidden)
{
	if (hidden)
	{
		if (!row) return;
		
		GtkTreeIter iter;
		
		GtkTreePath* path = gtk_tree_row_reference_get_path(row);
		gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &iter, path);
		gtk_tree_path_free(path);
		
		gtk_tree_store_remove(cv->store, &iter);
		gtk_tree_row_reference_free(row);
		
		this->row = NULL;
	}
	else
	{
		if (row) return;
		
		GtkTreeIter parentiter;
		
		if (parent)
		{
			GtkTreePath* path = gtk_tree_row_reference_get_path(parent->row);
			gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &parentiter, path);
			gtk_tree_path_free(path);
		}
		
		GtkTreeIter iter;
		gtk_tree_store_append(cv->store, &iter, parent ? &parentiter : NULL);
		
		GtkTreePath* path = gtk_tree_model_get_path(GTK_TREE_MODEL(cv->store), &iter);
		this->row = gtk_tree_row_reference_new(GTK_TREE_MODEL(cv->store), path);
		gtk_tree_view_expand_to_path(cv->view, path);
		
		gtk_tree_store_set(cv->store, &iter,
		                   col_chanbase, this,
		                   -1);
		
		rename(this->name);
		
		if (focusable) cv->focus_if_needed(path);
		gtk_tree_path_free(path);
	}
}

void chanview::chanbase::color(uint32_t xrgb)
{
	if (!row) return;
	
	GtkTreeIter iter;
	
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_model_get_iter(GTK_TREE_MODEL(cv->store), &iter, path);
	gtk_tree_path_free(path);
	
	gtk_tree_store_set(cv->store, &iter,
	                   col_attr, cv->attrs_for_color(xrgb),
	                   -1);
}


chanview::chanbase::~chanbase()
{
	set_hidden(NULL, true);
}


static GtkTreeIter iter_next(GtkTreeModel* mod, GtkTreeIter node)
{
	//extra scopes to tell GCC it's fine to reuse the iterators' storage
	{
		GtkTreeIter child;
		if (gtk_tree_model_iter_children(mod, &child, &node)) return child;
	}
	
again:
	{
		GtkTreeIter sibling = node;
		if (gtk_tree_model_iter_next(mod, &sibling)) return sibling;
	}
	
	{
		GtkTreeIter parent;
		if (gtk_tree_model_iter_parent(mod, &parent, &node))
		{
			node = parent;
			goto again;
		}
	}
	
	GtkTreeIter first;
	gtk_tree_model_get_iter_first(mod, &first);
	return first;
}

static GtkTreeIter iter_prev(GtkTreeModel* mod, GtkTreeIter node)
{
	GtkTreeIter descend = node;
	if (gtk_tree_model_iter_previous(mod, &descend))
	{
		goto do_descend;
	}
	
	{
		GtkTreeIter parent;
		if (gtk_tree_model_iter_parent(mod, &parent, &node)) return parent;
	}
	
	gtk_tree_model_iter_nth_child(mod, &descend, NULL, gtk_tree_model_iter_n_children(mod, NULL)-1);
do_descend:
	
	while (gtk_tree_model_iter_n_children(mod, &descend) > 0)
	{
		GtkTreeIter child;
		gtk_tree_model_iter_nth_child(mod, &child, &descend, gtk_tree_model_iter_n_children(mod, &descend)-1);
		descend = child;
	}
	return descend;
}

void chanview::move_focus(int dir)
{
	//hexchat does this via some kinda linear channel-to-number and number-to-channel functions, each of which is O(channel count)
	//O(~30) is perfectly fine, but I'd rather do it better anyways
	
	GtkTreeSelection* sel = gtk_tree_view_get_selection(this->view);
	GtkTreeModel* mod;
	GtkTreeIter it;
	gtk_tree_selection_get_selected(sel, &mod, &it);
	
	GtkTreeIter newsel = it;
	chanbase* chan;
	do {
		newsel = (dir>0 ? iter_next(mod, newsel) : iter_prev(mod, newsel));
		
		gtk_tree_model_get(mod, &newsel, col_chanbase, &chan, -1);
	} while (!chan->focusable);
	gtk_tree_selection_select_iter(sel, &newsel);
	
	//why do most GtkTreeModel functions use iterators but GtkTreeView prefers paths
	GtkTreePath* path = gtk_tree_model_get_path(mod, &newsel);
	gtk_tree_view_scroll_to_cell(this->view, path, NULL, false, 0.0, 0.0);
	gtk_tree_path_free(path);
}

void chanview::focus_if_needed(GtkTreePath* path)
{
	GtkTreeSelection* sel = gtk_tree_view_get_selection(view);
	if (!gtk_tree_selection_get_selected(sel, NULL, NULL))
	{
		gtk_tree_selection_set_select_function(gtk_tree_view_get_selection(this->view),
			[](GtkTreeSelection* selection, GtkTreeModel* model, GtkTreePath* path,
			   gboolean path_currently_selected, void* userdata) -> gboolean
			{
				chanview* this_ = (chanview*)userdata;
				if (path_currently_selected) return true; // deselecting is always fine
				
				GtkTreeIter iter;
				gtk_tree_model_get_iter(model, &iter, path);
				
				chanbase* chan;
				gtk_tree_model_get(model, &iter, col_chanbase, &chan, -1);
				if (!chan->focusable) return false;
				this_->focus_cb(chan->userdata);
				
				return true;
			},
			this, NULL);
		
		gtk_tree_selection_select_path(sel, path);
	}
}


int chanview::sort_func(GtkTreeModel* model, GtkTreeIter* a, GtkTreeIter* b)
{
	chanbase* chan_a;
	gtk_tree_model_get(model, a, col_chanbase, &chan_a, -1);
	chanbase* chan_b;
	gtk_tree_model_get(model, b, col_chanbase, &chan_b, -1);
	
	if (chan_a->sort1 < chan_b->sort1) return -1;
	if (chan_a->sort1 > chan_b->sort1) return  1;
	
	const char * k2a = (chan_a->sort2 ? chan_a->sort2 : chan_a->name);
	const char * k2b = (chan_b->sort2 ? chan_b->sort2 : chan_b->name);
	return strcmp(k2a, k2b);
}


PangoAttrList* chanview::attrs_for_color(uint32_t xrgb)
{
	if (xrgb == (uint32_t)-1) return NULL;
	
	if (!color_attrs.contains(xrgb))
	{
		uint8_t r = xrgb>>16;
		uint8_t g = xrgb>>8;
		uint8_t b = xrgb>>0;
		PangoAttribute* attr = pango_attr_foreground_new(r*257, g*257, b*257);
		
		PangoAttrList* attrs = pango_attr_list_new();
		pango_attr_list_insert(attrs, attr);
		color_attrs.insert(xrgb, attrs);
	}
	return color_attrs.get(xrgb);
}


chanview::~chanview()
{
	for (auto& pair : color_attrs) { pango_attr_list_unref(pair.value); }
	g_object_unref(store);
	gtk_widget_destroy(GTK_WIDGET(view));
}
#endif
