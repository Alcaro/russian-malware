#include "russian.h"
#include <gtk/gtk.h>

enum {
	col_name,
	col_attr,
	col_userdata,
	col_count
};

chanview::chanview()
{
	store = gtk_tree_store_new(3, G_TYPE_STRING, PANGO_TYPE_ATTR_LIST, G_TYPE_POINTER);
	
	view = GTK_TREE_VIEW(gtk_tree_view_new());
	
	GtkTreeViewColumn* col = gtk_tree_view_column_new();
	GtkCellRenderer* renderer = gtk_cell_renderer_text_new();
	gtk_tree_view_append_column(view, col);
	gtk_tree_view_column_pack_start(col, renderer, TRUE);
	gtk_tree_view_column_add_attribute(col, renderer, "text", 0);
	gtk_cell_renderer_text_set_fixed_height_from_font(GTK_CELL_RENDERER_TEXT(renderer), 1);
	
	gtk_tree_view_set_model(view, GTK_TREE_MODEL(store));
	gtk_tree_selection_set_mode(gtk_tree_view_get_selection(view), GTK_SELECTION_BROWSE);
	gtk_tree_view_set_headers_visible(view, false);
	
	gtk_tree_view_set_enable_tree_lines(view, true);
	gtk_tree_view_expand_all(view);
	
	g_signal_connect(gtk_tree_view_get_selection(view), "changed", G_CALLBACK(onfocus_sig_nat), this);
	
	gtk_tree_view_set_show_expanders(view, false);
	gtk_tree_view_set_level_indentation(view, 19);
	
	//TODO: figure out if this is helpful or annoying
	//gtk_tree_view_set_hover_selection(view, true);
}

chanview::chanbase::chanbase(chanview* parent, GtkTreeRowReference* parentrow, cstring name, void* userdata)
{
	this->parent = parent;
	
	GtkTreeIter parentiter;
	
	if (parentrow)
	{
		GtkTreePath* path = gtk_tree_row_reference_get_path(parentrow);
		gtk_tree_model_get_iter(GTK_TREE_MODEL(parent->store), &parentiter, path);
		gtk_tree_path_free(path);
	}
	
	GtkTreeIter iter;
	gtk_tree_store_append(parent->store, &iter, parentrow ? &parentiter : NULL);
	gtk_tree_store_set(parent->store, &iter,
	                   col_name, (const char*)name.c_str(),
	                   col_userdata, userdata,
	                   -1);
	
	GtkTreePath* path = gtk_tree_model_get_path(GTK_TREE_MODEL(parent->store), &iter);
	this->row = gtk_tree_row_reference_new(GTK_TREE_MODEL(parent->store), path);
	gtk_tree_view_expand_to_path(parent->view, path);
	gtk_tree_path_free(path);
}

//void chanview::chanbase::color(color_t col) {}

//Will fire the onfocus callback.
void chanview::chanbase::focus()
{
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_selection_select_path(gtk_tree_view_get_selection(parent->view), path);
	gtk_tree_path_free(path);
}

void chanview::chanbase::rename(cstring name)
{
	GtkTreeIter iter;
	
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_model_get_iter(GTK_TREE_MODEL(parent->store), &iter, path);
	gtk_tree_path_free(path);
	
	gtk_tree_store_set(parent->store, &iter,
	                   col_name, (const char*)name.c_str(),
	                   -1);
}

chanview::chanbase::~chanbase()
{
	GtkTreeIter iter;
	
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_model_get_iter(GTK_TREE_MODEL(parent->store), &iter, path);
	gtk_tree_path_free(path);
	
	gtk_tree_store_remove(parent->store, &iter);
}

void chanview::onfocus_sig(GtkTreeSelection* sel)
{
	GtkTreeModel* model;
	GtkTreeIter iter;
	
	if (gtk_tree_selection_get_selected(sel, &model, &iter))
	{
		void* userdata;
		gtk_tree_model_get(model, &iter, col_userdata, &userdata, -1);
		this->focus_cb(userdata);
	}
}

//void chanview::focus_up()
//{
//	//hexchat does this via some kinda linear channel-to-number and number-to-channel functions, each of which is O(channel count)
//	//O(~30) is perfectly fine, but I'd rather do it better anyways
//}

//void chanview::focus_down()
//{
//	
//}

chanview::group* chanview::child(cstring name, void* userdata)
{
	group* ret = new group(this, NULL, name, userdata);
	
	GtkTreeSelection* sel = gtk_tree_view_get_selection(view);
	if (!gtk_tree_selection_get_selected(sel, NULL, NULL))
	{
		GtkTreeIter iter;
		gtk_tree_model_get_iter_first(GTK_TREE_MODEL(store), &iter);
		gtk_tree_selection_select_iter(sel, &iter);
	}
	return ret;
}

chanview::~chanview()
{
	g_object_unref(store);
	gtk_widget_destroy(GTK_WIDGET(view));
}
