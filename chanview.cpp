#ifndef ARGUI_NONE
#include "russian.h"
#include <gtk/gtk.h>

#if !GTK_CHECK_VERSION(3,16,0)
//this is somewhat glitchy (textview works fine, but channel list gets scrollbar), but there's no better option for old gtks
#define GTK_POLICY_EXTERNAL GTK_POLICY_AUTOMATIC
#endif

enum {
	col_name,
	col_name_html, // for tooltips
	col_attr,
	col_userdata,
	col_focusable,
	col_count
	//if editing this, also edit the gtk_tree_store_new call
};

static const float px_per_step = 3;

chanview::chanview()
{
	store = gtk_tree_store_new(col_count, G_TYPE_STRING, G_TYPE_STRING, PANGO_TYPE_ATTR_LIST, G_TYPE_POINTER, G_TYPE_BOOLEAN);
	
	view = GTK_TREE_VIEW(gtk_tree_view_new());
	
	GtkTreeViewColumn* col = gtk_tree_view_column_new();
	GtkCellRenderer* renderer = gtk_cell_renderer_text_new();
	gtk_tree_view_append_column(view, col);
	gtk_tree_view_column_pack_start(col, renderer, TRUE);
	gtk_tree_view_column_add_attribute(col, renderer, "text", col_name);
	gtk_tree_view_column_add_attribute(col, renderer, "attributes", col_attr);
	gtk_cell_renderer_text_set_fixed_height_from_font(GTK_CELL_RENDERER_TEXT(renderer), 1);
	
	gtk_tree_view_set_model(view, GTK_TREE_MODEL(store));
	gtk_tree_selection_set_mode(gtk_tree_view_get_selection(view), GTK_SELECTION_BROWSE);
	gtk_tree_view_set_headers_visible(view, false);
	
	gtk_tree_view_set_enable_tree_lines(view, true);
	gtk_tree_view_expand_all(view);
	
	gtk_tree_view_set_show_expanders(view, false);
	gtk_tree_view_set_level_indentation(view, 19);
	
	gtk_tree_view_set_tooltip_column(view, col_name_html);
	
	
	scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	gtk_scrolled_window_set_policy(scrollview, GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(view));
	
	gboolean(*any_event_cb)(GtkWidget* widget, GdkEvent* event, void* user_data) =
	                     [](GtkWidget* widget, GdkEvent* event, void* user_data) -> gboolean
	{
		//Gtk somehow likes to eat the first scroll event on the application (or window?)
		//there is no bug in this function
		
		if (event->type == GDK_SCROLL)
		{
			chanview* cv = (chanview*)user_data;
			
			if (event->scroll.direction == GDK_SCROLL_UP) cv->move_focus(-1);
			if (event->scroll.direction == GDK_SCROLL_DOWN) cv->move_focus(1);
			if (event->scroll.direction == GDK_SCROLL_SMOOTH)
			{
				cv->scroll_accum += event->scroll.delta_y / px_per_step;
				if ((int)cv->scroll_accum != 0)
				{
					cv->move_focus((int)cv->scroll_accum);
					cv->scroll_accum -= (int)cv->scroll_accum;
				}
			}
			
			return GDK_EVENT_STOP;
		}
		
		return GDK_EVENT_PROPAGATE;
	};
	g_signal_connect(scrollview, "event", G_CALLBACK(any_event_cb), this);
}


chanview::chanbase::chanbase(chanview* parent, GtkTreeRowReference* parentrow, cstring name, bool can_focus, void* userdata)
{
	this->parent = parent;
	
	GtkTreeIter parentiter;
	
	if (parentrow)
	{
		GtkTreePath* path = gtk_tree_row_reference_get_path(parentrow);
		gtk_tree_model_get_iter(GTK_TREE_MODEL(parent->store), &parentiter, path);
		gtk_tree_path_free(path);
	}
	
	GtkTreeIter iter;
	gtk_tree_store_append(parent->store, &iter, parentrow ? &parentiter : NULL);
	
	gchar* name_html = g_markup_escape_text(name.c_str(), -1);
	gtk_tree_store_set(parent->store, &iter,
	                   col_name, (const char*)name.c_str(),
	                   col_name_html, name_html,
	                   col_userdata, userdata,
	                   col_focusable, (gboolean)can_focus,
	                   -1);
	g_free(name_html);
	
	GtkTreePath* path = gtk_tree_model_get_path(GTK_TREE_MODEL(parent->store), &iter);
	this->row = gtk_tree_row_reference_new(GTK_TREE_MODEL(parent->store), path);
	gtk_tree_view_expand_to_path(parent->view, path);
	
	if (can_focus) parent->focus_if_needed(path);
	gtk_tree_path_free(path);
}


//Will fire the onfocus callback.
void chanview::chanbase::focus()
{
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_selection_select_path(gtk_tree_view_get_selection(parent->view), path);
	gtk_tree_path_free(path);
}

void chanview::chanbase::rename(cstring name)
{
	GtkTreeIter iter;
	
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_model_get_iter(GTK_TREE_MODEL(parent->store), &iter, path);
	gtk_tree_path_free(path);
	
	gtk_tree_store_set(parent->store, &iter,
	                   col_name, (const char*)name.c_str(),
	                   -1);
}

void chanview::chanbase::color(uint32_t xrgb)
{
	GtkTreeIter iter;
	
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_model_get_iter(GTK_TREE_MODEL(parent->store), &iter, path);
	gtk_tree_path_free(path);
	
	gtk_tree_store_set(parent->store, &iter,
	                   col_attr, parent->attrs_for_color(xrgb),
	                   -1);
}


chanview::chanbase::~chanbase()
{
	GtkTreeIter iter;
	
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_model_get_iter(GTK_TREE_MODEL(parent->store), &iter, path);
	gtk_tree_path_free(path);
	
	gtk_tree_store_remove(parent->store, &iter);
	gtk_tree_row_reference_free(row);
}


static GtkTreeIter iter_next(GtkTreeModel* mod, GtkTreeIter node)
{
	//extra scopes to tell GCC it's fine to reuse the iterators' storage
	{
		GtkTreeIter child;
		if (gtk_tree_model_iter_children(mod, &child, &node)) return child;
	}
	
again:
	{
		GtkTreeIter sibling = node;
		if (gtk_tree_model_iter_next(mod, &sibling)) return sibling;
	}
	
	{
		GtkTreeIter parent;
		if (gtk_tree_model_iter_parent(mod, &parent, &node))
		{
			node = parent;
			goto again;
		}
	}
	
	GtkTreeIter first;
	gtk_tree_model_get_iter_first(mod, &first);
	return first;
}

static GtkTreeIter iter_prev(GtkTreeModel* mod, GtkTreeIter node)
{
	GtkTreeIter descend = node;
	if (gtk_tree_model_iter_previous(mod, &descend))
	{
		goto do_descend;
	}
	
	{
		GtkTreeIter parent;
		if (gtk_tree_model_iter_parent(mod, &parent, &node)) return parent;
	}
	
	gtk_tree_model_iter_nth_child(mod, &descend, NULL, gtk_tree_model_iter_n_children(mod, NULL)-1);
do_descend:
	
	while (gtk_tree_model_iter_n_children(mod, &descend) > 0)
	{
		GtkTreeIter child;
		gtk_tree_model_iter_nth_child(mod, &child, &descend, gtk_tree_model_iter_n_children(mod, &descend)-1);
		descend = child;
	}
	return descend;
}

void chanview::move_focus(int dir)
{
	//hexchat does this via some kinda linear channel-to-number and number-to-channel functions, each of which is O(channel count)
	//O(~30) is perfectly fine, but I'd rather do it better anyways
	
	GtkTreeSelection* sel = gtk_tree_view_get_selection(this->view);
	GtkTreeModel* mod;
	GtkTreeIter it;
	gtk_tree_selection_get_selected(sel, &mod, &it);
	
	GtkTreeIter newsel = it;
	gboolean can_focus;
	do {
		newsel = (dir>0 ? iter_next(mod, newsel) : iter_prev(mod, newsel));
		gtk_tree_model_get(mod, &newsel, col_focusable, &can_focus, -1);
	} while (!can_focus);
	gtk_tree_selection_select_iter(sel, &newsel);
	
	//why do most GtkTreeModel functions use iterators but GtkTreeView prefers paths
	GtkTreePath* path = gtk_tree_model_get_path(mod, &newsel);
	gtk_tree_view_scroll_to_cell(this->view, path, NULL, false, 0.0, 0.0);
	gtk_tree_path_free(path);
}

void chanview::focus_if_needed(GtkTreePath* path)
{
	GtkTreeSelection* sel = gtk_tree_view_get_selection(view);
	if (!gtk_tree_selection_get_selected(sel, NULL, NULL))
	{
		gtk_tree_selection_set_select_function(gtk_tree_view_get_selection(this->view),
			[](GtkTreeSelection* selection, GtkTreeModel* model, GtkTreePath* path,
			   gboolean path_currently_selected, void* userdata) -> gboolean
			{
				chanview* this_ = (chanview*)userdata;
				if (path_currently_selected) return true; // deselecting is always fine
				
				GtkTreeIter iter;
				gtk_tree_model_get_iter(model, &iter, path);
				
				void* userdata2;
				gboolean focusable;
				gtk_tree_model_get(model, &iter, col_userdata, &userdata2, col_focusable, &focusable, -1);
				if (!focusable) return false;
				this_->focus_cb(userdata2);
				
				return true;
			},
			this, NULL);
		
		gtk_tree_selection_select_path(sel, path);
	}
}


PangoAttrList* chanview::attrs_for_color(uint32_t xrgb)
{
	if (xrgb == (uint32_t)-1) return NULL;
	
	if (!color_attrs.contains(xrgb))
	{
		uint8_t r = xrgb>>16;
		uint8_t g = xrgb>>8;
		uint8_t b = xrgb>>0;
		PangoAttribute* attr = pango_attr_foreground_new(r*257, g*257, b*257);
		
		PangoAttrList* attrs = pango_attr_list_new();
		pango_attr_list_insert(attrs, attr);
		color_attrs.insert(xrgb, attrs);
	}
	return color_attrs.get(xrgb);
}


chanview::~chanview()
{
	for (auto& pair : color_attrs) { pango_attr_list_unref(pair.value); }
	g_object_unref(store);
	gtk_widget_destroy(GTK_WIDGET(view));
}
#endif
