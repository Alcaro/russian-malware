#include "russian.h"
#include <gtk/gtk.h>

#if !GTK_CHECK_VERSION(3,16,0)
//this is somewhat glitchy (textview works fine, but channel list gets scrollbar), but there's no better option for old gtks
#define GTK_POLICY_EXTERNAL GTK_POLICY_AUTOMATIC
#endif

enum {
	col_name,
	col_attr,
	col_userdata,
	col_count
};

static const float px_per_step = 3;

static gboolean any_event_cb(GtkWidget* widget, GdkEvent* event, gpointer user_data)
{
	if (event->type == GDK_SCROLL)
	{
		chanview* cv = (chanview*)user_data;
		
		if (event->scroll.direction == GDK_SCROLL_UP) cv->move_focus(-1);
		if (event->scroll.direction == GDK_SCROLL_DOWN) cv->move_focus(1);
		if (event->scroll.direction == GDK_SCROLL_SMOOTH) cv->_priv_scrolled_px(event->scroll.delta_y);
	}
	
	return false;
}

void chanview::_priv_scrolled_px(float delta)
{
	scroll_accum += delta / px_per_step;
	if ((int)scroll_accum != 0)
	{
		move_focus((int)scroll_accum);
		scroll_accum -= (int)scroll_accum;
	}
}

chanview::chanview()
{
	store = gtk_tree_store_new(3, G_TYPE_STRING, PANGO_TYPE_ATTR_LIST, G_TYPE_POINTER);
	
	view = GTK_TREE_VIEW(gtk_tree_view_new());
	
	GtkTreeViewColumn* col = gtk_tree_view_column_new();
	GtkCellRenderer* renderer = gtk_cell_renderer_text_new();
	gtk_tree_view_append_column(view, col);
	gtk_tree_view_column_pack_start(col, renderer, TRUE);
	gtk_tree_view_column_add_attribute(col, renderer, "text", 0);
	gtk_cell_renderer_text_set_fixed_height_from_font(GTK_CELL_RENDERER_TEXT(renderer), 1);
	
	gtk_tree_view_set_model(view, GTK_TREE_MODEL(store));
	gtk_tree_selection_set_mode(gtk_tree_view_get_selection(view), GTK_SELECTION_BROWSE);
	gtk_tree_view_set_headers_visible(view, false);
	
	gtk_tree_view_set_enable_tree_lines(view, true);
	gtk_tree_view_expand_all(view);
	
	g_signal_connect(gtk_tree_view_get_selection(view), "changed", G_CALLBACK(onfocus_sig_nat), this);
	
	gtk_tree_view_set_show_expanders(view, false);
	gtk_tree_view_set_level_indentation(view, 19);
	
	//TODO: figure out if this is helpful or annoying
	//gtk_tree_view_set_hover_selection(view, true);
	
	scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	gtk_scrolled_window_set_policy(scrollview, GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(view));
	
	g_signal_connect(scrollview, "event", G_CALLBACK(any_event_cb), this);
}

chanview::chanbase::chanbase(chanview* parent, GtkTreeRowReference* parentrow, cstring name, void* userdata)
{
	this->parent = parent;
	
	GtkTreeIter parentiter;
	
	if (parentrow)
	{
		GtkTreePath* path = gtk_tree_row_reference_get_path(parentrow);
		gtk_tree_model_get_iter(GTK_TREE_MODEL(parent->store), &parentiter, path);
		gtk_tree_path_free(path);
	}
	
	GtkTreeIter iter;
	gtk_tree_store_append(parent->store, &iter, parentrow ? &parentiter : NULL);
	gtk_tree_store_set(parent->store, &iter,
	                   col_name, (const char*)name.c_str(),
	                   col_userdata, userdata,
	                   -1);
	
	GtkTreePath* path = gtk_tree_model_get_path(GTK_TREE_MODEL(parent->store), &iter);
	this->row = gtk_tree_row_reference_new(GTK_TREE_MODEL(parent->store), path);
	gtk_tree_view_expand_to_path(parent->view, path);
	gtk_tree_path_free(path);
}

//void chanview::chanbase::color(color_t col) {}

//Will fire the onfocus callback.
void chanview::chanbase::focus()
{
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_selection_select_path(gtk_tree_view_get_selection(parent->view), path);
	gtk_tree_path_free(path);
}

void chanview::chanbase::rename(cstring name)
{
	GtkTreeIter iter;
	
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_model_get_iter(GTK_TREE_MODEL(parent->store), &iter, path);
	gtk_tree_path_free(path);
	
	gtk_tree_store_set(parent->store, &iter,
	                   col_name, (const char*)name.c_str(),
	                   -1);
}

chanview::chanbase::~chanbase()
{
	GtkTreeIter iter;
	
	GtkTreePath* path = gtk_tree_row_reference_get_path(row);
	gtk_tree_model_get_iter(GTK_TREE_MODEL(parent->store), &iter, path);
	gtk_tree_path_free(path);
	
	gtk_tree_store_remove(parent->store, &iter);
}

void chanview::onfocus_sig(GtkTreeSelection* sel)
{
	GtkTreeModel* model;
	GtkTreeIter iter;
	
	if (gtk_tree_selection_get_selected(sel, &model, &iter))
	{
		void* userdata;
		gtk_tree_model_get(model, &iter, col_userdata, &userdata, -1);
		this->focus_cb(userdata);
	}
}

static GtkTreeIter iter_next(GtkTreeModel* mod, GtkTreeIter node)
{
	//extra scopes to tell GCC it's fine to reuse the iterators' storage
	{
		GtkTreeIter child;
		if (gtk_tree_model_iter_children(mod, &child, &node)) return child;
	}
	
again:
	{
		GtkTreeIter sibling = node;
		if (gtk_tree_model_iter_next(mod, &sibling)) return sibling;
	}
	
	{
		GtkTreeIter parent;
		if (gtk_tree_model_iter_parent(mod, &parent, &node))
		{
			node = parent;
			goto again;
		}
	}
	
	GtkTreeIter first;
	gtk_tree_model_get_iter_first(mod, &first);
	return first;
}

static GtkTreeIter iter_prev(GtkTreeModel* mod, GtkTreeIter node)
{
	GtkTreeIter descend = node;
	if (gtk_tree_model_iter_previous(mod, &descend))
	{
		goto do_descend;
	}
	
	{
		GtkTreeIter parent;
		if (gtk_tree_model_iter_parent(mod, &parent, &node)) return parent;
	}
	
	gtk_tree_model_iter_nth_child(mod, &descend, NULL, gtk_tree_model_iter_n_children(mod, NULL)-1);
do_descend:
	
	while (gtk_tree_model_iter_n_children(mod, &descend) > 0)
	{
		GtkTreeIter child;
		gtk_tree_model_iter_nth_child(mod, &child, &descend, gtk_tree_model_iter_n_children(mod, &descend)-1);
		descend = child;
	}
	return descend;
}

void chanview::move_focus(int dir)
{
	//hexchat does this via some kinda linear channel-to-number and number-to-channel functions, each of which is O(channel count)
	//O(~30) is perfectly fine, but I'd rather do it better anyways
	
	GtkTreeSelection* sel = gtk_tree_view_get_selection(this->view);
	GtkTreeModel* mod;
	GtkTreeIter it;
	gtk_tree_selection_get_selected(sel, &mod, &it);
	
	GtkTreeIter newsel = (dir>0 ? iter_next(mod, it) : iter_prev(mod, it));
	gtk_tree_selection_select_iter(sel, &newsel);
}

chanview::group* chanview::child(cstring name, void* userdata)
{
	group* ret = new group(this, NULL, name, userdata);
	
	GtkTreeSelection* sel = gtk_tree_view_get_selection(view);
	if (!gtk_tree_selection_get_selected(sel, NULL, NULL))
	{
		GtkTreeIter iter;
		gtk_tree_model_get_iter_first(GTK_TREE_MODEL(store), &iter);
		gtk_tree_selection_select_iter(sel, &iter);
	}
	return ret;
}

chanview::~chanview()
{
	g_object_unref(store);
	gtk_widget_destroy(GTK_WIDGET(view));
}
