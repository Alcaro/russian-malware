#include "russian.h"

//bouncer launcher will
//- check that argc==2 and not isatty(stdin) and not isatty(stdout); if false, print an informational text message and exit
//- connect to AF_SEQPACKET unix socket at argv[1], where the actual bouncer listens
//- if it doesn't exist:
//  - parent: fork()
//  - parent: wait()
//  - child: create socket, which will be inherited by grandchild
//      if it exists, exit cleanly and let parent connect to that instead - maybe two Russians launched simultaneously
//  - child: fork()
//  - child: exit()
//  - parent: wait() returns
//  - parent: connect to socket
//      if this too fails, give up; print error and terminate
//   kinda pointless how daemonizing requires a fork-exit, rather than a disown() syscall or whatever
//   and it 'requires' a bunch of other random weird stuff too (like messing with controlling terminal),
//     half of which seems irrelevant for me. how fun
//- sendmsg() the stdin/stdout fds to bouncer, along with a NUL byte
//    it won't pass messages forever because pointless middleman, waste of time
//- keep stdin/stdout alive (to not confuse ssh), but ignore
//- stay alive forever, so ssh doesn't tear down the connection
//- if bouncer service dies, the fd used for sendmsg will close; bouncer launcher notices this and exits
//- if client disconnects, bouncer will send pings, not get an answer, and toss client out; launcher sees this as bouncer dying

//bouncer will, after getting the two fds, write the 16 bytes of the bouncer signature:
static const uint8_t russian_sig_bouncer[16] = {
	'R','U','S','M','A','L', // identifier, to avoid accidental launches by someone else
	'\x1B','[','c',          // terminals reply with some random warble if they see this
	'\r','\n',               // to ban CRLF->LF translations
	'\0',                    // commonly hated
	'\x1A',                  // DOS EOF
	'\n',                    // to ban LF->CRLF translations
	'\7',                    // another escape code
	0x89,                    // to protect against 8bit unclean stuff
};
//it will then read 16 bytes on stdin, expecting the client signature:
static const uint8_t russian_sig_client[16] = {
	'R','U','S','M','A','L',
	'\x1B','[','c',
	'\r','\n',
	'\0',
	'\x1A',
	'\n',
	'\7',
	0x8A, // same as above, except this byte has been changed
};
//if incorrect, it will give client an error and terminate
//if correct, bouncer will read 20 more bytes:
//- 4 bytes protocol version
//- 8 bytes config checksum (client's choice, bouncer doesn't care; client chooses truncated sha256 using bearssl implementation)
//- 8 bytes client timestamp
//all integers are little endian in this protocol
//
//after reading these 20 bytes, bouncer will switch to the runtime protocol
//bouncer will send *GETCONFIG (if needed), then client state, then *SCROLLBACK

//read differently: client, when connecting, will send
//- the 16 client signature bytes
//- 4 bytes protocol version
//- 8 bytes config checksum
//- 8 bytes client timestamp
//before reading the bouncer signature and starting to chat

//runtime protocol, version 0x00000001:
//a message looks like IRC, with a few extensions:
//- if the message starts with +, the final argument is that many bytes after the linebreak (which may contain \n or \0)
//    there can be no other final argument (starting with colon) before that
//    there is no terminator after said bytes
//- if the message starts with @, the message should be treated as having arrived at that timestamp (Unix epoch, microseconds, base 10)
//    two messages may not have the same timestamp; if they would be the same, the latter one must be incremented
//    if combined, @ must come before +
//    example:
//    @1234567890 +11 :Alcaro!floating@muncher.se PRIVMSG #serioushax
//    hello world@1234567891 :Alcaro!floating@muncher.se PRIVMSG #serioushax :hello world
//    bouncer will always include timestamp
//- a PRIVMSG from the client's nick is perfectly fine
//- login handshake is different; there's no NICK/USER, bouncer extracts that from client config
//- a few new commands, which start with * to avoid overlap with the real IRC:
//<< - messages sent only by client
//>> - messages sent only by bouncer
//>< - messages both can send
//>> *GETCONFIG
//  client replies with a *CONFIG command
//<< +123 *CONFIG 1234567890ABCDEF\n#ЯUSSIAN MALWДRE's bouncer ...
//  sends the client's config checksum as 16 hex digits, followed by the full config as BML
//  must use the + syntax
//>> +1234 *SCROLLBACK 0\n<binary warble>
//  contains the scrollback, DEFLATEd, as a sequence of commands; can be empty
//  the 0 is instead 1 if the bouncer has discarded messages since the one indicated in the handshake;
//    if so, 001 and 319 will be sent before anything else
//  if present, it's the first (or second, after *GETCONFIG) command sent by the bouncer after connecting
//
//when connecting, bouncer will send
//- *GETCONFIG, if needed
//- 001, to tell client its current nick
//- some JOINs
//
//additionally, bouncer understands the following standard commands from client:
//  PRIVMSG - bouncer sends it to IRC server, and creates a PRIVMSG from the caller
//  DIE - bouncer terminates, used to update it or debug stuff
//  QUIT - bouncer closes connection to irc server, used for debugging
//and the following from server:
//  001, NICK - updates who sent PRIVMSGs come from
//  JOIN, PART, KICK - updates what channels client is in
//    client state is a 001 and a 319
//>> DISCONNECTED
//  bouncer has disconnected and is attempting to reconnect
//  there's no message for when it reconnects, client should look for 001 or JOIN
//  bouncer may send multiple of those, as well as several NICK/USER to the server, before being connected
//<< DIE
//  bouncer terminates; client will soon create a new one
//  to disconnect from IRC only, send QUIT to the server
//  used for debugging, or to upgrade to a new bouncer version
//  if using in-process bouncer, this is ignored
//<< EXIT
//  bouncer kicks out the client
//  used for debugging
//  if using in-process bouncer, this is ignored
//>> ACK PRIVMSG #serioushax :munchers
//  the current client sent the above message to the IRC server; it has arrived and gotten a timestamp
//  if this is sent, other clients get a :Alcaro!kremlin@whitehouse.gov PRIVMSG #serioushax :munchers


//how about security? nope, none (other than SSH)
//bouncer and bouncer launcher run under the same user (unless the pipe is in idiotland), there's no security boundary to enforce
//client-bouncer communication is authenticated and encrypted by SSH; if I distrust SSH, I have bigger problems than an irc client
//and there is no possible place to put any security, either; bouncer is zero-config, there's no way to verify a password
//
//however, I will consider it a bug if a hostile bouncer can terminate the client,
//or if a hostile client could exploit the bouncer (exit(), abort() and pointers <= 0xFFFF are not exploits, DIE can do that anyways)
//(in-process bouncer is not subject to hostile other-side, it doesn't need security either)



//completely different option:
//put bouncer on the other side. only bouncer knows the different protocols, only bouncer connects the outside world.
//client supports only a homemade protocol.
//except client has to understand the local formatting, as well as /me, or it'd give uncomfortable delays
//and tab complete and probably a few other things
//so that'd be a mess.



namespace russian { namespace {

class bouncer : nocopy {
	
};

#ifndef ARGUI_NONE
//socket* socket_create_bouncer()
//{
//	
//}

class irc : public protocol {
public:
	struct channel {
		string name;
		string key;
		bool permanent = false;
		
		autoptr<russian::channel> host;
	};
	
	string name; // CaffieNET
	array<string> addresses; // irc.caffie.net:6667
	size_t addressid = 0;
	
	array<string> nicks;
	size_t nickid;
	string ident;
	string realname;
	
	string mynick;
	uintptr_t chan_top_id; // this overflows if you join 2^64 channels. just ... don't do that
	map<uintptr_t, channel> channels;
	map<string, uintptr_t> channel_id;
	
	array<string> onconnect;
	
	uintptr_t timer_id = 0;
	bool pingsent;
	static const uint32_t delay_reconnect = 10000;
	static const uint32_t delay_ping = 30000;
	
	autoptr<group> server;
	
	enum { st_nocon, st_nickuser, st_conn } state;
	autoptr<socket> sock;
	bytepipe sockbytes;
	
	
	/*private*/ void msg_chan_fmt(chanbase* chan, chanbase::importance_t imp, time_t at, cstring source, cstring text)
	{
		static const uint32_t colors[16] = {
			0xcccccc, 0x000000, 0x3535b3, 0x2a8c2a,
			0xd02a2a, 0x6f2828, 0x80267f, 0xdc721d,
			0xd9a641, 0x3dcc3d, 0x195555, 0x27d6c0,
			0x4545e6, 0xda31da, 0x6c6c6c, 0xafafaf,
		};
		
		span next;
		array<span> spans;
		
		size_t n=0;
		while (n<text.length())
		{
			uint8_t ch = text[n++];
			if (LIKELY(ch >= 32)) { next.text += ch; continue; }
			
			spans.append(next);
			next.text = "";
			
			if(0);
			else if (ch == 0x02) next.bold ^= 1;
			else if (ch == 0x1D) next.italics ^= 1;
			else if (ch == 0x1F) next.underline ^= 1;
			else if (ch == 0x0F) next = span();
			else if (ch == 0x03)
			{
				if (isdigit(text[n]))
				{
					{
						string colid;
						colid += text[n++];
						if (isdigit(text[n])) colid += text[n++];
						
						uint32_t colnum;
						fromstring(colid, colnum);
						next.fgcol = colors[colnum%16];
					}
					
					if (text[n] == ',' && isdigit(text[n+1]))
					{
						n++;
						
						string colid;
						colid += text[n++];
						if (isdigit(text[n])) colid += text[n++];
						
						uint32_t colnum;
						fromstring(colid, colnum);
						next.bgcol = colors[colnum%16];
					}
				}
				else { next.fgcol = -1; next.bgcol = -1; }
			}
			else next.text += ch;
		}
		spans.append(next);
		
		chan->message(imp, at, source, spans);
	}
	
	/*private*/ void send(cstring line)
	{
		msg_chan_fmt(server, chanbase::imp_none, time(NULL), "", "<< "+line);
		sock->send((line+"\r\n").bytes());
	}
	
	channel& chan_or_tmp(cstring name)
	{
		uintptr_t id = channel_id.get_or(name, 0);
		bool create = (id==0);
		if (create)
		{
			id = chan_top_id++;
			channel_id.insert(name, id);
		}
		channel& chan = channels.get_create(id);
		if (create)
		{
			chan.host = server->child(name, (void*)id);
			chan.name = name;
		}
		return chan;
	}
	
	/*private*/ array<cstring> parseline(cstring line)
	{
		array<cstring> parts;
		
		if (line[0]==':')
		{
			array<cstring> tmp = line.csplit<1>(" ");
			parts.append(tmp[0]);
			line = tmp[1];
		}
		else parts.append("");
		
		while (line && line[0]!=':')
		{
			array<cstring> tmp = line.csplit<1>(" ");
			parts.append(tmp[0]);
			if (tmp.size()==1) break;
			line = tmp[1];
		}
		
		if (line) parts.append(line.substr(1, ~0));
		
		return parts;
	}
	
	/*private*/ void ircline(string line, time_t at)
	{
		msg_chan_fmt(server, chanbase::imp_none, at, "", ">> "+line);
		
		array<cstring> parts = parseline(line);
		
		cstring source = (parts[0] ? parts[0].substr(1, ~0).csplit<1>("!")[0] : "");
		
		cstring cmd = parts[1];
		if (cmd == "PING")
		{
			send("PONG :"+parts[2]);
		}
		if (cmd == "PONG")
		{
			pingsent = false;
		}
		if (cmd == "001")
		{
			addressid = 0;
			
			for (cstring s : onconnect) send(s);
			
			if (state == st_nickuser)
			{
				string channels;
				string passchannels;
				string passwords = " ";
				for (auto& pair : this->channels)
				{
					if (!pair.value.permanent) continue;
					cstring name = pair.value.name;
					cstring pass = pair.value.key;
					if (pass) { passchannels += ","+name; passwords += ","+pass; }
					else channels += ","+name;
				}
				send("JOIN "+(passchannels+channels).substr(1, ~0)+passwords.substr(1, ~0));
				
				state = st_conn;
				timer_id = runloop::global()->set_timer_rel(timer_id, delay_ping, bind_this(&irc::timer_cb));
			}
			server->rename(name);
		}
		if (cmd == "433")
		{
			if (nickid == nicks.size())
				mynick = nicks[0]+tostring<4>(rand()%10000);
			else
				mynick = nicks[nickid++];
			send("NICK "+mynick);
		}
		if (cmd == "JOIN")
		{
			if (source == mynick)
			{
				cstring name = parts[2];
				channel& chan = chan_or_tmp(name);
				chan.host->rename(chan.name);
			}
		}
		if (cmd == "PRIVMSG")
		{
			cstring name = (parts[2][0]=='#') ? parts[2] : source;
			channel& chan = chan_or_tmp(name);
			msg_chan_fmt(chan.host, chanbase::imp_msg, at, source, parts[3]);
		}
	}
	
	/*private*/ void activity()
	{
		byte tmp[4096];
		int n = sock->recv(tmp);
		if (n<0)
		{
			sock = NULL;
			state = st_nocon;
			timer_id = runloop::global()->set_timer_rel(timer_id, delay_reconnect, bind_this(&irc::timer_cb));
			msg_chan_fmt(server, chanbase::imp_status, time(NULL), "", "Connection broken, reconnecting in "+tostring(delay_reconnect)+"ms");
			return;
		}
		sockbytes.push(arrayview<byte>(tmp, n));
		
		while (true)
		{
			arrayview<byte> lineb = sockbytes.pull_line();
			if (!lineb) break;
			string line(sockbytes.trim_line(lineb));
			sockbytes.pull_done(lineb);
			
			ircline(std::move(line), time(NULL));
		}
	}
	
	/*private*/ void connect()
	{
		state = st_nickuser;
		pingsent = false;
		
		server->rename("("+name+")");
		for (auto& pair : channels)
		{
			pair.value.host->rename("("+pair.value.name+")");
		}
		
		msg_chan_fmt(server, chanbase::imp_status, time(NULL), "", "Connecting to "+addresses[addressid]);
		
		//TODO: can't put an ipv6 address here
		//why did they choose :, rather than + or ' or ANYTHING else that's not likely to be near the address
		//: is the worst choice possible except / and alphanumerics
		
		array<cstring> parts = addresses[addressid].csplit<1>(":");
		if (parts.size() == 1) parts.append("6667");
		bool ssl = (parts[1][0]=='+');
		bool ssl_perm = (ssl && parts[1][1]=='-');
		uint16_t port;
		if (!fromstring(parts[1].substr(ssl+ssl_perm, ~0), port)) port = 0;
		
		sock = (ssl_perm ? socket::create_ssl_noverify : ssl ? socket::create_ssl : socket::create)(parts[0], port, runloop::global());
		addressid = (addressid+1) % addresses.size();
		
		sock->callback(bind_this(&irc::activity));
		nickid = 0;
		mynick = nicks[nickid++];
		send("NICK "+mynick);
		send("USER "+ident+" a a :"+realname);
		
		return;
	}
	
	/*private*/ bool timer_cb()
	{
		if (state == st_conn && !pingsent)
		{
			pingsent = true;
			send("PING :1");
		}
		else
		{
			connect();
		}
		return true;
	}
	
	irc(impl* parent, bmlunserialize_impl& s) : protocol(parent)
	{
		name = s.nextval();
		chan_top_id = 1;
		
		server = mkgroup(name, 0);
		server->rename("("+name+")");
		
		ser_enter(s)
		{
			s.item("address", addresses);
			s.item("nick", nicks);
			s.item("ident", ident);
			s.item("realname", realname);
			s.item("onconnect", onconnect);
			
			while (s.next() == "channel")
			{
				channel& chan = chan_or_tmp(s.nextval());
				chan.host->rename("("+chan.name+")");
				chan.permanent = true;
				ser_enter(s)
				{
					s.item("key", chan.key);
				}
			}
		}
		
		state = st_nocon;
		connect();
	}
	
	void action(cstring text, void* userdata)
	{
		uintptr_t id = (uintptr_t)userdata;
		if (!id) return;
		
		channel& chan = channels.get(id);
		array<cstring> lines = text.csplit("\n");
		for (cstring& line : lines)
		{
			send("PRIVMSG "+chan.name+" :"+line);
			msg_chan_fmt(chan.host, chanbase::imp_msg, time(NULL), mynick, line);
		}
	}
	
	~irc()
	{
		runloop::global()->remove(timer_id);
	}
};
#endif
}
#ifndef ARGUI_NONE
russian::protocol* russian::protocol::create_irc(impl* parent, bmlunserialize_impl& s) { return new irc(parent, s); }
#endif

void do_irc_bouncer(cstring path)
{
	//TODO
	puts("bouncer="+path);
}
}
