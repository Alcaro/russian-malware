#include "russian.h"

namespace russian { namespace {

class irc : public protocol {
public:
	struct channel {
		string name;
		string key;
		bool permanent = false;
		
		autoptr<russian::channel> host;
		
		void serialize(bmlunserialize_impl& s)
		{
			s.item("key", key);
		}
	};
	
	string name;
	array<string> address;
	
	array<string> nick;
	size_t nickid; // TODO: if nick is taken, use this to pick another one
	               // if all nicks are taken, append 5-digit random number to 'nick'
	string ident;
	string realname;
	
	uintptr_t chan_top_id;
	map<uintptr_t, channel> channels;
	map<string, uintptr_t> channel_id;
	
	array<string> onconnect;
	
	
	group* server;
	
	enum { st_nocon, st_nickuser, st_conn } state;
	autoptr<socket> sock;
	bytepipe sockbytes;
	
	
	/*private*/ void send(cstring line)
	{
		span msg[2];
		msg[0].text = "<< ";
		msg[1].text = line;
		server->message(0, msg);
		sock->send(line+"\r\n");
	}
	
	channel& chan_or_tmp(cstring name)
	{
		uintptr_t id = channel_id.get_or(name, 0);
		bool create = (id==0);
		if (create)
		{
			id = chan_top_id++;
			channel_id.insert(name, id);
		}
		channel& chan = channels.get_create(id);
		if (create)
		{
			chan.host = server->child(name, (void*)id);
			chan.name = name;
		}
		return chan;
	}
	
	/*private*/ void ircline(string line)
	{
		span msg[2];
		msg[0].text = ">> ";
		msg[1].text = line;
		server->message(0, msg);
		
		cstring remaining = line;
		array<cstring> part;
		
		if (remaining[0]==':')
		{
			array<cstring> tmp = remaining.csplit<1>(" ");
			part.append(tmp[0]);
			remaining = tmp[1];
		}
		else part.append("");
		
		while (remaining && remaining[0]!=':')
		{
			array<cstring> tmp = remaining.csplit<1>(" ");
			part.append(tmp[0]);
			remaining = tmp[1];
		}
		
		if (remaining) part.append(remaining.substr(1, ~0));
		
		cstring source = (part[0] ? part[0].substr(1, ~0).csplit<1>("!")[0] : "");
		
		cstring cmd = part[1];
		if (cmd == "PING")
		{
			send("PONG :"+part[2]);
		}
		if (cmd == "001")
		{
			for (cstring s : onconnect) send(s);
			
			if (state == st_nickuser)
			{
				string channels;
				string passchannels;
				string passwords;
				for (auto& pair : this->channels)
				{
puts("CHANNEL:"+tostring(pair.value.permanent)+":"+pair.value.name+":"+pair.value.key);
					if (!pair.value.permanent) continue;
					cstring name = pair.value.name;
					cstring pass = pair.value.key;
					if (pass) { passchannels += ","+name; passwords += ","+pass; }
					else channels += ","+name;
puts("DOJOIN:"+channels+":"+passchannels+":"+passwords);
				}
				send("JOIN "+(passchannels+channels).substr(1, ~0)+" "+passwords.substr(1, ~0));
			}
		}
		if (cmd == "JOIN")
		{
			cstring name = part[2];
			channel& chan = chan_or_tmp(name);
			(void)chan; // nothing to do, just create it
		}
		if (cmd == "PRIVMSG")
		{
			cstring name = (part[2][0]=='#') ? part[2] : source;
			channel& chan = chan_or_tmp(name);
			
			span msg[1];
			msg[0].text = "<"+source+"> "+part[3];
			chan.host->message(0, msg);
		}
	}
	
	/*private*/ void activity(socket*)
	{
		byte tmp[1];
		int n = sock->recv(tmp);
		if (n<0)
		{
			sock = NULL;
			state = st_nocon;
			
		}
		sockbytes.push(arrayview<byte>(tmp, n));
		
		while (true)
		{
			arrayview<byte> lineb = sockbytes.pull_line();
			if (!lineb) break;
			string line(sockbytes.trim_line(lineb));
			sockbytes.pull_done(lineb);
			
			ircline(std::move(line));
		}
	}
	
	/*private*/ void connect()
	{
		if (state != st_nocon) return;
		
		state = st_nickuser;
		
		sock = socket::create("92.246.28.59", 6667);
		sock->callback(runloop::global(), bind_this(&irc::activity));
		nickid = 0;
		send("NICK "+nick[nickid]);
		send("USER "+ident+" lol wut :"+realname);
	}
	
	irc(impl* parent, bmlunserialize_impl& s) : protocol(parent)
	{
		name = s.nextval();
		chan_top_id = 1;
		
		server = mkgroup(name, &server);
		
		s.item("irc", *this);
		
		state = st_nocon;
		connect();
	}
	
	void serialize(bmlunserialize_impl& s)
	{
		s.item("address", address);
		s.item("nick", nick);
		s.item("ident", ident);
		s.item("realname", realname);
		s.item("onconnect", onconnect);
		if (s.next()=="channel")
		{
			channel& chan = chan_or_tmp(s.nextval());
			chan.permanent = true;
			s.item("channel", chan);
		}
	}
	
	void action(cstring text, void* userdata)
	{
		span msg[1];
		msg[0].text = text;
		server->message(0, msg);
		sock->send(text+"\r\n");
	}
};
}
russian::protocol* russian::protocol::create_irc(impl* parent, bmlunserialize_impl& s) { return new irc(parent, s); }
}
