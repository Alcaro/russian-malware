#include "russian.h"

//TODO: default quit message:
//Моё су́дно на возду́шной поду́шке по́лно угре́й

namespace russian { namespace {

class irc : public protocol {
public:
	struct channel {
		string name;
		string key;
		bool permanent = false;
		
		autoptr<russian::channel> host;
	};
	
	string name; // CaffieNET
	array<string> addresses; // irc.caffie.net:6667
	size_t addressid = 0;
	
	array<string> nicks;
	size_t nickid;
	string ident;
	string realname;
	
	string mynick;
	uintptr_t chan_top_id; // this overflows if you join 2^64 channels. just ... don't do that
	map<uintptr_t, channel> channels;
	map<string, uintptr_t> channel_id;
	
	array<string> onconnect;
	
	uintptr_t timer_id = 0;
	bool pingsent;
	const uint32_t delay_reconnect = 10000;
	const uint32_t delay_ping = 30000;
	
	
	autoptr<group> server;
	
	enum { st_nocon, st_nickuser, st_conn } state;
	autoptr<socket> sock;
	bytepipe sockbytes;
	
	
	/*private*/ void msg_chan_fmt(chanbase* chan, time_t at, cstring source, cstring text)
	{
		//TODO
		span msg[1];
		msg[0].text = text;
		chan->message(at, source, msg);
	}
	
	/*private*/ void send(cstring line)
	{
		msg_chan_fmt(server, time(NULL), "", "<< "+line);
		sock->send((line+"\r\n").bytes());
	}
	
	channel& chan_or_tmp(cstring name)
	{
		uintptr_t id = channel_id.get_or(name, 0);
		bool create = (id==0);
		if (create)
		{
			id = chan_top_id++;
			channel_id.insert(name, id);
		}
		channel& chan = channels.get_create(id);
		if (create)
		{
			chan.host = server->child(name, (void*)id, false);
			chan.name = name;
		}
		return chan;
	}
	
	/*private*/ void ircline(string line, time_t at)
	{
		msg_chan_fmt(server, at, "", ">> "+line);
		
		cstring remaining = line;
		array<cstring> part;
		
		if (remaining[0]==':')
		{
			array<cstring> tmp = remaining.csplit<1>(" ");
			part.append(tmp[0]);
			remaining = tmp[1];
		}
		else part.append("");
		
		while (remaining && remaining[0]!=':')
		{
			array<cstring> tmp = remaining.csplit<1>(" ");
			part.append(tmp[0]);
			remaining = tmp[1];
		}
		
		if (remaining) part.append(remaining.substr(1, ~0));
		
		cstring source = (part[0] ? part[0].substr(1, ~0).csplit<1>("!")[0] : "");
		
		cstring cmd = part[1];
		if (cmd == "PING")
		{
			send("PONG :"+part[2]);
		}
		if (cmd == "PONG")
		{
			pingsent = false;
		}
		if (cmd == "001")
		{
			addressid = 0;
			
			for (cstring s : onconnect) send(s);
			
			if (state == st_nickuser)
			{
				string channels;
				string passchannels;
				string passwords;
				for (auto& pair : this->channels)
				{
					if (!pair.value.permanent) continue;
					cstring name = pair.value.name;
					cstring pass = pair.value.key;
					if (pass) { passchannels += ","+name; passwords += ","+pass; }
					else channels += ","+name;
				}
				send("JOIN "+(passchannels+channels).substr(1, ~0)+" "+passwords.substr(1, ~0));
				
				state = st_conn;
				timer_id = runloop::global()->set_timer_rel(timer_id, delay_ping, bind_this(&irc::timer_cb));
			}
			server->set_available(at, true);
		}
		if (cmd == "433")
		{
			if (nickid == nicks.size())
				mynick = nicks[0]+tostring<4>(rand()%10000);
			else
				mynick = nicks[nickid++];
			send("NICK "+mynick);
		}
		if (cmd == "JOIN")
		{
			cstring name = part[2];
			channel& chan = chan_or_tmp(name);
			chan.host->set_available(at, true);
		}
		if (cmd == "PRIVMSG")
		{
			cstring name = (part[2][0]=='#') ? part[2] : source;
			channel& chan = chan_or_tmp(name);
			msg_chan_fmt(chan.host, at, source, part[3]);
		}
	}
	
	/*private*/ void activity(socket*)
	{
		byte tmp[4096];
		int n = sock->recv(tmp);
		if (n<0)
		{
			sock = NULL;
			state = st_nocon;
			timer_id = runloop::global()->set_timer_rel(timer_id, delay_reconnect, bind_this(&irc::timer_cb));
			msg_chan_fmt(server, time(NULL), "", "Connection broken, reconnecting in "+tostring(delay_reconnect)+"ms");
			return;
		}
		sockbytes.push(arrayview<byte>(tmp, n));
		
		while (true)
		{
			arrayview<byte> lineb = sockbytes.pull_line();
			if (!lineb) break;
			string line(sockbytes.trim_line(lineb));
			sockbytes.pull_done(lineb);
			
			ircline(std::move(line), time(NULL));
		}
	}
	
	/*private*/ void connect()
	{
		state = st_nickuser;
		pingsent = false;
		
		server->set_available(time(NULL), false);
		for (auto& pair : channels)
		{
			pair.value.host->set_available(time(NULL), false);
		}
		
		msg_chan_fmt(server, time(NULL), "", "Connecting to "+addresses[addressid]);
		
		//TODO: can't put an ipv6 address here
		//why did they choose :, rather than + or ' or ANYTHING else that's not likely to be near the address
		//: is the worst choice possible except / and alphanumerics
		
		array<cstring> parts = addresses[addressid].csplit<1>(":");
		if (parts.size() == 1) parts.append("6667");
		bool ssl = (parts[1][0]=='+');
		int port;
		if (!fromstring(parts[1].substr(ssl ? 1 : 0, ~0), port)) port = 0;
		
		sock = (ssl ? socket::create_ssl : socket::create)(parts[0], port, runloop::global());
		addressid = (addressid+1) % addresses.size();
		
		sock->callback(runloop::global(), bind_this(&irc::activity));
		nickid = 0;
		mynick = nicks[nickid++];
		send("NICK "+mynick);
		send("USER "+ident+" lol wut :"+realname);
		
		return;
	}
	
	/*private*/ bool timer_cb()
	{
		if (state == st_conn && !pingsent)
		{
			pingsent = true;
			send("PING :1");
		}
		else
		{
			connect();
		}
		return true;
	}
	
	irc(impl* parent, bmlunserialize_impl& s) : protocol(parent)
	{
		name = s.nextval();
		chan_top_id = 1;
		
		server = mkgroup(name, 0, false);
		
		ser_enter(s)
		{
			s.item("address", addresses);
			s.item("nick", nicks);
			s.item("ident", ident);
			s.item("realname", realname);
			s.item("onconnect", onconnect);
			//s.item("delay-reconnect", delay_reconnect);
			//s.item("delay-ping", delay_ping);
			
			while (s.next() == "channel")
			{
				channel& chan = chan_or_tmp(s.nextval());
				chan.permanent = true;
				ser_enter(s)
				{
					s.item("key", chan.key);
				}
			}
		}
		
		state = st_nocon;
		connect();
	}
	
	void action(cstring text, void* userdata)
	{
		uintptr_t id = (uintptr_t)userdata;
		if (!id) return;
		
		channel& chan = channels.get(id);
		send("PRIVMSG "+chan.name+" :"+text);
		msg_chan_fmt(chan.host, time(NULL), mynick, text);
	}
	
	~irc()
	{
		runloop::global()->remove(timer_id);
	}
};
}
russian::protocol* russian::protocol::create_irc(impl* parent, bmlunserialize_impl& s) { return new irc(parent, s); }
}
