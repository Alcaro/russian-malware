#include "russian.h"

//bouncer launcher will
//- check that argc==2 and not isatty(stdin) and not isatty(stdout); if false, print an informational text message and exit
//- connect to AF_SEQPACKET unix socket at argv[1], where the actual bouncer listens
//- if it doesn't exist:
//  - parent: fork()
//  - parent: wait()
//  - child: create socket, which will be inherited by grandchild
//      if it exists, exit cleanly and let parent connect to that instead - maybe two Russians launched simultaneously
//  - child: fork()
//  - child: exit()
//  - parent: wait() returns
//  - parent: connect to socket
//      if this too fails, give up; print error and terminate
//   kinda pointless how daemonizing requires a fork-exit, rather than a disown() syscall or whatever
//   and it 'requires' a bunch of other random weird stuff too (like messing with controlling terminal),
//     half of which seems irrelevant for me. how fun
//- sendmsg() the stdin/stdout fds to bouncer, along with a NUL byte
//    it won't pass messages forever because pointless middleman, waste of time
//- keep stdin/stdout alive (to not confuse ssh), but ignore
//- stay alive forever, so ssh doesn't tear down the connection
//- if bouncer service dies, the fd used for sendmsg will close; bouncer launcher notices this and exits
//- if client disconnects, bouncer will send pings, not get an answer, and toss client out; launcher sees this as bouncer dying

//bouncer will, after getting the two fds, write the 16 bytes of the bouncer signature:
static const uint8_t russian_sig_bouncer[16] = {
	'R','U','S','M','A','L', // identifier, to avoid accidental launches by someone else
	'\x1B','[','c',          // terminals reply with some random warble if they see this
	'\r','\n',               // to ban CRLF->LF translations
	'\0',                    // commonly hated
	'\x1A',                  // DOS EOF
	'\n',                    // to ban LF->CRLF translations
	'\7',                    // another escape code
	0x89,                    // to protect against 8bit unclean stuff
};
//it will then read 16 bytes on stdin, expecting the client signature:
static const uint8_t russian_sig_client[16] = {
	'R','U','S','M','A','L',
	'\x1B','[','c',
	'\r','\n',
	'\0',
	'\x1A',
	'\n',
	'\7',
	0x8A, // same as above, except this byte has been changed
};
//if incorrect, it will give client an error and terminate
//if correct, bouncer will read 20 more bytes:
//- 4 bytes protocol version
//- 8 bytes config checksum (client's choice, bouncer doesn't care; client chooses truncated sha256 using bearssl implementation)
//- 8 bytes client timestamp
//all integers are little endian in this protocol
//
//after reading these 20 bytes, bouncer will switch to the runtime protocol
//bouncer will send *GETCONFIG (if needed), then client state, then *SCROLLBACK lines

//read differently: client, when connecting, will send
//- the 16 client signature bytes
//- 4 bytes protocol version
//- 8 bytes config checksum
//- 8 bytes client timestamp
//before reading the bouncer signature and starting to chat

//runtime protocol, version 0x00000001:
//a message looks like IRC, with a few extensions:
//- if the message starts with +, the final argument is that many bytes after the linebreak (which may contain \n or \0)
//    there can be no other final argument (starting with colon) before that
//    there is no terminator after said bytes
//- if the message starts with @, the message should be treated as having arrived at that timestamp (Unix epoch, in microseconds, base 10)
//    two messages may not have the same timestamp; if they would be the same, the latter one must be incremented
//    if combined, @ must come before +
//    example:
//    @1234567890 +11 :Alcaro!floating@muncher.se PRIVMSG #serioushax
//    hello world@1234567891 :Alcaro!floating@muncher.se PRIVMSG #serioushax :hello world
//    bouncer will always include it
//- a PRIVMSG from the client is perfectly fine; caller will use that
//- login handshake is different; there's no NICK/USER, bouncer extracts that from client config
//- a few new commands, which start with * to avoid overlap with the real IRC:
//<< - messages sent only by client
//>> - messages sent only by bouncer
//>< - messages both can send
//>> *GETCONFIG
//  client replies with a *CONFIG command
//<< +123 *CONFIG 1234567890ABCDEF\n#ЯUSSIAN MALWДRE's bouncer ...
//  sends the client's config checksum as 16 hex digits, followed by the full config as BML
//  must use the + syntax
//>> +1234 *SCROLLBACK 0\n<binary warble>
//  contains the scrollback, DEFLATEd, as a sequence of commands; can be empty
//  the 0 is instead 1 if the bouncer has discarded messages since the one indicated in the handshake
//  if present, it's the first (or second, after *GETCONFIG) command sent by the bouncer after connecting
//
//when connecting, bouncer will send
//- *GETCONFIG, if needed
//- 001, to tell client its current nick
//- some JOINs
//
//additionally, bouncer understands the following standard commands from client:
//  PRIVMSG - bouncer sends it to IRC server, and creates a PRIVMSG from the caller
//  DIE - bouncer terminates, used to update it or debug stuff
//  QUIT - bouncer closes connection to irc server, used for debugging
//and the following from server:
//  001, NICK - updates who sent PRIVMSGs come from
//  JOIN, PART, KICK - updates what channels client is in
//    client state is a 001 and a 319
//>> DISCONNECTED
//  bouncer has disconnected and is attempting to reconnect
//  there's no message for when it reconnects, client should look for 001 or JOIN
//  bouncer may send multiple of those, as well as several NICK/USER to the server, before being connected
//<< DIE
//  bouncer terminates; client will soon create a new one
//  to disconnect from IRC only, send QUIT to the server
//  used for debugging, or to upgrade to a new bouncer version
//  if using in-process bouncer, this is ignored
//<< EXIT
//  bouncer kicks out the client
//  used for debugging
//  if using in-process bouncer, this is ignored
//>> ACK PRIVMSG #serioushax :munchers
//  the current client sent the above message to the IRC server; it has arrived and gotten a sequence number
//>> WARNING :Config mismatch
//  the bouncer is dissatisfied with something the client did; the message should be shown to the user
//>< STATUS Alcaro #serioushax,#smwc
//  sets the current username, and the list of channels the client is in; bouncer sends it back to all connected clients
//  if the client asks for a sequence number that the bouncer has discarded, it will always start from a STATUS or DISCONNECTED
//  (this means the bouncer can keep logs longer than three days in some cases)
//>> -GETSTATUS
//  requests that the client sends a STATUS, bouncer doesn't track that itself
//  this happens whenever bouncer feels it's about to run out of discardable stuff











//runtime protocol, version 0x00000001:
//a message starts with 4 bytes length/type
//  highest three bits decide type:
//    000 - ping; the recipient will immediately send a pong with the same body
//    001 - pong; can be sent unannounced, which will be ignored
//    100 - irc server sent that; only bouncer sends this
//    101 - it's to the irc server; both client and bouncer can send those
//          if bouncer gets this, it sends a ACK control to that client, and a 101 to others
//          bouncer can also decide to send stuff on its own, like PING/PONG or reconnecting
//    111 - it's a control message to/from the bouncer itself
//  the remaining 29 bits are the length, which can be 0
//irc/control messages start with a 8 byte timestamp, signed, unix epoch, in microseconds
//  bouncer ignores them, but they must still be there; client uses them
//irc messages are followed by the raw line to/from the server; no CRLF, bouncer adds/removes that
//control messages are formatted like irc:
//  optional source (starts with a colon), then command name, then space-separated arguments
//  if an argument starts with a colon, it's removed, and the parsing ends; that argument lasts until the message ends
//  however, unlike irc's CRLF-terminated messages, these are length-prefixed, so they can contain linebreaks
//list:
//<< - messages sent only by client
//>> - messages sent only by bouncer
//>< - messages both can send
//>> -GETCONFIG
//  client replies with a CONFIG command
//  the dash means the command does not have a sequence number and is only sent to this client
//<< CONFIG 1234567890ABCDEF :#ЯUSSIAN MALWДRE's bouncer ...
//  sends the client's config checksum as 16 hex digits, followed by the full config as BML
//  unlike irc messages, this one can and should contain linebreaks
//>> -SEQUENCE 123 456
//  the first number is usually same as sequence number in the handshake; if not, bouncer has discarded messages since that one
//  a newly started bouncer sends the same value - unix timestamp in microseconds - twice
//  either way, the next numbered message from bouncer is this value plus 1
//  the second number is the latest message the bouncer has seen; once that one arrives, your scrollback is done transmitting
//  it's the first (or second, after GETCONFIG) command sent by the bouncer after connecting
//>> DISCONNECTED
//  bouncer has disconnected and is attempting to reconnect
//  there's no message for when it reconnects, client should look for 001 or JOIN
//  bouncer may send multiple of those, as well as several NICK/USER to the server, before being connected
//<< DIE
//  bouncer terminates; client will soon create a new one
//  to disconnect from IRC only, send QUIT to the server
//  used for debugging, or to upgrade to a new bouncer version
//  if using in-process bouncer, this is ignored
//<< EXIT
//  bouncer kicks out the client
//  used for debugging
//  if using in-process bouncer, this is ignored
//>> ACK PRIVMSG #serioushax :munchers
//  the current client sent the above message to the IRC server; it has arrived and gotten a sequence number
//>> WARNING :Config mismatch
//  the bouncer is dissatisfied with something the client did; the message should be shown to the user
//>< STATUS Alcaro #serioushax,#smwc
//  sets the current username, and the list of channels the client is in; bouncer sends it back to all connected clients
//  if the client asks for a sequence number that the bouncer has discarded, it will always start from a STATUS or DISCONNECTED
//  (this means the bouncer can keep logs longer than three days in some cases)
//>> -GETSTATUS
//  requests that the client sends a STATUS, bouncer doesn't track that itself
//  this happens whenever bouncer feels it's about to run out of discardable stuff

//how about security? nope, none (other than SSH)
//bouncer and bouncer launcher run under the same user (unless the pipe is in idiotland), there's no security boundary to enforce
//client-bouncer communication is authenticated and encrypted by SSH; if I distrust SSH, I have bigger problems than an irc client
//and there is no possible place to put any security, either; bouncer is zero-config, there's no way to verify a password
//
//however, I will consider it a bug if a hostile bouncer can terminate the client,
//or if a hostile client could exploit the bouncer (exit(), abort() and pointers <= 0xFFFF are not exploits, DIE can do that anyways)
//(in-process bouncer is not subject to hostile other-side, it doesn't need security)



//completely different option:
//put bouncer on the other side. only bouncer knows the different protocols, only bouncer connects the outside world.
//client supports only a homemade protocol.
//except client has to understand the local formatting, as well as /me, or it'd give uncomfortable delays
//and tab complete and probably a few other things
//so that'd be a mess.



namespace russian { namespace {

class bouncer : nocopy {
	
};

class irc : public protocol {
public:
	struct channel {
		string name;
		string key;
		bool permanent = false;
		
		autoptr<russian::channel> host;
	};
	
	string name; // CaffieNET
	array<string> addresses; // irc.caffie.net:6667
	size_t addressid = 0;
	
	array<string> nicks;
	size_t nickid;
	string ident;
	string realname;
	
	string mynick;
	uintptr_t chan_top_id; // this overflows if you join 2^64 channels. just ... don't do that
	map<uintptr_t, channel> channels;
	map<string, uintptr_t> channel_id;
	
	array<string> onconnect;
	
	uintptr_t timer_id = 0;
	bool pingsent;
	static const uint32_t delay_reconnect = 10000;
	static const uint32_t delay_ping = 30000;
	
	
	autoptr<group> server;
	
	enum { st_nocon, st_nickuser, st_conn } state;
	autoptr<socket> sock;
	bytepipe sockbytes;
	
	
	/*private*/ void msg_chan_fmt(chanbase* chan, time_t at, cstring source, cstring text)
	{
		//TODO
		span msg[1];
		msg[0].text = text;
		chan->message(at, source, msg);
	}
	
	/*private*/ void send(cstring line)
	{
		msg_chan_fmt(server, time(NULL), "", "<< "+line);
		sock->send((line+"\r\n").bytes());
	}
	
	channel& chan_or_tmp(cstring name)
	{
		uintptr_t id = channel_id.get_or(name, 0);
		bool create = (id==0);
		if (create)
		{
			id = chan_top_id++;
			channel_id.insert(name, id);
		}
		channel& chan = channels.get_create(id);
		if (create)
		{
			chan.host = server->child(name, (void*)id);
			chan.name = name;
		}
		return chan;
	}
	
	/*private*/ array<cstring> parseline(cstring line)
	{
		array<cstring> parts;
		
		if (line[0]==':')
		{
			array<cstring> tmp = line.csplit<1>(" ");
			parts.append(tmp[0]);
			line = tmp[1];
		}
		else parts.append("");
		
		while (line && line[0]!=':')
		{
			array<cstring> tmp = line.csplit<1>(" ");
			parts.append(tmp[0]);
			line = tmp[1];
		}
		
		if (line) parts.append(line.substr(1, ~0));
		
		return parts;
	}
	
	/*private*/ void ircline(string line, time_t at)
	{
		msg_chan_fmt(server, at, "", ">> "+line);
		
		array<cstring> parts = parseline(line);
		
		cstring source = (parts[0] ? parts[0].substr(1, ~0).csplit<1>("!")[0] : "");
		
		cstring cmd = parts[1];
		if (cmd == "PING")
		{
			send("PONG :"+parts[2]);
		}
		if (cmd == "PONG")
		{
			pingsent = false;
		}
		if (cmd == "001")
		{
			addressid = 0;
			
			for (cstring s : onconnect) send(s);
			
			if (state == st_nickuser)
			{
				string channels;
				string passchannels;
				string passwords;
				for (auto& pair : this->channels)
				{
					if (!pair.value.permanent) continue;
					cstring name = pair.value.name;
					cstring pass = pair.value.key;
					if (pass) { passchannels += ","+name; passwords += ","+pass; }
					else channels += ","+name;
				}
				send("JOIN "+(passchannels+channels).substr(1, ~0)+" "+passwords.substr(1, ~0));
				
				state = st_conn;
				timer_id = runloop::global()->set_timer_rel(timer_id, delay_ping, bind_this(&irc::timer_cb));
			}
			server->set_available(at, true);
		}
		if (cmd == "433")
		{
			if (nickid == nicks.size())
				mynick = nicks[0]+tostring<4>(rand()%10000);
			else
				mynick = nicks[nickid++];
			send("NICK "+mynick);
		}
		if (cmd == "JOIN")
		{
			if (source == mynick)
			{
				cstring name = parts[2];
				channel& chan = chan_or_tmp(name);
				chan.host->set_available(at, true);
			}
		}
		if (cmd == "PRIVMSG")
		{
			cstring name = (parts[2][0]=='#') ? parts[2] : source;
			channel& chan = chan_or_tmp(name);
			msg_chan_fmt(chan.host, at, source, parts[3]);
		}
	}
	
	/*private*/ void activity()
	{
		byte tmp[4096];
		int n = sock->recv(tmp);
		if (n<0)
		{
			sock = NULL;
			state = st_nocon;
			timer_id = runloop::global()->set_timer_rel(timer_id, delay_reconnect, bind_this(&irc::timer_cb));
			msg_chan_fmt(server, time(NULL), "", "Connection broken, reconnecting in "+tostring(delay_reconnect)+"ms");
			return;
		}
		sockbytes.push(arrayview<byte>(tmp, n));
		
		while (true)
		{
			arrayview<byte> lineb = sockbytes.pull_line();
			if (!lineb) break;
			string line(sockbytes.trim_line(lineb));
			sockbytes.pull_done(lineb);
			
			ircline(std::move(line), time(NULL));
		}
	}
	
	/*private*/ void connect()
	{
		state = st_nickuser;
		pingsent = false;
		
		server->set_available(time(NULL), false);
		for (auto& pair : channels)
		{
			pair.value.host->set_available(time(NULL), false);
		}
		
		msg_chan_fmt(server, time(NULL), "", "Connecting to "+addresses[addressid]);
		
		//TODO: can't put an ipv6 address here
		//why did they choose :, rather than + or ' or ANYTHING else that's not likely to be near the address
		//: is the worst choice possible except / and alphanumerics
		
		array<cstring> parts = addresses[addressid].csplit<1>(":");
		if (parts.size() == 1) parts.append("6667");
		bool ssl = (parts[1][0]=='+');
		int port;
		if (!fromstring(parts[1].substr(ssl ? 1 : 0, ~0), port)) port = 0;
		
		sock = (ssl ? socket::create_ssl : socket::create)(parts[0], port, runloop::global());
		addressid = (addressid+1) % addresses.size();
		
		sock->callback(bind_this(&irc::activity));
		nickid = 0;
		mynick = nicks[nickid++];
		send("NICK "+mynick);
		send("USER "+ident+" lol wut :"+realname);
		
		return;
	}
	
	/*private*/ bool timer_cb()
	{
		if (state == st_conn && !pingsent)
		{
			pingsent = true;
			send("PING :1");
		}
		else
		{
			connect();
		}
		return true;
	}
	
	irc(impl* parent, bmlunserialize_impl& s) : protocol(parent)
	{
		name = s.nextval();
		chan_top_id = 1;
		
		server = mkgroup(name, 0);
		
		ser_enter(s)
		{
			s.item("address", addresses);
			s.item("nick", nicks);
			s.item("ident", ident);
			s.item("realname", realname);
			s.item("onconnect", onconnect);
			
			while (s.next() == "channel")
			{
				channel& chan = chan_or_tmp(s.nextval());
				chan.permanent = true;
				ser_enter(s)
				{
					s.item("key", chan.key);
				}
			}
		}
		
		state = st_nocon;
		connect();
	}
	
	void action(cstring text, void* userdata)
	{
		uintptr_t id = (uintptr_t)userdata;
		if (!id) return;
		
		channel& chan = channels.get(id);
		send("PRIVMSG "+chan.name+" :"+text);
		msg_chan_fmt(chan.host, time(NULL), mynick, text);
	}
	
	~irc()
	{
		runloop::global()->remove(timer_id);
	}
};
}
russian::protocol* russian::protocol::create_irc(impl* parent, bmlunserialize_impl& s) { return new irc(parent, s); }
}
