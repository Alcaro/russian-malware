#include "russian.h"

//TODO: bouncer launcher will
//- read the 16 signature bytes on stdin, ensuring they're
//  'RUSMAL'       - identifier, to avoid accidental launches by someone else
//  \x1B, '[', 'c' - terminals reply with some random warble if they see this
//  CR, LF         - to ban CRLF->LF translations
//  NUL            - commonly hated
//  \x89           - to protect against 8bit unclean stuff
//  BEL            - another escape code
//  \x1A           - DOS EOF
//  LF             - to ban LF->CRLF translations
//- if signature is wrong, print an informational text message and exit
//- read 1 byte of length, then N bytes of ASCII to tell which network it's connecting to
//    for example \x07 "DerpNET"
//- connect to AF_SEQPACKET unix socket at $XDG_RUNTIME_DIR+"/russian-malware/DerpNET", where the actual bouncer listens
//- if it doesn't exist, fork, daemonize and create it, then connect again
//- sendmsg() the stdin/stdout fds to bouncer, in a message whose body is the 16 signature bytes
//    why not pass just messages forever? pointless middleman, waste of time
//- stay alive forever, so ssh doesn't tear down the connection
//- if bouncer service dies, the fd used for sendmsg will close; bouncer launcher notices this and exits
//
//to avoid funky races:
//- parent: connect to socket, fail because doesn't exist
//- parent: fork()
//- parent: wait()
//- child: create socket, which will be inherited by grandchild
//    if it exists, exit cleanly and let parent connect to that instead - maybe two Russians launched simultaneously
//- child: fork()
//- child: exit()
//- parent: wait() returns
//- parent: connect to socket, which is known to exist at this point
//- parent: forward stdin/stdout forever
//- grandchild: accept stuff from socket
//kinda pointless how daemonizing requires a fork-exit, rather than a disown() syscall or whatever
//and it 'requires' a bunch of other random weird stuff too (like messing with controlling terminal),
//  half of which seems irrelevant for me. how fun

//once the bouncer gets the stdin/stdout fds and ensured the message's signature is correct, it will
//- read 4 bytes of protocol version number
//    if signature or version is wrong, print an informational text message and close fds
//- write the 16 signature bytes, to tell client it's found the right guy
//- read 8 bytes of checksum of the config (truncated md5)
//  - if that doesn't match the current config, send a request-client-config message, and a warning if this isn't a fresh launch
//- read 8 bytes, the sequence number of the latest message that client has
//  - send all logged messages (if any) since said message sequence number
//- [TODO]

//read differently: client, when connecting, will send
//- the 16 signature bytes
//- length-prefixed server name
//- 4 bytes of protocol version
//- 8 bytes of checksum of the config (truncated md5)
//- 8 bytes of latest checksum byte
//before reading anything

//protocol structure after handshake/connecting:
//4 bytes of message type, 4 bytes of length, N bytes of body
//[C] for stuff client sends, [S] for stuff server sends
//timestamp is unused by server, and ignored by client for most messages

//TODO: what messages do I need? request-client-config, what else?
//how much does client need to know about irc protocol? how much does bouncer need to know?
//do I make bouncer send raw irc lines (plus timestamps and sequence numbers), or a more convenient format?
//actually, no need to send sequence numbers at all, just have client keep track of the last one and increment it

//protocol:
//8 bytes unix timestamp, little endian
//4 bytes length and type; if positive, it's from/to the irc server (CRLF added/removed by bouncer), if negative, it's a control message
//control messages are formatted like IRC, but without the source, like IRC PING
//list:
//<< - messages sent only by client
//>> - messages sent only by bouncer
//>< - messages both can send
//>> SEQUENCE 123
//

//how about security? nope, none
//bouncer and bouncer launcher run under the same username, there's no security boundary to enforce
//client-bouncer communication is protected by SSH; if I distrust SSH, I have bigger problems than an irc client

namespace russian { namespace {

class irc : public protocol {
public:
	struct channel {
		string name;
		string key;
		bool permanent = false;
		
		autoptr<russian::channel> host;
	};
	
	string name; // CaffieNET
	array<string> addresses; // irc.caffie.net:6667
	size_t addressid = 0;
	
	array<string> nicks;
	size_t nickid;
	string ident;
	string realname;
	
	string mynick;
	uintptr_t chan_top_id; // this overflows if you join 2^64 channels. just ... don't do that
	map<uintptr_t, channel> channels;
	map<string, uintptr_t> channel_id;
	
	array<string> onconnect;
	
	uintptr_t timer_id = 0;
	bool pingsent;
	static const uint32_t delay_reconnect = 10000;
	static const uint32_t delay_ping = 30000;
	
	
	autoptr<group> server;
	
	enum { st_nocon, st_nickuser, st_conn } state;
	autoptr<socket> sock;
	bytepipe sockbytes;
	
	
	/*private*/ void msg_chan_fmt(chanbase* chan, time_t at, cstring source, cstring text)
	{
		//TODO
		span msg[1];
		msg[0].text = text;
		chan->message(at, source, msg);
	}
	
	/*private*/ void send(cstring line)
	{
		msg_chan_fmt(server, time(NULL), "", "<< "+line);
		sock->send((line+"\r\n").bytes());
	}
	
	channel& chan_or_tmp(cstring name)
	{
		uintptr_t id = channel_id.get_or(name, 0);
		bool create = (id==0);
		if (create)
		{
			id = chan_top_id++;
			channel_id.insert(name, id);
		}
		channel& chan = channels.get_create(id);
		if (create)
		{
			chan.host = server->child(name, (void*)id);
			chan.name = name;
		}
		return chan;
	}
	
	/*private*/ void ircline(string line, time_t at)
	{
		msg_chan_fmt(server, at, "", ">> "+line);
		
		cstring remaining = line;
		array<cstring> part;
		
		if (remaining[0]==':')
		{
			array<cstring> tmp = remaining.csplit<1>(" ");
			part.append(tmp[0]);
			remaining = tmp[1];
		}
		else part.append("");
		
		while (remaining && remaining[0]!=':')
		{
			array<cstring> tmp = remaining.csplit<1>(" ");
			part.append(tmp[0]);
			remaining = tmp[1];
		}
		
		if (remaining) part.append(remaining.substr(1, ~0));
		
		cstring source = (part[0] ? part[0].substr(1, ~0).csplit<1>("!")[0] : "");
		
		cstring cmd = part[1];
		if (cmd == "PING")
		{
			send("PONG :"+part[2]);
		}
		if (cmd == "PONG")
		{
			pingsent = false;
		}
		if (cmd == "001")
		{
			addressid = 0;
			
			for (cstring s : onconnect) send(s);
			
			if (state == st_nickuser)
			{
				string channels;
				string passchannels;
				string passwords;
				for (auto& pair : this->channels)
				{
					if (!pair.value.permanent) continue;
					cstring name = pair.value.name;
					cstring pass = pair.value.key;
					if (pass) { passchannels += ","+name; passwords += ","+pass; }
					else channels += ","+name;
				}
				send("JOIN "+(passchannels+channels).substr(1, ~0)+" "+passwords.substr(1, ~0));
				
				state = st_conn;
				timer_id = runloop::global()->set_timer_rel(timer_id, delay_ping, bind_this(&irc::timer_cb));
			}
			server->set_available(at, true);
		}
		if (cmd == "433")
		{
			if (nickid == nicks.size())
				mynick = nicks[0]+tostring<4>(rand()%10000);
			else
				mynick = nicks[nickid++];
			send("NICK "+mynick);
		}
		if (cmd == "JOIN")
		{
			cstring name = part[2];
			channel& chan = chan_or_tmp(name);
			chan.host->set_available(at, true);
		}
		if (cmd == "PRIVMSG")
		{
			cstring name = (part[2][0]=='#') ? part[2] : source;
			channel& chan = chan_or_tmp(name);
			msg_chan_fmt(chan.host, at, source, part[3]);
		}
	}
	
	/*private*/ void activity(socket*)
	{
		byte tmp[4096];
		int n = sock->recv(tmp);
		if (n<0)
		{
			sock = NULL;
			state = st_nocon;
			timer_id = runloop::global()->set_timer_rel(timer_id, delay_reconnect, bind_this(&irc::timer_cb));
			msg_chan_fmt(server, time(NULL), "", "Connection broken, reconnecting in "+tostring(delay_reconnect)+"ms");
			return;
		}
		sockbytes.push(arrayview<byte>(tmp, n));
		
		while (true)
		{
			arrayview<byte> lineb = sockbytes.pull_line();
			if (!lineb) break;
			string line(sockbytes.trim_line(lineb));
			sockbytes.pull_done(lineb);
			
			ircline(std::move(line), time(NULL));
		}
	}
	
	/*private*/ void connect()
	{
		state = st_nickuser;
		pingsent = false;
		
		server->set_available(time(NULL), false);
		for (auto& pair : channels)
		{
			pair.value.host->set_available(time(NULL), false);
		}
		
		msg_chan_fmt(server, time(NULL), "", "Connecting to "+addresses[addressid]);
		
		//TODO: can't put an ipv6 address here
		//why did they choose :, rather than + or ' or ANYTHING else that's not likely to be near the address
		//: is the worst choice possible except / and alphanumerics
		
		array<cstring> parts = addresses[addressid].csplit<1>(":");
		if (parts.size() == 1) parts.append("6667");
		bool ssl = (parts[1][0]=='+');
		int port;
		if (!fromstring(parts[1].substr(ssl ? 1 : 0, ~0), port)) port = 0;
		
		sock = (ssl ? socket::create_ssl : socket::create)(parts[0], port, runloop::global());
		addressid = (addressid+1) % addresses.size();
		
		sock->callback(runloop::global(), bind_this(&irc::activity));
		nickid = 0;
		mynick = nicks[nickid++];
		send("NICK "+mynick);
		send("USER "+ident+" lol wut :"+realname);
		
		return;
	}
	
	/*private*/ bool timer_cb()
	{
		if (state == st_conn && !pingsent)
		{
			pingsent = true;
			send("PING :1");
		}
		else
		{
			connect();
		}
		return true;
	}
	
	irc(impl* parent, bmlunserialize_impl& s) : protocol(parent)
	{
		name = s.nextval();
		chan_top_id = 1;
		
		server = mkgroup(name, 0);
		
		ser_enter(s)
		{
			s.item("address", addresses);
			s.item("nick", nicks);
			s.item("ident", ident);
			s.item("realname", realname);
			s.item("onconnect", onconnect);
			
			while (s.next() == "channel")
			{
				channel& chan = chan_or_tmp(s.nextval());
				chan.permanent = true;
				ser_enter(s)
				{
					s.item("key", chan.key);
				}
			}
		}
		
		state = st_nocon;
		connect();
	}
	
	void action(cstring text, void* userdata)
	{
		uintptr_t id = (uintptr_t)userdata;
		if (!id) return;
		
		channel& chan = channels.get(id);
		send("PRIVMSG "+chan.name+" :"+text);
		msg_chan_fmt(chan.host, time(NULL), mynick, text);
	}
	
	~irc()
	{
		runloop::global()->remove(timer_id);
	}
};
}
russian::protocol* russian::protocol::create_irc(impl* parent, bmlunserialize_impl& s) { return new irc(parent, s); }
}
