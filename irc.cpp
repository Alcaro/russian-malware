#include "russian.h"
#include <sys/socket.h>
#include <sys/un.h>
#include <signal.h>

// plausible upgrades:
// - allow running bouncer on another machine than the ui (run the socket over ssh)
//     https://man.archlinux.org/man/core/libssh2/libssh2_channel_direct_streamlocal_ex.3.en
//     needs some config on how to start the remote process, nothing too tricky (can be started over the same ssh channel)
//     use Form1.cs as template for how to use ssh
// - have client store exit time somewhere and use that to tell bouncer server where to resume from,
//     instead of server storing 'last time anyone disconnected'

// IRCv3 has plenty of moderately useful capabilities (echo-message, chghost, sasl, multi-prefix and draft/chathistory)
// but (even if including server-time) they're not enough to implement a seamless bouncer; I can't find caps for
// - sending current connection state without the client logging a join in every channel
// - having client tell when to send logs from (not sure if chathistory implements that, but it's a draft anyways)
// - how to represent bouncer/server disconnects
// - configuring the bouncer (this one shouldn't even try to be standardized, but I can just make a private capability)
// so I'll just leave them all unimplemented until and unless I feel a need for them
// (which is probably never, some of them look annoying to parse)

namespace russian { namespace {

namespace irc {
// autopilot - contains the socket
// - responds to 001 and PING
// - sends raw lines, parsed lines, and Connecting/Disconnected messages to its parent object
// serialization returns list of servers, nicks, channels, and other things from the main config file
template<typename Tparent>
class autopilot {
	struct autojoin {
		string name;
		string key;
		SERIALIZE(name, key);
	};
	array<autojoin> autojoins;
	
	array<string> addresses; // Only used while not connected.
	size_t addressid = 0; // Only used while not connected.
	
	array<string> nicks;
	size_t nickid; // Only used while not connected.
	time_t reset_nick_before;
	string ident = "ukrainian";
	string realname = APPNAME;
	string rawlog_fname;
	
	array<string> sasl;
	array<string> onconnect;
	
	socketbuf sock;
	
	bool ping_sent = false;
	bool connected = false; // False if the socket is broken, or if the server didn't say 001 yet.
	
	// unserializable
	file rawlog_file;
	waiter<void> pingtime_wait = make_waiter<&autopilot::pingtime_wait, &autopilot::pingtime_cb>();
	static const uint32_t delay_reconnect = 30000;
	static const uint32_t delay_ping = 90000;
	
	waiter<void> sock_wait;
	
	Tparent* parent()
	{
		return container_of<&Tparent::pilot>(this);
	}
	
	struct ui_state {
		string root_name;
		string bouncer;
		bool show_joins = true;
		bool merge_joins = false;
		bool show_motd = true;
		array<string> highlights;
		array<autojoin>& channels;
	};
public:
	ui_state serialize(auto& s)
	{
		if (!s.serializing)
		{
			autojoins.reset();
			sasl.reset();
			onconnect.reset();
		}
		ui_state ret { .channels = autojoins };
		SER_ENTER(s)
		{
			s.item("name", ret.root_name);
			s.item("bouncer", ret.bouncer);
			s.item("addresses", addresses);
			s.item("nicks", nicks);
			s.item("ident", ident);
			s.item("realname", realname);
			s.item("highlights", ret.highlights);
			s.item("onconnect", onconnect);
			s.item("sasl", sasl);
			s.item("show_joins", ret.show_joins);
			s.item("merge_joins", ret.merge_joins);
			s.item("motd", ret.show_motd);
			s.item("rawlog", rawlog_fname);
			s.item("channels", autojoins);
		}
		ret.highlights.append(nicks[0]);
		return ret;
	}
private:
	
	void disconnected_inner()
	{
		sock = NULL;
		connected = false;
	}
	
	void disconnected(cstring reason)
	{
		disconnected_inner();
		connect_status(reason);
		connect(delay_reconnect);
	}
	
	void connect(int delay) // start connecting to server in N ms
	{
		disconnected_inner();
		pingtime_wait.cancel();
		
		// extra indirection in case it's called by the socket coroutine
		runloop2::in_ms(delay).then(&pingtime_wait);
	}
	
	void connect_real()
	{
		sock_wait.cancel();
		main_recv().then(&sock_wait);
		runloop2::in_ms(delay_ping).then(&pingtime_wait);
	}
	
	async<void> main_recv()
	{
		cstring addr = addresses[addressid];
		addressid = (addressid+1) % addresses.size();
		
		connect_status("** Connecting to "+addr);
		if (addr.contains(":+"))
			sock = co_await autoproxy::socket_create_ssl(addr.replace(":+",":"), 6697);
		else
			sock = co_await autoproxy::socket_create(addr, 6667);
		if (!sock)
		{
			disconnected("** Couldn't connect");
			co_return;
		}
		
		ping_sent = false;
		connect_status("** Connected to "+addr);
		
		if (sasl.size() == 2)
		{
			// this may break if I enable any other CAPs, or if the server doesn't support SASL
			// may want to co_await responses between these lines
			send("CAP REQ :sasl");
			send("AUTHENTICATE PLAIN");
			send("AUTHENTICATE "+base64_enc((sasl[0]+string::nul()+sasl[0]+string::nul()+sasl[1]).bytes()));
			send("CAP END");
		}
		
		nickid = 0;
		send("NICK "+nicks[nickid++]);
		send("USER "+ident+" a a :"+realname);
		reset_nick_before = 0;
		
		while (true)
		{
			cstring line = co_await sock.line(8192+512);
			if (!line)
			{
				disconnected("** Connection broken");
				co_return;
			}
			ircline(bytepipe::trim_line(line), time(NULL));
		}
	}
	
public:
	static array<cstring> parseline(cstring line)
	{
		static_assert(std::is_same_v<Tparent, void>);
		
		array<cstring> parts;
		
		if (line[0]==':')
		{
			array<cstring> tmp = line.csplit<1>(" ");
			parts.append(tmp[0]);
			line = tmp[1];
		}
		else parts.append("");
		
		while (line && line[0]!=':')
		{
			array<cstring> tmp = line.csplit<1>(" ");
			parts.append(tmp[0]);
			if (tmp.size() == 1)
				return parts;
			line = tmp[1];
		}
		
		if (line) parts.append(line.substr(1, ~0));
		
		return parts;
	}
private:
	
	string logdate(time_t rawtime)
	{
		struct tm * timeinfo = localtime(&rawtime);
		char out[64];
		strftime(out, 64, "[%H:%M:%S]", timeinfo);
		return out;
	}
	string logdate()
	{
		return logdate(time(NULL));
	}
	
	void ircline(cstring line, time_t at)
	{
		if (rawlog_file)
			rawlog_file.write(logdate()+" >> "+line+"\n");
		
		if (!line.isutf8())
		{
			string newline;
			for (uint8_t n : line.bytes())
			{
				if (n == '\r' || n == '\0')
					newline += "\xEF\xBF\xBD";
				else
					newline += string::codepoint(n);
			}
			ircline(newline, at);
			return;
		}
		if (line.contains_nul() || line.contains("\r"))
		{
			ircline(line.replace(string::nul(), "\xEF\xBF\xBD").replace("\r", "\xEF\xBF\xBD"), at);
			return;
		}
		
		array<cstring> parts_real = autopilot<void>::parseline(line);
		size_t n_parts = parts_real.size();
		if (parts_real.size() < 10)
			parts_real.resize(10); // to ensure overflows don't do anything too silly
		arrayview<cstring> parts = parts_real.slice(0, n_parts);
		
		cstring cmd = parts[1];
		
		if (reset_nick_before)
		{
			if ((cmd == "QUIT" && parts[0].substr(1, ~0).csplit<1>("!")[0].lower() == nicks[0].lower()) ||
				reset_nick_before < time(NULL))
			{
				send("NICK "+nicks[0]);
				reset_nick_before = 0;
			}
		}
		
		if (cmd == "PING")
		{
			send("PONG :"+parts[2]);
		}
		else if (cmd == "PONG")
		{
			ping_sent = false;
		}
		else if (cmd == "001" && !connected)
		{
			connected = true;
			addressid = 0;
			nickid = 0;
			
			for (cstring s : onconnect)
				send(s);
			
			string channels;
			string passchannels;
			string passwords = " ";
			for (const autojoin& chan : autojoins)
			{
				cstring name = chan.name;
				cstring pass = chan.key;
				if (pass) { passchannels += ","+name; passwords += pass+","; }
				else channels += ","+name;
			}
			if (channels || passchannels)
				send("JOIN "+(passchannels+channels).substr(1, ~0)+passwords.substr(0, ~1));
		}
		else if (cmd == "433" && !connected)
		{
			if (nickid == nicks.size())
				send(format("NICK ",nicks[0],fmt_pad<4>(g_rand(10000))));
			else
				send("NICK "+nicks[nickid++]);
			reset_nick_before = time(NULL)+600;
		}
		else if (cmd == "PRIVMSG" && parts[3].startswith("\1") && parts[3].endswith("\1"))
		{
			cstring source = parts[0].substr(1, ~0).csplit<1>("!")[0];
			cstring body = parts[3].substr(1, ~1);
			cstring word = body.csplit<1>(" ")[0];
			//cstring arg = body.csplit<1>(" ")[1]; // unused, but may make sense for some CTCP handlers
			
			if (word == "ACTION") {}
			else if (word == "VERSION")
				send("NOTICE "+source+" :\1VERSION " APPNAME " https://github.com/Alcaro/russian-malware\1");
			else if (word == "PING")
				send("NOTICE "+source+" :\1"+body+"\1");
			else
				send("NOTICE "+source+" :\1ERRMSG Unknown CTCP command.\1");
			return;
		}
		
		parent()->ircline(line, parts, at);
	}
	
	void pingtime_cb()
	{
		if (!sock)
		{
			connect_real();
		}
		else if (ping_sent)
		{
			connect_status("** Connection timed out");
			connect(0);
		}
		else if (!connected)
		{
			disconnected("** Connection timed out");
		}
		else
		{
			ping_sent = true;
			send("PING :1");
			runloop2::in_ms(delay_ping).then(&pingtime_wait);
		}
	}
	
	void connect_status(cstring text)
	{
		parent()->connect_status(text, time(NULL));
	}
	
public:
	void send(cstring line)
	{
		if (rawlog_file)
			rawlog_file.write(logdate()+" << "+line+"\n");
		sock.send_buf(line,"\r\n");
		sock.send_flush();
	}
	
	bool active() { return pingtime_wait.is_waiting(); }
	// Connects to the IRC server. Can only be called once. Do not call if the parent object is supposed to connect to a bouncer instead.
	void activate()
	{
		if (rawlog_fname)
			rawlog_file.open(file::resolve(file::exedir(), rawlog_fname), file::m_replace);
		
		connect_real();
	}
	void deactivate()
	{
		pingtime_wait.cancel();
		sock_wait.cancel();
		sock.reset();
	}
	void debug_log(cstring line)
	{
		if (rawlog_file)
			rawlog_file.write(logdate()+" ** "+line+"\n");
	}
};

// tracker - tracks members of your channels, and converts parsed lines to formatted messages
// serialization returns the channel list; deserializing to a fresh tracker yields an identical one
// the tracker can not cause any message to be sent to the IRC server
template<typename Tparent>
class tracker {
	Tparent* parent()
	{
		return container_of<&Tparent::track>(this);
	}
	
public:
	struct channel {
		string name;
		bool joined = false; // Always true for queries, unless the server is offline.
		array<string> members;
		
		bool is_query() const { return is_query(name); }
		static bool is_query(cstring name) { return name[0]!='#' && name[0]!='&'; }
		
		void serialize(auto& s)
		{
			SER_ENTER(s)
			{
				s.item("name", name);
				s.item("joined", joined);
				s.item("members", members);
			}
		}
	};
	
private:
	// config (I prefer keeping config in the autopilot if possible, but 'possible' is false for some of those)
	bool show_motd = true;
	chanbase::importance_t join_imp;
	array<string> highlights;
	
	// state
	string mynick;
	string myident; // contains both ident and hostname
public:
	bool connected = false;
	map<string, channel> channels;
	
	void serialize(auto& s)
	{
		SER_ENTER(s)
		{
			s.item("connected", connected);
			s.item("mynick", mynick);
			s.item("myident", myident);
			s.item("channels", channels);
		}
	}
	
	channel& get_channel(cstring name)
	{
		channel& chan = channels.get_create(name);
		if (!chan.name)
		{
			chan.name = name;
			bool is_query = chan.is_query();
			chan.joined = is_query;
			// unnecessary, query channels omit the user list
			//if (is_query)
			//	chan.members = { mynick, name };
		}
		return chan;
	}
private:
	
	channel* get_chan_or_null(cstring name)
	{
		return channels.get_or_null(name);
	}
	
public:
	void disconnected(time_t at)
	{
		for (channel& chan : channels.values())
		{
			if (chan.joined && !chan.is_query())
			{
				channel_set_joined(chan, false);
				channel_msg(chan, join_imp, at, "\3""5** Disconnected");
			}
		}
		connected = false;
	}
	
	void ircline(cstring line, time_t at)
	{
		ircline(line, autopilot<void>::parseline(line), at);
	}
	void ircline(cstring line, arrayview<cstring> parts, time_t at)
	{
		cstring source = (parts[0]               ? parts[0].substr(1, ~0).csplit<1>("!")[0] : "");
		cstring ident  = (parts[0].contains("!") ? parts[0].substr(1, ~0).csplit<1>("!")[1] : "");
		
		if (source == mynick)
			myident = ident;
		
		cstring cmd = parts[1];
		if (cmd == "PING") {}
		else if (cmd == "PONG") {}
		else if (cmd == "001")
		{
			channels.reset();
			mynick = parts[2];
			// 001 does not send my ident, and the one in the USER command could be wrong (could be tilde prefixed)
			// let it be wrong for now, it'll show up on next JOIN
			connected = true;
			parent()->connected(at);
		}
		else if (cmd == "JOIN")
		{
			cstring name = parts[2];
			channel& chan = get_channel(name);
			if (source == mynick)
			{
				channel_set_joined(chan, true);
				channel_msg(chan, join_imp, at, "\3""9** Now talking on "+name);
			}
			channel_msg_mergeable(chan, join_imp, at, "\3""9* \2"+source+"\2 ("+ident+") has joined "+name, "\3""9+"+source);
			channel_user_join(chan, source);
		}
		else if (cmd == "NICK")
		{
			for (channel& chan : channels.values())
			{
				if (chan.is_query())
					continue;
				if (chan.members.contains(source))
				{
					channel_msg_mergeable(chan, join_imp, at, "\3""7* "+source+" is now known as "+parts[2], "\3""7"+source+"->"+parts[2]);
					channel_user_leave(chan, source);
					channel_user_join(chan, parts[2]);
				}
			}
			if (source == mynick)
				mynick = parts[2];
			//TODO: make this rename queries
		}
		else if (cmd == "PART")
		{
			channel* chan = get_chan_or_null(parts[2]);
			if (!chan) return;
			
			string reason = "";
			if (parts.size() >= 4 && parts[3])
				reason = " ("+parts[3]+")";
			channel_msg_mergeable(*chan, join_imp, at, "\3""5* "+source+" ("+ident+") has left "+parts[2]+reason, "\3""5-"+source);
			channel_user_leave(*chan, source);
			if (source == mynick)
				channel_set_joined(*chan, false);
		}
		else if (cmd == "KICK")
		{
			channel* chan = get_chan_or_null(parts[2]);
			if (!chan) return;
			
			// not mergeable, those things are rare
			channel_msg(*chan, chanbase::imp_status, at, "\3""4* "+source+" has kicked "+parts[3]+" from "+parts[2]+" ("+parts[4]+")");
			channel_user_leave(*chan, parts[3]);
			if (parts[3] == mynick)
				channel_set_joined(*chan, false);
		}
		else if (cmd == "QUIT")
		{
			for (channel& chan : channels.values())
			{
				if (chan.is_query())
					continue;
				if (chan.members.contains(source))
				{
					channel_msg_mergeable(chan, join_imp, at, "\3""5* "+source+" has quit ("+parts[2]+")", "\3""5-"+source);
					channel_user_leave(chan, source);
				}
			}
		}
		else if (cmd == "353")
		{
			//>> :irc.caffie.net 353 Alcaro @ #derp :Alcaro AlcaRobot @ChanServ
			channel* chan = get_chan_or_null(parts[4]);
			if (!chan) return;
			
			for (cstring user : parts[5].csplit(" "))
			{
				while (user && strchr("~&@%+", user[0])) user = user.substr(1, ~0);
				if (user)
				{
					if (!chan->members.contains(user))
						channel_user_join(*chan, user);
				}
			}
		}
		else if (cmd == "366")
		{
			//>> :irc.caffie.net 366 Alcaro #derp :End of /NAMES list.
			//nothing to do here
		}
		else if ((cmd == "375" || cmd == "372" || cmd == "376") && !show_motd)
		{
			// :moon.freenode.net 375 Alcaro :- moon.freenode.net Message of the Day - 
			// :moon.freenode.net 372 Alcaro :- Welcome to moon.freenode.net in Atlanta, GA, US! Thanks to
			// :moon.freenode.net 376 Alcaro :End of /MOTD command.
		}
		else if (cmd == "401" || cmd == "404")
		{
			//>> :orwell.freenode.net 401 Alcaro #dfjghkldfjhgdfhklfhl :No such nick/channel
			//>> :orwell.freenode.net 404 Alcaro #derp :Cannot send to channel
			temp_msg(chanbase::imp_status, at, parts[3]+": "+parts[4]);
		}
		else if (cmd == "PRIVMSG")
		{
			string msg = parts[3];
			
			bool is_action = false;
			if (msg.startswith("\1") && msg.endswith("\1"))
			{
				cstring body = msg.substr(1, ~1);
				cstring word = body.csplit<1>(" ")[0];
				//cstring arg = body.csplit<1>(" ")[1]; // unused, but may make sense for some CTCP handlers
				
				if (word == "ACTION") { is_action = true; goto do_message; }
				
				temp_msg(chanbase::imp_status, at, "* Received a CTCP "+body+" from "+source);
				return;
			}
		do_message: ;
			cstring name = channel::is_query(parts[2]) ? source : parts[2];
			channel& chan = get_channel(name);
			
			bool is_highlight = false;
			
			auto has_word = [&](const string& word)->bool {
					//I'd prefer cstring::iindexof, but creating that requires a memcasemem() function which doesn't make sense.
					const char * wordstart = strcasestr(msg, word);
					return (wordstart && (wordstart == (const char*)msg || !isalpha(wordstart[-1])) &&
					        (!isalpha(wordstart[strlen(word)])));
				};
			for (const string& word : highlights)
			{
				if (has_word(word))
					is_highlight = true;
			}
			if (has_word(mynick))
				is_highlight = true;
			
			const char * hl_start = "";
			const char * hl_end = "";
			chanbase::importance_t imp = chanbase::imp_msg;
			
			if (is_highlight)
			{
				hl_start = "\3""4\2";
				hl_end = "\2";
				imp = chanbase::imp_highlight;
			}
			
			string msg_fmt;
			if (is_action)
				msg_fmt = (cstring)"\3""6"+hl_start+"* "+source+hl_end+" "+msg.substr(strlen("\1ACTION "), ~1);
			else
				msg_fmt = (cstring)hl_start+"<"+source+">"+hl_end+" "+msg;
			channel_msg(chan, imp, at, msg_fmt);
		}
		else if (cmd == "NOTICE")
		{
			if (!channel::is_query(parts[2]))
			{
				channel& chan = get_channel(parts[2]);
				channel_msg(chan, chanbase::imp_status, at, "-"+source+"- "+parts[3]);
			}
			else
			{
				temp_msg(chanbase::imp_status, at, "-"+source+"- "+parts[3]);
			}
		}
		else if (cmd == "MODE" && !channel::is_query(parts[2]))
		{
			channel* chan = get_chan_or_null(parts[2]);
			if (!chan) return;
			string text = "\3""7* "+source+" sets mode "+parts.skip(3).join(" ");
			if (parts.size() == 5 && parts[3] == "+o")
				channel_msg_mergeable(*chan, join_imp, at, text, "\3""7"+parts[4]+parts[3]);
			else
				channel_msg(*chan, join_imp, at, text);
		}
		else
		{
			server_msg(chanbase::imp_status, at, line);
		}
	}
	
	size_t max_line_len(channel& chan, bool is_action)
	{
		size_t meta_size = strlen(":")+mynick.length()+strlen("!")+myident.length()+strlen(" PRIVMSG ")+chan.name.length()+strlen(" :");
		if (is_action)
			meta_size += strlen("\1ACTION")+strlen("\1");
		return 512 - meta_size - strlen("\r\n");
	}
	
private:
	void channel_msg(channel& chan, chanbase::importance_t imp, time_t at, cstring text)
	{
		parent()->channel_msg(chan, imp, at, text);
	}
	void channel_msg_mergeable(channel& chan, chanbase::importance_t imp, time_t at, cstring text, cstring text_short)
	{
		parent()->channel_msg_mergeable(chan, imp, at, text, text_short);
	}
	void temp_msg(chanbase::importance_t imp, time_t at, cstring text)
	{
		parent()->temp_msg(imp, at, text);
	}
	void server_msg(chanbase::importance_t imp, time_t at, cstring text)
	{
		parent()->server_msg(imp, at, text);
	}
	void channel_set_joined(channel& chan, bool joined)
	{
		if (chan.joined != joined)
		{
			if (!joined)
				chan.members.reset();
			chan.joined = joined;
			parent()->channel_set_joined(chan);
		}
	}
	void channel_user_join(channel& chan, cstring name)
	{
		chan.members.append(name);
		parent()->channel_user_join(chan, name);
	}
	void channel_user_leave(channel& chan, cstring name)
	{
		chan.members.remove_matching(name);
		parent()->channel_user_leave(chan, name);
	}
public:
	
	void configure(auto& config)
	{
		join_imp = (config.show_joins ? chanbase::imp_status : chanbase::imp_none);
		show_motd = config.show_motd;
		highlights = config.highlights;
	}
	
	void send(time_t at, cstring line)
	{
		if (line.istartswith("PRIVMSG "))
		{
			array<cstring> parts = line.csplit<2>(" ");
			channel* chan = get_chan_or_null(parts[1]);
			if (!chan) return;
			if (parts[2].startswith(":\1ACTION ") && parts[2].endswith("\1"))
				channel_msg(*chan, chanbase::imp_self, at, "\3""6* "+mynick+" "+parts[2].substr(strlen(":\1ACTION "),~1));
			else
				channel_msg(*chan, chanbase::imp_self, at, "<\3""14"+mynick+"\x0F> "+parts[2].substr(1,~0));
		}
	}
};

// an instantiation of the tracker that does nothing; can be serialized, nothing else
class passive_tracker {
public:
	tracker<passive_tracker> track;
	using channel = tracker<passive_tracker>::channel;
	
	// called by tracker
	void connected(time_t at) {}
	void channel_set_joined(channel& chan) {}
	void channel_msg(channel& chan, chanbase::importance_t imp, time_t at, cstring text) {}
	void channel_msg_mergeable(channel& chan, chanbase::importance_t imp, time_t at, cstring text, cstring text_short) {}
	void server_msg(chanbase::importance_t imp, time_t at, cstring text) {}
	void temp_msg(chanbase::importance_t imp, time_t at, cstring text) {}
	void channel_user_join(channel& chan, cstring name) {}
	void channel_user_leave(channel& chan, cstring name) {}
	
	// called by parent
	void disconnected(time_t at) { track.disconnected(at); }
	void ircline(cstring line, arrayview<cstring> parts, time_t at) { track.ircline(line, parts, at); }
	void ircline(cstring line, time_t at) { track.ircline(line, at); }
	void send(time_t at, cstring line) { track.send(at, line); }
	void serialize(auto& s) { track.serialize(s); }
};

class bouncer_server {
public:
	autopilot<bouncer_server> pilot;
private:
	int uiconnect_sock;
	waiter<void> uiconnect_wait = make_waiter<&bouncer_server::uiconnect_wait, &bouncer_server::uiconnect_ready>();
	
	struct client {
		bouncer_server* parent;
		socketbuf sock;
		waiter<cstring> sock_wait = make_waiter<&client::sock_wait, &client::sock_line>();
		
		void sock_line(cstring line)
		{
			parent->sock_line(this, line);
		}
	};
	refarray<client> clients;
	
	uint64_t last_disconnect = 0;
	
	// bouncer socket protocol:
	// like irc, it's a line based protocol
	// lines from ui to bouncer start with a single byte, telling the type
	// - < - send this to the irc server, usually followed by PRIVMSG
	// - C - configuration, followed by a json blob
	// - P - ping, causes server to respond with a p
	// - p - ping reply
	// - X - ask bouncer to terminate, empty body
	// lines from bouncer to ui also have a type, but there's a unix timestamp (in microseconds, base 16, always 16 digits) before that
	// - > - irc server sent this
	// - < - sent this to irc server (for example PRIVMSG, if bouncer has multiple clients)
	// - S - state, followed by a json blob
	// - c - connection status, has a body; only sent while offline (but may immediately precede a 'now online' > or S)
	// - P - ping, causes client to respond with a p (server never actually sends this, but client supports it)
	// - p - ping reply
	// a bouncer server object can only talk with a single irc server
	// (it's theoretically possible to run multiple bouncer server objects in the same process, but this is unimplemented)
	
	struct history_line {
		uint64_t at2;
		string body; // contains from-bouncer line prefix character, but no timestamps
	};
	passive_tracker track;
	array<history_line> history;
	
public:
	static async<int> connect(cstrnul fname)
	{
		bool can_retry = true;
	bouncer_again:
		
		int fd = socket(PF_UNIX, SOCK_STREAM, 0);
		if (fd < 0)
			_exit(1);
		socket2::set_fd_nonblock(fd);
		struct sockaddr_un addr;
		memset(&addr, 0, sizeof(addr));
		addr.sun_family = AF_UNIX;
		strcpy(addr.sun_path, fname);
		if (::connect(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
		{
			if (can_retry)
			{
if (false) // put bouncer in the same process, as a debug aid
{
bouncer_server* bnc = new bouncer_server(); // intentional memory leak (will also leak a few waiters, so exit() will SIGABRT)
bnc->init_server(fname);
can_retry = false;
goto bouncer_again;
}
				process::params par;
				par.prog = file::exepath();
				par.argv = { par.prog, "--irc-bouncer", fname };
				process::pipe stdout = process::pipe::create();
				par.fds = { -1, 1, 2, stdout.wr };
				par.detach = true;
				
				process().create(par);
				co_await runloop2::await_read(stdout.rd); // don't bother reading it, the pipe's dtor will discard it
				
				can_retry = false;
				goto bouncer_again;
			}
		}
		co_return fd;
	}
	
	void init_server(const char * sock_path)
	{
		unlink(sock_path);
		
		uiconnect_sock = socket(PF_UNIX, SOCK_STREAM, 0);
		if (uiconnect_sock < 0)
			exit(1);
		socket2::set_fd_nonblock(uiconnect_sock);
		struct sockaddr_un addr;
		memset(&addr, 0, sizeof(addr));
		addr.sun_family = AF_UNIX;
		strcpy(addr.sun_path, sock_path);
		int prev_umask = umask(0077); // not thread safe, but this process is single threaded anyways
		if (bind(uiconnect_sock, (struct sockaddr *)&addr, sizeof(addr)))
			exit(1);
		if (listen(uiconnect_sock, 10) < 0)
			exit(1);
		umask(prev_umask);
		// can't use socketlisten, it only works with TCP sockets
		runloop2::await_read(uiconnect_sock).then(&uiconnect_wait);
	}
	
private:
	void uiconnect_ready()
	{
		runloop2::await_read(uiconnect_sock).then(&uiconnect_wait);
		
		int fd = accept(uiconnect_sock, NULL, NULL);
		if (fd < 0) // don't think this is possible, but...
			return;
		socket2::set_fd_nonblock(fd);
		client& cl = clients.append();
		cl.parent = this;
		cl.sock = socket2::create_from_fd(fd);
		cl.sock.line().then(&cl.sock_wait);
	}
	
	void sock_line(client* cl, cstring line)
	{
		if (!line)
		{
			size_t n=0;
			while (&clients[n] != cl)
				n++;
			clients.remove(n);
			if (history)
				last_disconnect = history[history.size()-1].at2;
			else
				last_disconnect = 0;
			return;
		}
		
		cstring body = bytepipe::trim_line(line).substr(1, ~0);
		switch (line[0])
		{
		case '<':
			pilot.send(body);
			send_line("<", body, time(NULL), cl);
			break;
		case 'C':
		{
			if (body)
			{
				jsondeserializer2 s(body);
				pilot.serialize(s);
			}
this->pilot.debug_log("config "+body);
			
			uint64_t a_week_ago = time(NULL)*1000000 - (uint64_t)7*86400*1000000;
			size_t n = 0;
this->pilot.debug_log("begin trim history; size "+tostring(history.size())+", state "+jsonserialize2(this->track));
			while (n < history.size() && history[n].at2 < a_week_ago)
			{
				// todo: put this piece somewhere else
				history_line& line = history[n];
				if (line.body[0] == '>')
				{
					cstring body = line.body.substr(1, ~0);
					this->track.ircline(body, line.at2/1000000);
				}
				n++;
			}
			if (n)
				history = history.skip(n);
this->pilot.debug_log("done trim history; size "+tostring(history.size())+", state "+jsonserialize2(this->track));
			
			uint64_t stop = last_disconnect;
			if (stop && stop < a_week_ago)
			{
				send_line_to(cl, "c", "** Scrollback has been truncated", stop);
			}
			passive_tracker local_track = this->track;
this->pilot.debug_log("copied state "+jsonserialize2(local_track));
			while (n < history.size() && history[n].at2 <= stop)
			{
				history_line& line = history[n];
				if (line.body[0] == '>')
				{
					cstring body = line.body.substr(1, ~0);
					local_track.ircline(body, line.at2/1000000);
				}
				n++;
			}
this->pilot.debug_log("tracked "+tostring(n)+" lines locally, state "+jsonserialize2(local_track));
			send_line_to(cl, "S", jsonserialize2(local_track), 0);
			if (n < history.size())
			{
				while (n < history.size())
				{
					cl->sock.send_buf(tostringhex<16>(history[n].at2), history[n].body, "\r\n");
					n++;
				}
				cl->sock.send_flush();
			}
			
			if (!pilot.active())
				pilot.activate();
			break;
		}
		case 'P':
			send_line_to(cl, "p", "", 0);
			break;
		case 'p':
			// nothing
			break;
		case 'X':
			_exit(0);
		}
		
		cl->sock.line().then(&cl->sock_wait);
	}
	
	void send_line_to(client* target, const char * type, cstring text, cstring at)
	{
		target->sock.send_buf(at, type, text, "\r\n");
		target->sock.send_flush();
	}
	void send_line_to(client* target, const char * type, cstring text, uint64_t at)
	{
		send_line_to(target, type, text, tostringhex<16>(at));
	}
	void send_line(const char * type, cstring text, uint64_t at, client* except = nullptr)
	{
		string at_str = tostringhex<16>(at);
		for (client& cl : clients)
		{
			if (&cl != except)
				send_line_to(&cl, type, text, at_str);
		}
		if (history)
			at = max(at, history[history.size()-1].at2+1);
		history.append({ at, type+text });
	}
	
public:
	void connect_status(cstring text, time_t at)
	{
		send_line("c", text, (uint64_t)at*1000000);
	}
	
	void ircline(cstring line, arrayview<cstring> parts, time_t at)
	{
		// don't save those, waste of space
		if (parts.size() >= 2 && parts[1] == "PONG")
			return;
		send_line(">", line, (uint64_t)at*1000000);
	}
};

template<typename Tparent>
class bouncer_client {
	Tparent* parent()
	{
		return container_of<&Tparent::bouncer>(this);
	}
	
	string sock_filename;
	socketbuf sock;
	waiter<void> sock_wait;
	waiter<void> time_wait = make_waiter<&bouncer_client::time_wait, &bouncer_client::time_ping>();
	bool ping_sent;
	
	async<void> main_recv()
	{
		sock.reset();
		ping_sent = false;
		time_wait.cancel();
		runloop2::in_ms(30000).then(&time_wait);
		
		sock = socket2::create_from_fd(co_await bouncer_server::connect(sock_filename));
		sock.send_buf("C",jsonserialize2(parent()->pilot),"\r\n");
		sock.send_flush();
		
		while (true)
		{
			cstring line = co_await sock.line(8192+512);
			if (!line)
			{
				parent()->connect_status("** Disconnected from bouncer", time(NULL));
				sock = NULL;
				time_wait.cancel();
				runloop2::in_ms(0).then(&time_wait);
				co_return;
			}
			line = bytepipe::trim_line(line);
			
			uint64_t at;
			fromstringhex(line.substr(0, 16), at);
if(at<0xFFFFFFFF)at*=1000000; // TODO: delete this next time bouncer is restarted
			// TODO: pass the exact value somewhere, so client can know which exact point to start from, instead of last_disconnect
			cstring line_body = line.substr(17, ~0);
			switch (line[16])
			{
			case '>':
				parent()->ircline(line_body, autopilot<void>::parseline(line_body), at/1000000);
				break;
			case '<':
				parent()->ircline_sent(line_body, at/1000000);
				break;
			case 'S':
				parent()->load_state(line_body);
				break;
			case 'c':
				parent()->connect_status(line_body, at/1000000);
				break;
			case 'p':
				ping_sent = false;
				break;
			}
		}
	}
	
	void time_ping()
	{
		if (ping_sent || !sock)
		{
			sock_wait.cancel();
			main_recv().then(&sock_wait);
		}
		else
		{
			ping_sent = true;
			sock.send("P\r\n");
			runloop2::in_ms(30000).then(&time_wait);
		}
	}
	
public:
	void activate(cstring sock_filename)
	{
		this->sock_filename = sock_filename;
		main_recv().then(&sock_wait);
	}
	
	void send(cstring line)
	{
		if (!sock)
			return;
		sock.send_buf("<", line, "\r\n");
		sock.send_flush();
	}
	
	void restart_server()
	{
		sock.send("X\r\n");
		sock = NULL;
		
		sock_wait.cancel();
		main_recv().then(&sock_wait);
	}
	
	void deactivate()
	{
		sock.send("X\r\n");
		sock = NULL;
		
		sock_wait.cancel();
		time_wait.cancel();
	}
};

class ui : public protocol {
	autoptr<russian::group> server; // keep this above every russian::channel, destructor order is important
	
	using channel = tracker<ui>::channel;
	
	struct uichan_data {
		string name;
		autoptr<russian::channel> host;
		string recent_joins; // Empty, or " +user1" (with leading space)
	};
	map<string, autoptr<uichan_data>> channel_hosts;
	uichan_data& uichan_for(channel& chan)
	{
		autoptr<uichan_data>& ret = channel_hosts.get_create(chan.name);
		if (!ret)
		{
			ret = new uichan_data;
			uint32_t flags = 0;
			if (chan.is_query()) flags |= chanbase::f_no_users;
			ret->name = chan.name;
			ret->host = server->child(chan.name, flags, (uichan_data*)ret);
		}
		return *ret;
	}
	russian::channel* host_for(channel& chan)
	{
		return uichan_for(chan).host;
	}
	
public:
	autopilot<ui> pilot;
	bouncer_client<ui> bouncer;
	tracker<ui> track;
private:
	bool use_bouncer;
	bool merge_joins;
	
public:
	ui(impl* parent, json5deserializer2& s) : protocol(parent, fmt_b|fmt_k|fmt_o|fmt_i|fmt_u)
	{
		auto ui_config = pilot.serialize(s);
		
		use_bouncer = (ui_config.bouncer);
		
		server = mkgroup(ui_config.root_name, chanbase::f_no_logs|chanbase::f_no_users, nullptr);
		server->set_available(false);
		
		track.configure(ui_config);
		merge_joins = ui_config.merge_joins;
		
		for (auto& chan : ui_config.channels)
			update_host(track.get_channel(chan.name));
		
		if (use_bouncer)
			bouncer.activate(ui_config.bouncer);
		else
			pilot.activate();
	}
	
	void connected(time_t at)
	{
		server->set_available(true);
		for (uichan_data* ch : channel_hosts.values())
		{
			if (channel::is_query(ch->name))
				ch->host->set_available(true);
		}
	}
	void ircline(cstring line, arrayview<cstring> parts, time_t at)
	{
		track.ircline(line, parts, at);
	}
	void ircline_sent(cstring line, time_t at)
	{
		track.send(at, line);
	}
	void load_state(cstring json)
	{
		jsondeserializer2 s(json);
		track.serialize(s);
		for (channel& ch : track.channels.values())
		{
			if (ch.joined && !ch.is_query())
				channel_set_joined(ch);
		}
		if (track.connected)
			connected(0);
		server_msg(chanbase::imp_none, time(NULL), "** Connected to bouncer");
	}
	void connect_status(cstring text, time_t at)
	{
		// some connect status messages are 'connecting' rather than 'disconnected',
		// but they only happen when disconnected, so disconnecting again does nothing
		channel_msg(server, chanbase::imp_status, at, text);
		server->set_available(false);
		for (uichan_data* ch : channel_hosts.values())
		{
			if (ch->host->users_exist())
				ch->host->user_clear();
			ch->host->set_available(false);
		}
		track.disconnected(at);
	}
	void channel_msg(channel& chan, chanbase::importance_t imp, time_t at, cstring text)
	{
		channel_msg(host_for(chan), imp, at, text);
	}
	void channel_msg_mergeable(channel& chan, chanbase::importance_t imp, time_t at, cstring text, cstring text_short)
	{
		channel_msg(host_for(chan), imp, at, text, text_short);
	}
	void server_msg(chanbase::importance_t imp, time_t at, cstring text)
	{
		channel_msg(server, imp, at, text);
	}
	void temp_msg(chanbase::importance_t imp, time_t at, cstring text)
	{
		// just dump em in the server tab
		channel_msg(server, imp, at, text);
	}
	
	void channel_set_joined(channel& chan)
	{
		update_host(chan);
		russian::channel* host = host_for(chan);
		if (host->users_exist())
			host->user_clear();
		if (chan.joined)
		{
			for (cstring name : chan.members)
				host->user_add(name);
		}
	}
	void channel_user_join(channel& chan, cstring name)
	{
		host_for(chan)->user_add(name);
	}
	void channel_user_leave(channel& chan, cstring name)
	{
		host_for(chan)->user_del(name);
	}
	
private:
	void channel_msg(chanbase* chan, int imp, time_t at, cstring text, cstring text_short = "")
	{
		// todo: this is wrong, use imp_no_show instead
		if ((imp & chanbase::imp_color) >= chanbase::imp_msg && chan != server)
			((russian::channel*)chan)->set_hidden(false);
		cstring id = "";
		if (merge_joins && (uichan_data*)chan->userdata)
		{
			uichan_data& ui_chan = *(uichan_data*)chan->userdata;
			if (text_short && !ui_chan.recent_joins)
			{
				id = "merge";
				ui_chan.recent_joins += " "+text_short;
			}
			else if (text_short && ui_chan.recent_joins)
			{
				ui_chan.recent_joins += " "+text_short;
				array<span> spans = { { "* Members:" } };
				parse_irc(spans, span(), ui_chan.recent_joins);
				chan->message_edit_true("merge", at, spans);
				imp |= chanbase::imp_log_only;
			}
			else if (!text_short && !ui_chan.recent_joins)
			{
				// nothing
			}
			else if (!text_short && ui_chan.recent_joins)
			{
				ui_chan.recent_joins = "";
				chan->message_change_id("merge", "");
			}
		}
		array<span> spans;
		parse_irc(spans, span(), text);
		chan->message(id, imp, at, spans);
	}
	
	void update_host(channel& chan)
	{
		host_for(chan)->set_available(chan.joined);
	}
	
	void send(cstring line)
	{
		track.send(time(NULL), line);
		if (use_bouncer)
			bouncer.send(line);
		else
			pilot.send(line);
	}
	
	void action(chanbase& at, cstrnul text_) override
	{
		string text = text_;
		if (text == "/newbouncer")
		{
			if (!use_bouncer)
				return channel_msg(&at, chanbase::imp_scrollback, time(NULL), "* Not using a bouncer");
			bouncer.restart_server();
			return;
		}
		
		if (!track.connected)
		{
			channel_msg(&at, chanbase::imp_scrollback, time(NULL), "* Disconnected, not available");
			return;
		}
		
		bool is_action = false;
		if (text[0]=='/' && text[1] == '/')
			text = text.substr(1, ~0);
		else if (text[0]=='/')
		{
			if (text.startswith("/notice "))
			{
				array<cstring> words = text.csplit<2>(" ");
				channel_msg(&at, chanbase::imp_scrollback, time(NULL), ">"+words[1]+"< "+words[2]);
				
				send("NOTICE "+words[1]+" :"+words[2]);
				return;
			}
			if (text == "/quit" || text.startswith("/quit "))
			{
				if (text.length() > strlen("/quit "))
					send("QUIT :"+text.substr(strlen("/quit "), ~0));
				else
					send("QUIT :Farewell, comrades");
				if (use_bouncer)
					bouncer.deactivate();
				else
					pilot.deactivate();
				channel_msg(&at, chanbase::imp_scrollback, time(NULL), "* Disconnected, will not reconnect");
				return;
			}
			if (text.startswith("/join "))
			{
				auto m = REGEX("/join ([^, ]+)").match(text);
				if (!m) return send(text.substr(1, ~0)); // joining multiple, or with key -> don't focus
				
				cstring name = m[1];
				channel& chan = track.get_channel(name);
				update_host(chan);
				host_for(chan)->set_hidden(false);
				host_for(chan)->focus();
				if (!chan.is_query())
					send(text.substr(1, ~0));
				return;
			}
			if (text == "/hide")
			{
				if (at.userdata == nullptr)
				{
					channel_msg(&at, chanbase::imp_scrollback, time(NULL), "* Can't do that here");
					return;
				}
				russian::channel* ch = (russian::channel*)&at;
				ch->set_hidden(true);
				return;
			}
			if (text.startswith("/me "))
			{
				text = text.substr(4, ~0);
				is_action = true;
				goto do_message;
			}
			
			send(text.substr(1,~0));
			return;
		}
	do_message:
		
		if (at.userdata == nullptr)
		{
			channel_msg(&at, chanbase::imp_scrollback, time(NULL), "* Can't talk in here, try /join #<channel>");
			return;
		}
		
		uichan_data& ui_chan = *(uichan_data*)at.userdata;
		channel& chan = track.get_channel(ui_chan.name);
		if (!chan.joined)
		{
			if (track.connected)
				channel_msg(&at, chanbase::imp_scrollback, time(NULL), "* Join the channel first");
			else
				channel_msg(&at, chanbase::imp_scrollback, time(NULL), "* Disconnected, not available");
			return;
		}
		array<cstring> lines = text.csplit("\n"); // don't parse /commands on non-first lines, so source code can be copypasted
		
		size_t max_len = track.max_line_len(chan, is_action);
		for (cstring line : lines)
		{
			if (line.length() > max_len)
			{
				channel_msg(&at, chanbase::imp_scrollback, time(NULL),
				            "* Line length "+tostring(line.length())+" exceeds limit "+tostring(max_len));
				return;
			}
		}
		
		while (lines && !lines[0]) lines.remove(0);
		while (lines && !lines[lines.size()-1]) lines.remove(lines.size()-1);
		if (!lines)
			channel_msg(&at, chanbase::imp_scrollback, time(NULL), "* Nothing to send");
		for (cstring line : lines)
		{
			if (!line) continue;
			
			if (is_action)
				send("PRIVMSG "+chan.name+" :\1ACTION "+line+"\1");
			else
				send("PRIVMSG "+chan.name+" :"+line);
		}
	}
	
	void begin_private(chanbase& at, cstrnul name) override
	{
		channel& chan = track.get_channel(name);
		update_host(chan);
		host_for(chan)->focus();
	}
	
	void close_chan(chanbase& at) override
	{
		if (at.userdata == nullptr) return;
		
		uichan_data& ui_chan = *(uichan_data*)at.userdata;
		channel& chan = track.get_channel(ui_chan.name);
		if (chan.joined && !chan.is_query())
		{
			channel_msg(ui_chan.host, chanbase::imp_status, time(NULL), "\3""9* You have left "+chan.name);
			send("PART "+chan.name+" :Farewell, comrades");
		}
		channel_hosts.remove(chan.name);
	}
};
}
}
russian::protocol* russian::protocol::create_irc(impl* parent, json5deserializer2& s) { return new irc::ui(parent, s); }

int russian::protocol::irc_childproc(char** argv)
{
	signal(SIGHUP, SIG_IGN);
	
	irc::bouncer_server bnc;
	bnc.init_server(argv[2]);
	
	write(3, "a", 1); // tell parent that the socket is ready
	close(3);
	
	while (true)
		runloop2::step();
	return 0;
}

void parse_irc(array<span>& out, span fmt, cstring text)
{
	static const uint32_t colors[16] = {
		0xcccccc, 0x000000, 0x3535b3, 0x2a8c2a,
		0xd02a2a, 0x6f2828, 0x80267f, 0xdc721d,
		0xd9a641, 0x3dcc3d, 0x195555, 0x27d6c0,
		0x4545e6, 0xda31da, 0x6c6c6c, 0xafafaf,
	};
	
	span next = fmt;
	
	auto finish = [&out, &next]()
	{
		if (!next.text)
			return;
		if (out.size() > 0 && out[out.size()-1].fmt_eq(next))
			out[out.size()-1].text += next.text;
		else
			out.append(next);
		next.text = "";
	};
	
	size_t n=0;
	while (n<text.length())
	{
		if (UNLIKELY(n+8 < text.length() && // this is kinda gnarly code, but I'm not sure how to do it better...
		             text[n+0] == 'h' &&
		             text[n+1] == 't' &&
		             text[n+2] == 't' &&
		             text[n+3] == 'p'))
		{
			if (n != 0 && isalpha(text[n-1])) goto not_link; // use isalpha, not isalnum, so [k]4http:// is a link
			
			size_t linkend = n+4;
			if (text[linkend] == 's') linkend++;
			if (text[linkend++] != ':') goto not_link;
			if (text[linkend++] != '/') goto not_link;
			if (text[linkend++] != '/') goto not_link;
			
			int n_paren = 0;
			size_t bodylen = 0;
			while (linkend < text.length() && (uint8_t)text[linkend] > 32)
			{
				if (text[linkend] == '(') n_paren++;
				if (text[linkend] == ')') n_paren--;
				linkend++;
				bodylen++;
			}
			if (bodylen < 3) goto not_link;
			
			if (strchr(".,:;\"'", text[linkend-1])) linkend--;
			if (text[linkend-1] == '>') linkend--;
			while (n_paren < 0 && text[linkend-1] == ')') { linkend--; n_paren++; }
			
			finish();
			
			next.text = text.substr(n, linkend);
			next.hyperlink = true;
			finish();
			next.hyperlink = false;
			n = linkend;
			
			continue;
		}
		
	not_link: ;
		uint8_t ch = text[n++];
		if (LIKELY(ch >= 32) || ch=='\t' || ch=='\r' || ch=='\n') { next.text += ch; continue; }
		
		finish();
		
		if(0);
		else if (ch == 0x02) next.bold ^= 1;
		else if (ch == 0x11) next.monospace ^= 1;
		else if (ch == 0x1D) next.italics ^= 1;
		else if (ch == 0x1E) next.strike ^= 1;
		else if (ch == 0x1F) next.underline ^= 1;
		else if (ch == 0x0F) next = fmt;
		else if (ch == 0x03)
		{
			if (isdigit(text[n]))
			{
				{
					int col = 0;
					col += text[n++]-'0';
					if (isdigit(text[n])) col = col*10 + text[n++]-'0';
					next.fgcol = colors[col%16];
				}
				
				if (text[n] == ',' && isdigit(text[n+1]))
				{
					n++;
					
					int col = 0;
					col += text[n++]-'0';
					if (isdigit(text[n])) col = col*10 + text[n++]-'0';
					next.fgcol = colors[col%16];
				}
			}
			else { next.fgcol = fmt.fgcol; next.bgcol = fmt.bgcol; }
		}
		else next.text += ch;
	}
	finish();
}
}
