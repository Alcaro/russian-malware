#include "russian.h"

namespace russian { namespace {

class irc : public protocol {
public:
	struct channel : nocopy {
		string name;
		string key;
		bool permanent = false;
		bool joined = false; // always true for queries
		bool is_query;
		
		autoptr<russian::channel> host;
	};
	
	string name; // CaffieNET
	array<string> addresses; // irc.caffie.net:6667
	string proxy;
	size_t addressid = 0;
	
	array<string> nicks;
	size_t nickid;
	string ident;
	string realname;
	
	array<string> highlights;
	
	chanbase::importance_t join_imp;
	
	enum chan_t {
		ch_server = -1,
		ch_rawlog = -2,
	};
	autoptr<group> server; // keep this above 'rawlog' and 'channels', destructor order is important
	autoptr<russian::channel> rawlog;
	file rawlog_ext;
	
	string mynick;
	uintptr_t chan_top_id; // this overflows if you join 2^64 channels. just ... don't do that
	map<uintptr_t, channel> channels;
	map<string, uintptr_t> channel_id;
	
	array<string> onconnect;
	
	DECL_G_TIMER(timer, irc);
	bool pingsent;
	static const uint32_t delay_reconnect = 30000;
	static const uint32_t delay_ping = 90000;
	
	enum { st_nocon, st_nickuser, st_conn } state;
	autoptr<socket> sock;
	bytepipe sockbytes;
	
	//The span array can be nonempty. If so, 'text' will be appended.
	/*private*/ static void msg_fmt(array<span>& out, cstring text)
	{
		static const uint32_t colors[16] = {
			0xcccccc, 0x000000, 0x3535b3, 0x2a8c2a,
			0xd02a2a, 0x6f2828, 0x80267f, 0xdc721d,
			0xd9a641, 0x3dcc3d, 0x195555, 0x27d6c0,
			0x4545e6, 0xda31da, 0x6c6c6c, 0xafafaf,
		};
		
		span next;
		
		size_t n=0;
		while (n<text.length())
		{
			if (UNLIKELY(text[n+0] == 'h' &&
			             text[n+1] == 't' &&
			             text[n+2] == 't' &&
			             text[n+3] == 'p'))
			{
				if (n != 0 && isualpha(text[n-1])) goto not_link;
				
				size_t linkend = n+4;
				if (text[linkend] == 's') linkend++;
				if (text[linkend++] != ':') goto not_link;
				if (text[linkend++] != '/') goto not_link;
				if (text[linkend++] != '/') goto not_link;
				
				int n_paren = 0;
				while ((uint8_t)text[linkend] > 32)
				{
					if (text[linkend] == '(') n_paren++;
					if (text[linkend] == ')') n_paren--;
					linkend++;
				}
				
				if (strchr(".,:;\"'>", text[linkend-1])) linkend--;
				while (n_paren < 0 && text[linkend-1] == ')') { linkend--; n_paren++; }
				
				if (next.text) out.append(next);
				
				next.text = text.substr(n, linkend);
				next.hyperlink = true;
				out.append(next);
				next.hyperlink = false;
				next.text = "";
				n = linkend;
				
				continue;
			}
			
		not_link: ;
			uint8_t ch = text[n++];
			if (LIKELY(ch >= 32)) { next.text += ch; continue; }
			
			out.append(next);
			next.text = "";
			
			if(0);
			else if (ch == 0x02) next.bold ^= 1;
			else if (ch == 0x1D) next.italics ^= 1;
			else if (ch == 0x1F) next.underline ^= 1;
			else if (ch == 0x0F) next = span();
			else if (ch == 0x03)
			{
				if (isdigit(text[n]))
				{
					{
						string colid;
						colid += text[n++];
						if (isdigit(text[n])) colid += text[n++];
						
						uint32_t colnum;
						fromstring(colid, colnum);
						next.fgcol = colors[colnum%16];
					}
					
					if (text[n] == ',' && isdigit(text[n+1]))
					{
						n++;
						
						string colid;
						colid += text[n++];
						if (isdigit(text[n])) colid += text[n++];
						
						uint32_t colnum;
						fromstring(colid, colnum);
						next.bgcol = colors[colnum%16];
					}
				}
				else { next.fgcol = -1; next.bgcol = -1; }
			}
			else next.text += ch;
		}
		out.append(next);
	}
	
	/*private*/ void msg_chan_fmt(chanbase* chan, chanbase::importance_t imp, time_t at, cstring text)
	{
		array<span> spans;
		msg_fmt(spans, text);
		chan->message(imp, at, spans);
	}
	
	/*private*/ void msg_tmp_fmt(chanbase::importance_t imp, time_t at, cstring text)
	{
		array<span> spans;
		msg_fmt(spans, text);
		server->message_temp(imp, at, spans);
	}
	
	/*private*/ void send(cstring line)
	{
		if (rawlog_ext)
			rawlog_ext.write("<< "+line+"\n");
		msg_chan_fmt(rawlog, chanbase::imp_none, time(NULL), "<< "+line);
		sock->send((line+"\r\n").bytes());
	}
	
	channel& chan_or_tmp(cstring name, bool is_query)
	{
		uintptr_t id = channel_id.get_or(name, 0);
		bool create = (id==0);
		if (create)
		{
			id = chan_top_id++;
			channel_id.insert(name, id);
		}
		channel& chan = channels.get_create(id);
		if (create)
		{
			chan.host = server->child(name, is_query ? chanbase::f_no_users : 0, id);
			chan.name = name;
			chan.joined = is_query;
			chan.is_query = is_query;
		}
		return chan;
	}
	
	channel* chan_or_null(cstring name)
	{
		uintptr_t id = channel_id.get_or(name, 0);
		if (id==0) return nullptr;
		return &channels.get(id);
	}
	
	/*private*/ array<cstring> parseline(cstring line)
	{
		array<cstring> parts;
		
		if (line[0]==':')
		{
			array<cstring> tmp = line.csplit<1>(" ");
			parts.append(tmp[0]);
			line = tmp[1];
		}
		else parts.append("");
		
		while (line && line[0]!=':')
		{
			array<cstring> tmp = line.csplit<1>(" ");
			parts.append(tmp[0]);
			if (tmp.size()==1) break;
			line = tmp[1];
		}
		
		if (line) parts.append(line.substr(1, ~0));
		
		return parts;
	}
	
	/*private*/ bool is_channel(cstring name) { return name[0]=='#' || name[0]=='&'; }
	
	/*private*/ void ircline(string line, time_t at)
	{
		if (!line.isutf8())
		{
			string newline;
			for (uint8_t n : line.bytes())
				newline += string::codepoint(n);
			line = newline;
		}
		if (line.contains_nul()) line = line.replace(string::nul(), "\xEF\xBF\xBD");
		if (line.contains("\r")) line = line.replace("\r", "\xEF\xBF\xBD");
		
		if (rawlog_ext)
			rawlog_ext.write(">> "+line+"\n");
		msg_chan_fmt(rawlog, chanbase::imp_none, at, ">> "+line);
		
		array<cstring> parts = parseline(line);
		if (parts.size() < 10)
			parts.resize(10); // to ensure overflows don't do anything too silly
		
		cstring source = (parts[0]               ? parts[0].substr(1, ~0).csplit<1>("!")[0] : "");
		cstring ident  = (parts[0].contains("!") ? parts[0].substr(1, ~0).csplit<1>("!")[1] : "");
		
		cstring cmd = parts[1];
		if (cmd == "PING")
		{
			send("PONG :"+parts[2]);
		}
		else if (cmd == "PONG")
		{
			pingsent = false;
		}
		else if (cmd == "001")
		{
			addressid = 0;
			
			for (cstring s : onconnect) send(s);
			
			if (state == st_nickuser)
			{
				if (this->channels.size() != 0)
				{
					string channels;
					string passchannels;
					string passwords = " ";
					for (channel& chan : this->channels.values())
					{
						if (!chan.permanent) continue;
						cstring name = chan.name;
						cstring pass = chan.key;
						if (pass) { passchannels += ","+name; passwords += ","+pass; }
						else channels += ","+name;
					}
					send("JOIN "+(passchannels+channels).substr(1, ~0)+passwords.substr(1, ~0));
				}
				
				state = st_conn;
			}
			for (channel& chan : channels.values())
			{
				if (chan.is_query)
					chan.joined = true;
			}
			server->set_available(true);
			timer.set_repeat(delay_ping, bind_this(&irc::timer_cb));
		}
		else if (cmd == "433" && state == st_nickuser)
		{
			if (nickid == nicks.size())
				mynick = nicks[0]+tostring<4>(rand()%10000);
			else
				mynick = nicks[nickid++];
			send("NICK "+mynick);
		}
		else if (cmd == "JOIN")
		{
			cstring name = parts[2];
			channel& chan = chan_or_tmp(name, false);
			if (source == mynick)
			{
				chan.host->set_available(true);
				msg_chan_fmt(chan.host, chanbase::imp_status, at, "\3""9** Now talking on "+name);
				chan.joined = true;
			}
			msg_chan_fmt(chan.host, join_imp, at, "\3""9* \2"+source+"\2 ("+ident+") has joined "+name);
			chan.host->user_add(source);
		}
		else if (cmd == "NICK")
		{
			for (channel& chan : channels.values())
			{
				if (chan.is_query)
					continue;
				if (chan.host->user_exists(source))
				{
					msg_chan_fmt(chan.host, join_imp, at, "\3""9* "+source+" is now known as "+parts[2]);
					chan.host->user_del(source);
					chan.host->user_add(parts[2]);
				}
			}
			if (source == mynick) mynick = parts[2];
			//TODO: make this rename queries
		}
		else if (cmd == "PART")
		{
			channel* chan = chan_or_null(parts[2]);
			if (!chan) return;
			
			if (parts.size() >= 4)
				msg_chan_fmt(chan->host, join_imp, at, "\3""5* "+source+" ("+ident+") has left "+parts[2]+" ("+parts[3]+")");
			else
				msg_chan_fmt(chan->host, join_imp, at, "\3""5* "+source+" ("+ident+") has left "+parts[2]);
			chan->host->user_del(source);
			if (source == mynick)
			{
				chan->joined = false;
				chan->host->set_available(false);
				chan->host->user_clear();
			}
		}
		else if (cmd == "KICK")
		{
			channel* chan = chan_or_null(parts[2]);
			if (!chan) return;
			
			msg_chan_fmt(chan->host, chanbase::imp_status, at, "\3""4* "+source+" has kicked "+parts[3]+" from "+parts[2]+" ("+parts[4]+")");
			chan->host->user_del(parts[3]);
			if (parts[3] == mynick)
			{
				chan->joined = false;
				chan->host->set_available(false);
				chan->host->user_clear();
			}
		}
		else if (cmd == "QUIT")
		{
			for (channel& chan : channels.values())
			{
				if (chan.is_query)
					continue;
				if (chan.host->user_exists(source))
				{
					msg_chan_fmt(chan.host, join_imp, at, "\3""5* "+source+" has quit ("+parts[2]+")");
					chan.host->user_del(source);
					if (source == mynick)
					{
						chan.joined = false;
						chan.host->set_available(false);
						chan.host->user_clear();
					}
				}
			}
		}
		else if (cmd == "353")
		{
			//>> :irc.caffie.net 353 Alcaro @ #derp :Alcaro AlcaRobot @ChanServ
			channel* chan = chan_or_null(parts[4]);
			if (!chan) return;
			
			for (cstring user : parts[5].csplit(" "))
			{
				while (user && strchr("~&@%+", user[0])) user = user.substr(1, ~0);
				if (user) chan->host->user_add(user);
			}
		}
		else if (cmd == "366")
		{
			//>> :irc.caffie.net 366 Alcaro #derp :End of /NAMES list.
			//just ignore it
		}
		else if (cmd == "401" || cmd == "404")
		{
			//>> :orwell.freenode.net 401 Alcaro #dfjghkldfjhgdfhklfhl :No such nick/channel
			//>> :orwell.freenode.net 404 Alcaro #derp :Cannot send to channel
			msg_tmp_fmt(chanbase::imp_status, at, parts[3]+": "+parts[4]);
		}
		else if (cmd == "PRIVMSG")
		{
			string msg = parts[3];
			
			bool is_action = false;
			if (msg.startswith("\1") && msg.endswith("\1"))
			{
				cstring body = msg.substr(1, ~1);
				cstring word = body.csplit<1>(" ")[0];
				//cstring arg = body.csplit<1>(" ")[1]; // unused, but may make sense for some CTCP handlers
				
				if (word == "ACTION") { is_action = true; goto do_message; }
				
				msg_tmp_fmt(chanbase::imp_status, at, "* Received a CTCP "+body+" from "+source);
				
				if (word == "VERSION")
					send("NOTICE "+source+" :\1VERSION " APPNAME " https://github.com/Alcaro/russian-malware\1");
				else if (word == "PING")
					send("NOTICE "+source+" :\1"+body+"\1");
				else
					send("NOTICE "+source+" :\1ERRMSG Unknown CTCP command.\1");
				return;
			}
		do_message: ;
			cstring name = is_channel(parts[2]) ? parts[2] : source;
			channel& chan = chan_or_tmp(name, !is_channel(parts[2]));
			
			if (is_action)
			{
				msg_chan_fmt(chan.host, chanbase::imp_msg, at, "\3""6* "+source+" "+msg.substr(strlen("\1ACTION "), ~1));
				return;
			}
			
			bool is_highlight = false;
			
			auto has_word = [&](const string& word)->bool {
					//I'd prefer cstring::iindexof, but creating that requires a memcasemem() function which doesn't make sense.
					const char * wordstart = strcasestr(msg, word);
					return (wordstart && (wordstart == (const char*)msg || !isualnum(wordstart[-1])) &&
					        (!isualnum(wordstart[strlen(word)])));
				};
			for (const string& word : highlights)
			{
				if (has_word(word))
					is_highlight = true;
			}
			if (has_word(mynick))
				is_highlight = true;
			
			if (is_highlight)
				msg_chan_fmt(chan.host, chanbase::imp_highlight, at, "\2\3""4<"+source+">\2 "+msg);
			else
				msg_chan_fmt(chan.host, chanbase::imp_msg, at, "<"+source+"> "+msg);
		}
		else if (cmd == "NOTICE")
		{
			if (is_channel(parts[2]))
			{
				channel& chan = chan_or_tmp(parts[2], false);
				msg_chan_fmt(chan.host, chanbase::imp_status, at, "-"+source+"- "+parts[3]);
			}
			else
			{
				msg_tmp_fmt(chanbase::imp_status, at, "-"+source+"- "+parts[3]);
			}
		}
		else
		{
			msg_chan_fmt(server, chanbase::imp_status, at, line);
		}
	}
	
	/*private*/ void activity()
	{
		byte tmp[4096];
		int n = sock->recv(tmp);
		if (n<0)
		{
			msg_chan_fmt(server, chanbase::imp_status, time(NULL), "** Connection broken, reconnecting in "+tostring(delay_reconnect)+"ms");
			connect(delay_reconnect);
			return;
		}
		sockbytes.push(arrayview<byte>(tmp, n));
		
		while (true)
		{
			arrayview<byte> lineb = sockbytes.pull_line();
			if (!lineb) break;
			string line(sockbytes.trim_line(lineb));
			sockbytes.pull_done(lineb);
			
			ircline(std::move(line), time(NULL));
		}
	}
	
	/*private*/ void disconnect(time_t at)
	{
		server->set_available(false);
		for (channel& chan : channels.values())
		{
			chan.host->set_available(false);
			if (chan.joined && !chan.is_query)
			{
				chan.host->user_clear();
				msg_chan_fmt(chan.host, chanbase::imp_status, at, "\3""5** Disconnected");
				chan.joined = false;
			}
		}
	}
	
	/*private*/ void connect(int delay = 0)
	{
		disconnect(time(NULL));
		runloop* loop = runloop::global();
		
		if (delay != 0)
		{
			sock = NULL;
			state = st_nocon;
			timer.set_repeat(delay, bind_this(&irc::timer_cb));
			
			return;
		}
		
		state = st_nickuser;
		pingsent = false;
		
		msg_chan_fmt(server, chanbase::imp_status, time(NULL), "** Connecting to "+addresses[addressid]);
		
		//TODO: can't put an ipv6 address here
		//why did they choose :, rather than + or ' or ANYTHING else that's not likely to be near the address
		//: is the worst choice possible except / and alphanumerics
		
		array<cstring> parts = addresses[addressid].csplit<1>(":");
		if (parts.size() == 1) parts.append("6667");
		bool ssl = (parts[1][0]=='+');
		bool ssl_perm = (ssl && parts[1][1]=='-');
		cstring domain = parts[0];
		uint16_t port;
		if (!fromstring(parts[1].substr(ssl+ssl_perm, ~0), port)) port = 0;
		
		socket* tmp_sock;
		if (proxy)
		{
			socks5 proxy_obj;
			proxy_obj.configure(proxy, loop);
			tmp_sock = proxy_obj.connect(false, domain, port, loop);
		}
		else
		{
			tmp_sock = socket::create(domain, port, loop);
		}
		
		if (ssl_perm) sock = socket::wrap(socket::wrap_ssl_raw_noverify(tmp_sock, loop), loop);
		else if (ssl) sock = socket::wrap_ssl(tmp_sock, domain, loop);
		else sock = tmp_sock;
		
		addressid = (addressid+1) % addresses.size();
		
		sock->callback(bind_this(&irc::activity));
		nickid = 0;
		mynick = nicks[nickid++];
		send("NICK "+mynick);
		send("USER "+ident+" a a :"+realname);
		
		timer.set_repeat(delay_reconnect, bind_this(&irc::timer_cb));
	}
	
	/*private*/ void timer_cb()
	{
		if (state == st_nocon)
		{
			connect();
		}
		else if (state == st_conn && !pingsent)
		{
			pingsent = true;
			send("PING :1");
		}
		else
		{
			msg_chan_fmt(server, chanbase::imp_status, time(NULL), "** Connection timed out, reconnecting in "+tostring(delay_reconnect)+"ms");
			connect(delay_reconnect);
		}
	}
	
	irc(impl* parent, bmldeserializer& s) : protocol(parent, fmt_b|fmt_k|fmt_o|fmt_i|fmt_u)
	{
		name = s.nextval();
		chan_top_id = 1;
		
		server = mkgroup(name, chanbase::f_no_logs|chanbase::f_no_users, ch_server);
		server->set_available(false);
		
		rawlog = server->child("<raw>", chanbase::f_no_logs|chanbase::f_no_users, ch_rawlog);
		rawlog->set_hidden(true);
		rawlog->sort_as(1, "");
		
		bool joins = true;
		string rawlog_fname;
		ser_enter(s)
		{
			s.item("address", addresses);
			s.item("socks5", proxy);
			s.item("nick", nicks);
			s.item("ident", ident);
			s.item("realname", realname);
			s.item("highlight", highlights);
			s.item("onconnect", onconnect);
			s.item("joins", joins);
			s.item("rawlog", rawlog_fname);
			
			while (s.next() == "channel")
			{
				string name = s.nextval();
				channel& chan = chan_or_tmp(name, !is_channel(name));
				chan.host->set_available(false);
				chan.permanent = true;
				ser_enter(s)
				{
					s.item("key", chan.key);
				}
			}
		}
		join_imp = (joins ? chanbase::imp_status : chanbase::imp_none);
		
		if (rawlog_fname)
			rawlog_ext.open(file::resolve(file::exepath(), rawlog_fname), file::m_replace);
		
		state = st_nocon;
		connect();
	}
	
	void action(cstring text_, uintptr_t userdata) override
	{
		string text = text_;
		if (text == "/rawlog")
		{
			rawlog->set_hidden(false);
			rawlog->focus();
			return;
		}
		if (text.startswith("/1w "))
			text = "/ar timedo 1w "+text.substr(4,~0); // TODO: this is absolute bullshit
		if (text.startswith("/ar "))
			text = "/notice alcarobot !ar "+text.substr(4,~0);
		
		if (!sock)
		{
			msg_tmp_fmt(chanbase::imp_status, time(NULL), "Disconnected, not available");
			return;
		}
		
		bool is_action = false;
		if (text[0]=='/')
		{
			if (text.startswith("/notice "))
			{
				array<cstring> words = text.csplit<2>(" ");
				msg_tmp_fmt(chanbase::imp_status, time(NULL), ">"+words[1]+"< "+words[2]);
				
				send("NOTICE "+words[1]+" :"+words[2]);
				return;
			}
			if (text.startswith("/me "))
			{
				text = text.substr(4, ~0);
				is_action = true;
				goto do_message;
			}
			
			send(text.substr(1,~0));
			return;
		}
	do_message:
		
		intptr_t id = (intptr_t)userdata;
		if (id == ch_rawlog)
		{
			send(text);
			return;
		}
		if (id == ch_server)
		{
			msg_tmp_fmt(chanbase::imp_status, time(NULL), "Can't talk in here, try /join #<channel>");
			return;
		}
		
		channel& chan = channels.get(id);
		if (!chan.joined)
		{
			if (state != st_conn)
				msg_tmp_fmt(chanbase::imp_status, time(NULL), "Disconnected, not available");
			else
				msg_tmp_fmt(chanbase::imp_status, time(NULL), "Rejoin the channel first");
			return;
		}
		array<cstring> lines = text.csplit("\n"); // don't parse /commands on non-first lines, so source code can be copypasted
		while (lines && !lines[0]) lines.remove(0);
		while (lines && !lines[lines.size()-1]) lines.remove(lines.size()-1);
		if (!lines)
			msg_tmp_fmt(chanbase::imp_status, time(NULL), "Nothing to send");
		for (cstring line : lines)
		{
			if (!line) line = " ";
			
			if (is_action)
			{
				send("PRIVMSG "+chan.name+" :\1ACTION "+line+"\1");
				msg_chan_fmt(chan.host, chanbase::imp_none, time(NULL), "\3""6* "+mynick+" "+line);
			}
			else
			{
				send("PRIVMSG "+chan.name+" :"+line);
				msg_chan_fmt(chan.host, chanbase::imp_none, time(NULL), "<\3""14"+mynick+"\x0F> "+line);
			}
		}
	}
	
	void begin_private(cstring name) override
	{
		channel& chan = chan_or_tmp(name, true);
		chan.host->focus();
	}
	
	void close_chan(uintptr_t userdata) override
	{
		intptr_t id = (intptr_t)userdata;
		if (id == ch_rawlog)
		{
			rawlog->set_hidden(true);
			return;
		}
		if (id == ch_server) return;
		
		channel& chan = channels.get(id);
		if (chan.joined && is_channel(chan.name))
		{
			msg_chan_fmt(chan.host, chanbase::imp_status, time(NULL), "\3""9* You have left "+name);
			send("PART "+chan.name+" :Farewell, comrades");
		}
		channel_id.remove(chan.name);
		channels.remove(id);
	}
	
	~irc()
	{
		disconnect(time(NULL));
		
		//this one sometimes doesn't work, not sure why
		//can't fix without inhibiting process shutdown for a second, which I'd rather not
		if (sock) send("QUIT :Farewell, comrades");
	}
};
}
russian::protocol* russian::protocol::create_irc(impl* parent, bmldeserializer& s) { return new irc(parent, s); }
}
