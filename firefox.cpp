#include "firefox.h"

// having sqlite disabled is entirely untested and probably broken
#ifndef NO_SQLITE3
#include <sqlite3.h>
#endif

namespace russian {

// This function assumes input is well formed, and makes no attempt to reject truncated, oversized, or otherwise malformed input.
static bytearray snappy_decompress(bytesr by)
{
	const uint8_t * in = by.ptr();
	const uint8_t * end = in + by.size();
	uint32_t len = *in++;
	if (len & 1<<7)
		len = (len&~(1<<7)) | (*in++)<<7;
	if (len & 1<<14)
		len = (len&~(1<<14)) | (*in++)<<14;
	if (len & 1<<21)
		len = (len&~(1<<21)) | (*in++)<<21;
	if (len & 1<<28)
		len = (len&~(1<<28)) | (*in++)<<28;
	bytearray ret;
	ret.resize(len);
	uint8_t * out = ret.ptr();
	while (in < end)
	{
		uint8_t head = *in++;
		uint32_t len = (head>>2)+1;
		if ((head&3) == 0)
		{
			if (len > 60)
			{
				uint32_t len_orig = len;
				// even on not-malformed inputs, this will read a few bytes out of range if someone uses an overlong encoding
				len = (readu_le32(in) & (0xFFFFFFFF >> ((64-len_orig)*8))) + 1;
				in += (len_orig-60);
			}
			memcpy(out, in, len);
			out += len;
			in += len;
		}
		else
		{
			uint32_t offset;
			if ((head&3) == 1)
			{
				len = ((head>>2)&7) + 4;
				offset = (head&0xE0)<<3 | *in++;
			}
			else if ((head&3) == 2)
			{
				offset = readu_le16(in);
				in += 2;
			}
			else
			{
				offset = readu_le32(in);
				in += 4;
			}
			const uint8_t * tmp = out-offset;
			rep_movsb(out, tmp, len);
		}
	}
	return ret;
}


// this thing can be found in IndexedDB (SELECT data FROM object_data), after Snappy decompression
// no clue what else is in the IndexedDB sqlites, most of it looks like random garbage (base85 encoded sha256 of something, I guess)
// nor do I know what, if anything, this format is called
// I suspect it isn't actually json, but some superset thereof; there are plenty of holes in the types enum, and arrays have key fields
// but all IndexedDBs I've seen contain only json-compatible data, so I'll keep it like this for now
// there are no overflow checks in this function, invalid inputs are likely to segfault or otherwise misbehave
enum idb_t {
	idb_null = 0xFFFF0000,
	idb_null2 = 0xFFFF0001,
	idb_bool = 0xFFFF0002,
	idb_int32 = 0xFFFF0003,
	idb_string = 0xFFFF0004,
	idb_array = 0xFFFF0007,
	idb_dict = 0xFFFF0008,
	idb_end = 0xFFFF0013,
};

static string string_from_indexeddb(uint32_t meta, bytestream& by)
{
	bool utf16 = !(meta & 0x80000000);
	uint32_t len = (meta & 0x7FFFFFFF);
	string ret;
	if (utf16)
		ret = smelly_string::utf16l_to_utf8(by.bytes(len*2));
	else
		ret = smelly_string::ucs1_to_utf8(by.bytes(len));
	by.bytes((-by.tell())%8); // alignment
	return ret;
}

static bool from_indexeddb_recurse(JSONw& out, bytestream& by)
{
	uint64_t val = by.u64l();
	if ((val & 0x7FFFFFFF'FFFFFFFF) <= 0x7FF00000'00000001) // these last two values are inf and nan
	{
		out = reinterpret<double>(val);
		return true;
	}
	
	uint32_t meta = val;
	uint32_t type = val >> 32;
	
	switch (type)
	{
	case idb_null:
		out = nullptr;
		break;
	case idb_null2:
		// not sure what this is... maybe one of the nulls is null, and the other is undefined?
		out = nullptr;
		break;
	case idb_bool:
		out = (bool)meta;
		break;
	case idb_int32:
		if (meta >= 0x80000000) // todo: check if it's signed or unsigned
			return false;
		out = (int32_t)meta;
		break;
	case idb_string:
		out = string_from_indexeddb(meta, by);
		break;
	case idb_array:
		out.list().resize(meta);
		for (size_t n=0;n<meta;n++)
		{
			if (by.u32l() != n || by.u32l() != idb_int32)
				return false;
			if (!from_indexeddb_recurse(out[n], by))
				return false;
		}
		if (by.u32l() != 0 || by.u32l() != idb_end)
			return false;
		break;
	case idb_dict:
		if (meta != 0)
			return false;
		out.assoc(); // make it {} if empty, not null
		while (true)
		{
			// this feels wrong-endian, but it's hard to design a better format without making doubles middle endian or everything big endian
			uint32_t meta = by.u32l();
			uint32_t type = by.u32l();
			if (type == idb_string)
			{
				JSONw& val = out[string_from_indexeddb(meta, by)];
				if (!from_indexeddb_recurse(val, by))
					return false;
			}
			else if (type == idb_end && meta == 0)
				break;
			else
				return false;
		}
		break;
	default:
		return false;
	}
	return true;
}

static MAYBE_UNUSED JSONw from_indexeddb(bytearray bytes)
{
	bytestream by = bytes;
	if (by.u64l() != 0xFFF10000'00000003)
		return {};
	JSONw ret;
	if (!from_indexeddb_recurse(ret, by))
		return {};
	if (by.remaining() != 0)
		return {};
	return ret;
}


firefox_profile firefox_profile::get_default()
{
	for (cstring dirname : file::listdir((string)getenv("HOME")+"/.mozilla/firefox/"))
	{
		if (dirname.endswith(".default/"))
			return { dirname };
	}
	return { "" };
}

array<firefox_profile> firefox_profile::get_all()
{
	array<firefox_profile> ret;
	for (cstring dirname : file::listdir((string)getenv("HOME")+"/.mozilla/firefox/"))
	{
		if (dirname.endswith("/"))
			ret.append({ dirname });
	}
	return ret;
}

#ifndef NO_SQLITE3
sqlite3* firefox_profile::open_db(cstring name)
{
	sqlite3* db;
	//Firefox holds some kind of lock on some sqlite databases while running. I must unlock,
	//  disable, or bypass this lock somehow, or I can't open the db.
	//The chosen mechanism is claiming immutability; it's a lie, but the alternatives are
	//- demanding Firefox to be not running
	//    this program has no right to dictate the user's workflow
	//- demanding Firefox <= 62 (it only started holding permanent locks in 63)
	//    insecure
	//- copying the database file somewhere
	//    waste of megabytes, and likely to leak or fail if the program crashes or runs concurrently
	//- a custom VFS that ignores locking
	//    yields nasty spaghetticode with many special cases, where bad or incomplete implementations would likely write to the file
	//    (even with SQLITE_OPEN_READONLY, it still writes a bit)
	//so this is the least bad method
	if (sqlite3_open_v2("file:"+dirname+name+"?immutable=1", &db,
	                    SQLITE_OPEN_URI|SQLITE_OPEN_READONLY, NULL) != SQLITE_OK)
	{
		sqlite3_close(db);
		return nullptr;
	}
	return db;
}

static void bind_param(sqlite3_stmt* stmt, int idx, const cstring& value)
{
	sqlite3_bind_text(stmt, idx, (char*)value.bytes().ptr(), value.length(), SQLITE_STATIC);
}

template<typename... Ts>
sqlite3_stmt* create_query(sqlite3* db, const char * query, const Ts&... args)
{
	sqlite3_stmt* stmt;
	sqlite3_prepare_v2(db, query, strlen(query)+1, &stmt, NULL);
	int param_id = 0;
	(bind_param(stmt, ++param_id, args), ...);
	return stmt;
}
#endif

string firefox_profile::get_cookie(cstring domain, cstring name)
{
	string ret;
	
#ifndef NO_SQLITE3
	sqlite3* db = open_db("cookies.sqlite");
	if (!db) return "";
	
	sqlite3_stmt* stmt = create_query(db, "SELECT value FROM moz_cookies WHERE host=? AND name=?", domain, name);
	if (sqlite3_step(stmt) == SQLITE_ROW)
		ret = http_t::urldecode((char*)sqlite3_column_text(stmt, 0));
	sqlite3_finalize(stmt);
	
	sqlite3_close(db);
#endif
	
	return ret;
}

#ifndef NO_SQLITE3
static string get_localstorage_row(sqlite3_stmt* stmt)
{
	bytesr value = { (uint8_t*)sqlite3_column_blob(stmt, 2), (size_t)sqlite3_column_bytes(stmt, 2) };
	
	bytearray ret;
	
	int compression_type = sqlite3_column_int(stmt, 0);
	if (compression_type == 0)
		ret = value;
	else if (compression_type == 1)
		ret = snappy_decompress(value);
	else
		return {}; // unknown compression
	
	int conversion_type = sqlite3_column_int(stmt, 1);
	if (conversion_type == 0)
		return smelly_string::utf16l_to_utf8(ret);
	else if (conversion_type == 1)
		return ret; // parts of firefox use ucs1, parts use utf8; this one is utf8
	else
		return {}; // unknown conversion
}
#endif

void firefox_profile::get_localstorage_inner(cstring domain, arrayview<cstring> keys, arrayvieww<string> values)
{
#ifndef NO_SQLITE3
	sqlite3* db = open_db("storage/default/https+++"+domain+"/ls/data.sqlite");
	if (!db) return;
	
	sqlite3_stmt* stmt = create_query(db, "SELECT compression_type, conversion_type, value FROM data WHERE key=?");
	for (size_t n : range(keys.size()))
	{
		bind_param(stmt, 1, keys[n]);
		if (sqlite3_step(stmt) == SQLITE_ROW)
		{
			values[n] = get_localstorage_row(stmt);
		}
		sqlite3_reset(stmt);
	}
	sqlite3_finalize(stmt);
	
	sqlite3_close(db);
#endif
}

}
