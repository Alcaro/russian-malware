#include "firefox.h"

// having sqlite disabled is entirely untested and probably bitrotted
#ifndef NO_SQLITE3
#include <sqlite3.h>
#endif

namespace russian {

firefox_profile firefox_profile::get_default()
{
	for (cstring dirname : file::listdir((string)getenv("HOME")+"/.mozilla/firefox/"))
	{
		if (dirname.endswith(".default/"))
			return { dirname };
	}
	return { "" };
}

array<firefox_profile> firefox_profile::get_all()
{
	array<firefox_profile> ret;
	for (cstring dirname : file::listdir((string)getenv("HOME")+"/.mozilla/firefox/"))
	{
		if (dirname.endswith("/"))
			ret.append({ dirname });
	}
	return ret;
}

#ifndef NO_SQLITE3
sqlite3* firefox_profile::open_db(cstring name)
{
	sqlite3* db;
	//Firefox holds some kind of lock on this file while running. I must unlock, disable, or
	//  bypass this lock somehow, or I can't open the db.
	//The chosen mechanism is claiming immutability; it's a lie, but the alternatives are
	//- demanding Firefox to be not running
	//    this program has no right to dictate the user's workflow
	//- demanding Firefox <= 62 (it only started holding permanent locks in 63)
	//    insecure
	//- copying the database file somewhere
	//    waste of megabytes, and likely to leak or fail if the program crashes or runs concurrently
	//- a custom VFS that ignores locking
	//    yields nasty spaghetticode with many special cases, where bad or incomplete implementations would likely write to the file
	//    (even with SQLITE_OPEN_READONLY, it still writes a bit)
	//so this is the least bad method
	if (sqlite3_open_v2("file:"+dirname+name+"?immutable=1", &db,
	                    SQLITE_OPEN_URI|SQLITE_OPEN_READONLY, NULL) != SQLITE_OK)
	{
		sqlite3_close(db);
		return nullptr;
	}
	return db;
}

static void bind_param(sqlite3_stmt* stmt, int idx, const cstring& value)
{
	sqlite3_bind_text(stmt, idx, (char*)value.bytes().ptr(), value.length(), SQLITE_STATIC);
}

template<typename... Ts>
sqlite3_stmt* create_query(sqlite3* db, const char * query, const Ts&... args)
{
	sqlite3_stmt* stmt;
	sqlite3_prepare_v2(db, query, strlen(query)+1, &stmt, NULL);
	int param_id = 0;
	(bind_param(stmt, ++param_id, args), ...);
	return stmt;
}
#endif

string firefox_profile::get_cookie(cstring domain, cstring name)
{
	string ret;
	
#ifndef NO_SQLITE3
	sqlite3* db = open_db("cookies.sqlite");
	if (!db) return "";
	
	sqlite3_stmt* stmt = create_query(db, "SELECT value FROM moz_cookies WHERE host=? AND name=?", domain, name);
	if (sqlite3_step(stmt) == SQLITE_ROW)
		ret = http_t::urldecode((char*)sqlite3_column_text(stmt, 0));
	sqlite3_finalize(stmt);
	
	sqlite3_close(db);
#endif
	
	return ret;
}

// This function assumes input is well formed, and makes no attempt to reject truncated, oversized, or otherwise malformed input.
static bytearray snappy_decompress(bytesr by)
{
	const uint8_t * in = by.ptr();
	const uint8_t * end = in + by.size();
	uint32_t len = *in++;
	if (len & 1<<7)
		len = (len&~(1<<7)) | (*in++)<<7;
	if (len & 1<<14)
		len = (len&~(1<<14)) | (*in++)<<14;
	if (len & 1<<21)
		len = (len&~(1<<21)) | (*in++)<<21;
	if (len & 1<<28)
		len = (len&~(1<<28)) | (*in++)<<28;
	bytearray ret;
	ret.resize(len);
	uint8_t * out = ret.ptr();
	while (in < end)
	{
		uint8_t head = *in++;
		uint32_t len = (head>>2)+1;
		if ((head&3) == 0)
		{
			if (len >= 60)
			{
				uint32_t len_orig = len;
				len = (readu_le32(in) & (0xFFFFFFFF >> ((64-len_orig)*8))) + 1;
				in += (len_orig-60);
			}
			memcpy(out, in, len);
			out += len;
			in += len;
		}
		else
		{
			uint32_t offset;
			if ((head&3) == 1)
			{
				len = ((head>>2)&7) + 4;
				offset = (head&0xE0)<<3 | *in++;
			}
			else if ((head&3) == 2)
			{
				offset = readu_le16(in);
				in += 2;
			}
			else
			{
				offset = readu_le32(in);
				in += 4;
			}
			const uint8_t * tmp = out-offset;
			rep_movsb(out, tmp, len);
		}
	}
	return ret;
}

static string get_localstorage_row(sqlite3_stmt* stmt)
{
	bytesr value = { (uint8_t*)sqlite3_column_blob(stmt, 2), (size_t)sqlite3_column_bytes(stmt, 2) };
	
	bytearray ret;
	
	int compression_type = sqlite3_column_int(stmt, 0);
	if (compression_type == 0)
		ret = value;
	else if (compression_type == 1)
		ret = snappy_decompress(value);
	else
		return {}; // unknown compression
	
	int conversion_type = sqlite3_column_int(stmt, 1);
	if (conversion_type == 0)
		return {}; // it's utf16, not utf8; ignore that for now
	else if (conversion_type == 1)
		return ret;
	else
		return {}; // unknown conversion
}

void firefox_profile::get_localstorage_inner(cstring domain, arrayview<cstring> keys, arrayvieww<string> values)
{
#ifndef NO_SQLITE3
	sqlite3* db = open_db("storage/default/https+++"+domain+"/ls/data.sqlite");
	if (!db) return;
	
	sqlite3_stmt* stmt = create_query(db, "SELECT compression_type, conversion_type, value FROM data WHERE key=?");
	for (size_t n : range(keys.size()))
	{
		bind_param(stmt, 1, keys[n]);
		if (sqlite3_step(stmt) == SQLITE_ROW)
		{
			values[n] = get_localstorage_row(stmt);
		}
		sqlite3_reset(stmt);
	}
	sqlite3_finalize(stmt);
	
	sqlite3_close(db);
#endif
}

}
