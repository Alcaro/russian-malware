// gtk4 annoyances:
// - the xi2 scroll bullshit; quite possibly the ugliest lamehack I've ever written in software not fundamentally designed for shenanigans
// - a large collection of warnings about broken active state accounting and whatever; some of it is easy to reproduce, some isn't
// - context menues were redesigned and are inconsistent with every other program on the machine
// - all the deprecations and replacements and pointless busywork

// but the showstopper is repeated (but not reliably reproducible) segfaults with signature
/*
#0  __strcmp_avx2 () at ../sysdeps/x86_64/multiarch/strcmp-avx2.S:105
#1  0x00007ffff715d19d in g_str_equal ()
    at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff794193b in  () at /lib/x86_64-linux-gnu/libgtk-4.so.1       gdk_x11_clipboard_request_targets_got_stream
#3  0x00007ffff7363749 in  () at /lib/x86_64-linux-gnu/libgio-2.0.so.0
#4  0x00007ffff736394b in  () at /lib/x86_64-linux-gnu/libgio-2.0.so.0     g_task_return_pointer
#5  0x00007ffff7949805 in  () at /lib/x86_64-linux-gnu/libgtk-4.so.1       gdk_x11_selection_input_stream_xevent
#6  0x00007ffff78e0067 in  () at /lib/x86_64-linux-gnu/libgtk-4.so.1       _gdk_marshal_BOOLEAN__POINTER
#7  0x00007ffff726ec0f in g_closure_invoke ()
    at /lib/x86_64-linux-gnu/libgobject-2.0.so.0
#8  0x00007ffff728aea6 in  () at /lib/x86_64-linux-gnu/libgobject-2.0.so.0
#9  0x00007ffff728c296 in g_signal_emit_valist ()
    at /lib/x86_64-linux-gnu/libgobject-2.0.so.0
#10 0x00007ffff728ccfe in g_signal_emit_by_name ()
    at /lib/x86_64-linux-gnu/libgobject-2.0.so.0
#11 0x00007ffff7944bf2 in  () at /lib/x86_64-linux-gnu/libgtk-4.so.1       _gdk_x11_display_queue_events
#12 0x00007ffff78f0919 in  () at /lib/x86_64-linux-gnu/libgtk-4.so.1
#13 0x00007ffff794a67e in  () at /lib/x86_64-linux-gnu/libgtk-4.so.1
#14 0x00007ffff717a8bb in g_main_context_dispatch ()
    at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#15 0x00007ffff71cdf08 in  () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#16 0x00007ffff7178003 in g_main_context_iteration ()
    at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#17 0x0000555555582f1b in (anonymous namespace)::runloop_gtk::enter()
    (this=0x555555b63a00) at arlib/gui/gtk3-misc.cpp:719
#18 0x00005555556696d7 in russian::impl::execute(string)
    (this=0x7fffffffde10, cfgpath=...) at main.cpp:561
#19 0x0000555555666a11 in main(int, char**) (argc=1, argv=0x7fffffffdff8)
    at main.cpp:1225

(some symbol names determined via reading assembly and comparing to source code)

the exact faulting location is type being NULL in
  else if (!g_str_equal (type, "ATOM") || format != 32)
*/
// I also saw an X protocol error, but wasn't able to reproduce that either

#include "russian.h"
#include "obj/resources.h"
#include <sys/resource.h>
#include <sys/file.h>
#include <gtk/gtk.h>

#if defined(ARLIB_GUI_GTK3)
#define GDK_ALT_MASK GDK_MOD1_MASK
#elif defined(ARLIB_GUI_GTK4)
#include <X11/extensions/XInput2.h>
#include <gdk/x11/gdkx.h>
#else
#error gtk only
#endif

#ifdef ARLIB_GUI_GTK4
static void fix_xi2_because_gtk_refuses_to(GtkWindow* wnd)
{
	// if you want to see their pathetic excuses, https://gitlab.gnome.org/GNOME/gtk/-/issues/558
	
	static int xi_opcode;
	static auto query_wheel = [](GdkSurface* surf)
	{
		GdkDisplay* disp = gdk_surface_get_display(surf);
		Display* xdisp = gdk_x11_display_get_xdisplay(disp);
		
		int firstevent, firsterror;
		if (!xi_opcode)
			XQueryExtension(xdisp, "XInputExtension", &xi_opcode, &firstevent, &firsterror); // Gtk already demands this exists
		
		int n_dev;
		XIDeviceInfo* info = XIQueryDevice(xdisp, XIAllDevices, &n_dev);
		
		for (int i=0;i<n_dev;i++)
		{
			uint8_t mask[4]; // the wire protocol seems to have a 32-bit mask for valuator ID
			double values[32]; // https://www.x.org/releases/X11R7.7/doc/inputproto/XI2proto.txt
			
			size_t n_valuators = 0;
			for (int j=0;j<info[i].num_classes;j++)
			{
				XIAnyClassInfo* cl = info[i].classes[j];
				if (cl->type == XIValuatorClass)
				{
					XIValuatorClassInfo* vcl = (XIValuatorClassInfo*)cl;
					XISetMask(mask, n_valuators);
					values[n_valuators] = vcl->value;
					n_valuators++;
				}
			}
			
			if (n_valuators && info[i].use == XISlavePointer)
			{
				XIDeviceEvent ev = {
					/* type */       GenericEvent,
					/* serial */     (uint64_t)-1, // unclear if it's used
					/* send_event */ true, // unused
					/* display */    xdisp,
					/* extension */  xi_opcode,
					/* evtype */     XI_Motion,
					// (this struct has a few fields in common with XGenericEvent, but they're not used as such)
					/* time */       1, // part of gdk_x11_device_manager_xi2_translate_event return value
					// (XIEvent ends here)
					/* deviceid */   info[i].attachment, // physical device ID
					/* sourceid */   info[i].deviceid, // logical device ID
					/* detail */     0, // unused
					/* root */       0, // unused
					/* event */      gdk_x11_surface_get_xid(surf),
					/* child */      0, // unused
					/* root_x */     0, // unused
					/* root_y */     0, // unused
					/* event_x */    0, // part of gdk_x11_device_manager_xi2_translate_event return value
					/* event_y */    0, // part of gdk_x11_device_manager_xi2_translate_event return value
					/* flags */      0, // must not contain XIPointerEmulated
					/* buttons */    {}, // part of gdk_x11_device_manager_xi2_translate_event return value
					/* valuators */  { sizeof(mask), mask, values },
					/* mods */       {}, // part of gdk_x11_device_manager_xi2_translate_event return value
					/* group */      {}, // part of gdk_x11_device_manager_xi2_translate_event return value
				};
				
				XGenericEventCookie xev = {
					/* type */       GenericEvent,
					/* serial */     (uint64_t)-1,
					/* send_event */ true,
					/* display */    xdisp,
					/* extension */  xi_opcode,
					/* evtype */     XI_Motion,
					/* cookie */     0, // unused
					/* data */       &ev,
				};
				
				gboolean discard;
				g_signal_emit_by_name(disp, "xevent", &xev, &discard);
			}
		}
		XIFreeDeviceInfo(info);
	};
	
	GdkSurface* surf = gtk_native_get_surface(gtk_widget_get_native(GTK_WIDGET(wnd)));
	GdkDisplay* disp = gdk_surface_get_display(surf);
	
	GtkEventController* ev = gtk_event_controller_legacy_new();
	gtk_event_controller_set_propagation_phase(ev, GTK_PHASE_CAPTURE);
	gtk_widget_add_controller(GTK_WIDGET(wnd), ev);
	auto ev_cb = decompose_lambda([ev](GdkEvent* event, GtkEventControllerLegacy* self) -> gboolean {
		// sending Gtk fake scroll events tends to, well, scroll the contents. Let's block that.
		if (gdk_event_get_time(event) == 1)
			return GDK_EVENT_STOP;
		return GDK_EVENT_PROPAGATE;
	});
	g_signal_connect_swapped(ev, "event", G_CALLBACK(ev_cb.fp), ev_cb.ctx);
	
	auto xev_cb = decompose_lambda([surf](const XEvent * xevent, GdkDisplay* display) -> gboolean {
		if (xevent->type == GenericEvent)
		{
			XGenericEventCookie* xevc = (XGenericEventCookie*)xevent;
			if (xevc->extension == xi_opcode)
			{
				XIDeviceEvent* xie = (XIDeviceEvent*)xevc->data;
				if (xie->evtype == XI_Enter)
				{
					// need to run this function after Gtk processes the entry event
					g_idle_add([](void* data)->gboolean {
							query_wheel((GdkSurface*)data);
							return G_SOURCE_REMOVE;
						}, surf);
				}
			}
		}
		return GDK_EVENT_PROPAGATE;
	});
	g_signal_connect_swapped(disp, "xevent", G_CALLBACK(xev_cb.fp), xev_cb.ctx);
	
	query_wheel(surf);
}
#endif

//todo list

//verification:
//null

//top prio:
//- arlib/socket: check if incoming data on two SSL simultaneously screws up
//    either before processing either, or while processing one of them
//- discord: I got a crash at or around a CHANNEL_CREATE for a DM, but I lost disco.log and can't figure out how that happened
//- textview: make bottom lock stickier; only scroll (mouse/touchpad), drag (scrollbar), and pgup/dn (and heavy activity) should unstick
//- textview: check if two consecutive images with alt text screw up selection, and if yes, fix
//    probably via custom ctrl-c handler and deleting the selection lamehack
//- chanview: leaving a channel with activity less than 1000ms ago should leave it marked active; must increase last activity precision
//- main/protocols: if last activity was less than 5s ago and new message is from myself or a bot, it should not count as activity
//- figure out which features I actually need

//high prio:
//- create class textview_impl so all the privates get out of the header
//- tab complete
//- irc: rename query windows on /nick
//- discord: find some way to split discord.cpp, it's getting uncomfortably big
//- global commands
//    /in, /1w
//    /ar (via cgi, uses a temp message to the current channel even if cross-group)
//- textview: custom ctrl-c handler and remove scale=0.0 hack; it works for textview, but not inputview, and they should do the same
//- create all visible textviews in g_idle_add

//medium prio:
//- discord: userlist per guild
//- discord: userlist per channel (permission-aware)
//- discord: make channel/etc links clickable
//- discord: irc->discord format translator
//    and /md or /raw command, for bot commands that won't parse markdown
//    and bot prefix list in config; if message starts with !, leave it raw, bots don't parse md
//- discord: username colors
//- discord: implement various state change handlers: user joined, channel renamed, etc
//- discord: render attachments inline
//- discord: non-square emoji should be vertically centered, not bottom-aligned
//- discord: non-square emoji should be horizontally padded to square
//- discord: auto mark afk if machine is 5min idle
//    int dummy;
//    if (DPMSQueryExtension(dpy, &dummy, &dummy) && DPMSCapable(dpy))
//    {
//        CARD16 state = DPMSModeOn;
//        BOOL onoff;
//        DPMSInfo(dpy, &state, &onoff);
//        if (onoff && state != DPMSModeOn)
//            // screen is off, aka machine is idle
//- textview: protocol-callback links (as opposed to the current hardcoded browser-only links)
//    discord: fix [Example](https://www.example.com/) parsing, and how to render it
//      append [www.example.com] to link text, unless that and only that domain is visibly present on other links in the message?
//- textview: allow small amounts of mouse movement when clicking a link
//- textview: give insert/selection-bound left gravity
//- discord/textview: when deleting message, ask protocol for larger image, rather than resizing something the protocol already shrank
//- main: somewhere to print errors if a protocol refers to a nonexistent message in bad ways
//- inputview: syntax highlighting
//- inputview: indentation on line wrap
//- user list powerlevels
//- Copy as - IRC | HTML | unformatted | without timestamps | etc
//    needs textview ctrl-c handler

//low prio, some of those probably shouldn't be done at all:
//- message editing leaves a diff, rather than just the old message
//- find or create diff function for the above
//- topic box
//- discord: guild tabs should contain status messages (joins, powerlevels, etc) about the guild, rather than being unfocusable
//- discord: move avatars and emoji out of the json blob
//- discord: estimate server time to improve temp message timestamp
//- discord: user rename should rename the query window too (TODO: how to make that not rearrange them?)
//- discord: pins
//- discord: voice
//- discord: <#1234> on a voice channel or channel category should render as '#General' in plaintext, not #deleted-channel
//- discord: use the server-side last-read markers (low prio, pointless with only a single computer)
//- discord: hide channels I can't access (low prio, they auto hide after a few days)
//- discord: use server-defined guild order
//- textview: put mouse on link, switch channel, move mouse to not on link, switch back. this should update cursor
//- textview: paint clicked links purple
//- textview: gtk_text_view_set_top_margin for inputview, rather than side windows
//- textview: shrunk images should ask the protocol for a smaller one, rather than gdk_pixbuf_scale_simple, to avoid some generation loss
//    there's no way to do that without making a mess; it's impossible to go from GdkPixbuf* to textview::image*
//      (map<GdkPixbuf*, image*> would have lifetime issues)
//      multiple textview::image for same GdkPixbuf would make comparison annoying
//      changing image* to image would make lifetime management tricky
//      and I can't see any other implementation
//- textview: make message_replace_image work on shrunk images
//    same caveats as the above

//zero prio, I will not implement these (I wouldn't reject a well-written PR, though I can't promise it won't break at random intervals):
//- macos support
//- windows support
//    I don't have those installed, and it would require a lot of effort for zero (to me) gain
//- inputview: dehardcode the selection colors with warning enabled
//    I'd love a PR showing how to do that, I couldn't find it myself
//- dark theme
//    the bulk of the work should be done by a GTK+ stylesheet, but providing one,
//    documenting how to use it, and dehardcoding a couple of colors, would be an improvement
//    (assuming Gtk stylesheets have stopped breaking with every single version...)
//- discord: extract cookies from chrome/chromium
//    I don't have that installed either; easier to install than windows, and harder to accidentally regress, but still no personal gain
//- discord: code block syntax highlighting
//    discord uses some version of https://highlightjs.org/; translating is lots of effort for little gain,
//    while using something else would most likely bring massive amounts of nasty dependencies,
//      be annoying to integrate, and likely be slightly inaccurate
//- discord: video
//    it's undocumented
//- textview: 1px left/right padding on code tags, so discord `<200b>`<200b> times 10 shows up
//    tags' padding property seems to be ignored, left-margin applies only on linebreak or word wrap

#define IDLE_TIMEOUT 1800
#define DONT_MARK_READ_TIMEOUT 2

namespace russian {

#ifdef ARLIB_GUI_GTK4 // this widget isn't used anyways
class hintview : nocopy {
public:
	GtkOverlay* overlay;
	
	GtkWidget* main; // main widget
	GtkWidget* sub; // child widget, placed on top of the main widget
	
	int x;
	int main_scrollwidth;
	
	hintview(GtkWidget* main, GtkWidget* sub)
	{
{
GtkTextView* contents = GTK_TEXT_VIEW(gtk_text_view_new());
gtk_text_buffer_insert_at_cursor(gtk_text_view_get_buffer(contents), "floating\nmuncher", -1);
sub = GTK_WIDGET(contents);
}
		this->main = main;
		
		// yes, a GtkScrolledWindow with scrollbar policy NEVER/NEVER is silly, but it's the easiest way to add a border
		// I tried various kinds of css, but border, outline margin and padding didn't seem to do anything when I tried
		// (as a bonus, it's guaranteed to match textview's border)
		GtkScrolledWindow* sub_wrap = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(
#ifdef ARLIB_GUI_GTK3
NULL, NULL
#endif
		));
		gtk_scrolled_window_set_policy(sub_wrap, GTK_POLICY_NEVER, GTK_POLICY_NEVER);
#ifdef ARLIB_GUI_GTK3
		gtk_scrolled_window_set_shadow_type(sub_wrap, GTK_SHADOW_IN);
		gtk_container_add(GTK_CONTAINER(sub_wrap), GTK_WIDGET(sub));
#else
		gtk_scrolled_window_set_has_frame(sub_wrap, true);
		gtk_scrolled_window_set_child(sub_wrap, GTK_WIDGET(sub));
#endif
		this->sub = GTK_WIDGET(sub_wrap);
		
		overlay = GTK_OVERLAY(gtk_overlay_new());
		gtk_overlay_set_child(overlay, main);
		gtk_overlay_add_overlay(overlay, GTK_WIDGET(sub_wrap));
		
		auto place_child_cb = decompose_lambda([this](GtkWidget* widget, GdkRectangle* allocation, GtkOverlay* overlay) -> gboolean
		{
			GtkRequisition sub_size;
			gtk_widget_get_preferred_size(this->sub, NULL, &sub_size);
			
			int main_width = gtk_widget_get_allocated_width(this->main) - this->main_scrollwidth;
			int main_height = gtk_widget_get_allocated_height(this->main);
			
			allocation->x = min(x, main_width - sub_size.width);
			allocation->y = main_height - sub_size.height;
			allocation->width = sub_size.width;
			allocation->height = sub_size.height;
			
			return TRUE;
		});
		g_signal_connect_swapped(overlay, "get-child-position", G_CALLBACK(place_child_cb.fp), place_child_cb.ctx);
		
		main_scrollwidth = 0;
		if (GTK_IS_SCROLLED_WINDOW(main))
		{
			GtkWidget* scroll = gtk_scrolled_window_get_vscrollbar(GTK_SCROLLED_WINDOW(main));
			if (scroll)
			{
				GtkRequisition nat;
				gtk_widget_get_preferred_size(scroll, NULL, &nat);
				main_scrollwidth = nat.width;
			}
		}
		
		this->x = 0;
	}
	
	void show(bool show)
	{
		gtk_widget_set_visible(sub, show);
	}
	
	int width()
	{
		return gtk_widget_get_allocated_width(main);
	}
	
	//If x is too high, it's clamped. Negative is undefined behavior.
	void move(int x)
	{
		this->x = x;
		gtk_widget_queue_resize(GTK_WIDGET(overlay));
	}
	
	GtkWidget* gtkwidget() { return (GtkWidget*)overlay; }
};
#endif

template<typename T>
class hashable_pointer {
	T* ptr;
public:
	hashable_pointer() = default;
	hashable_pointer(T* ptr) : ptr(ptr) {}
	T* operator->() { return ptr; }
	T& operator*() { return *ptr; }
	const T* operator->() const { return ptr; }
	const T& operator*() const { return *ptr; }
	operator T*() { return ptr; }
	operator const T*() const { return ptr; }
	explicit operator bool() const { return ptr; }
	size_t hash() const { return (uintptr_t)ptr; }
	bool operator==(const hashable_pointer& other) const { return ptr == other.ptr; }
};

class imgcache_t {
public:
	string fn;
	
private:
	staticmap smap;
	bool open = false;
	
	http_t http;
	array<string> http_todo;
	waiter_fn<void, void> http_coro;
	
	map<string, array<textview::image*>> loaded; // An URL may be loaded multiple times with different sizes. May be blank placeholders.
	map<hashable_pointer<textview::image>, array<textview*>> placeholder_locations;
	
	void todo_process()
	{
puts("fetch "+http_todo[0]+", "+tostring(http_todo.size())+" left");
		http_coro = {};
		([](imgcache_t* self)->async<void>{
			http_t::req q;
			q.url = self->http_todo[0];
			http_t::rsp r = co_await self->http.request(q);
			self->todo_done(r);
		}(this)).then(&http_coro);
	}
	void todo_done(http_t::rsp& r)
	{
		http_todo.pop(0);
		if (r.status == 404)
		{
			smap.insert(r.request.url.bytes(), bytesr());
smap.fsck();
		}
		else if (r.body())
		{
			smap.insert(r.request.url.bytes(), r.body());
smap.fsck();
			replace_image(r.request.url, r.body());
		}
		if (http_todo)
			todo_process();
		else
			smap.sync();
	}
	
	void replace_image(cstring url, bytesr by)
	{
		array<textview::image*>& imgs = loaded.get_create(url); // should always exist, so let's get_create
		array<textview::image*> newimgs;
		for (textview::image* img : imgs)
		{
			textview::image* newimg = textview::image::create(by, img->width(), img->height());
			array<textview*>& tvs = placeholder_locations.get_create((hashable_pointer<textview::image>)img);
			for (textview* tv : tvs)
				tv->message_replace_image("", img, newimg);
			delete img;
			placeholder_locations.remove((hashable_pointer<textview::image>)img);
		}
		imgs = std::move(newimgs);
	}
	
	bytesr get_img_by_url(cstring url, bool* found)
	{
		if (!open)
		{
			smap.open(fn);
			open = true;
puts("loaded cache, "+tostring(smap.size())+" entries");
		}
		bytesr ret = smap.get_or_empty(url.bytes(), found);
		if (!*found && http_todo.find(url) == (size_t)-1)
		{
			http_todo.append(url);
			if (http_todo.size() == 1)
				todo_process();
		}
		return ret;
	}
	
public:
	textview::image* image_create(cstring url, size_t width, size_t height)
	{
		array<textview::image*>& imgs = loaded.get_create(url);
		for (textview::image* img : imgs)
		{
			if (img->width() == width && img->height() == height)
				return img;
		}
		textview::image* ret;
		bool found;
		bytesr by = get_img_by_url(url, &found);
		if (by)
			ret = textview::image::create(by, width, height);
		else
			ret = textview::image::blank(width, height);
		if (!found)
			placeholder_locations.get_create((hashable_pointer<textview::image>)ret);
		imgs.append(ret);
		return ret;
	}
	void peek(textview* tv, arrayview<span> spans)
	{
		for (const span& sp : spans)
		{
			array<textview*>* tvs = placeholder_locations.get_or_null((hashable_pointer<textview::image>)sp.img);
			if (!tvs) continue;
			if (tvs->contains(tv)) continue;
			tvs->append(tv);
		}
	}
	void delete_textview(textview* tv)
	{
		for (auto& pair : placeholder_locations)
		{
			size_t idx = pair.value.find(tv);
			if (idx != (size_t)-1)
				pair.value.remove(idx);
		}
	}
	~imgcache_t()
	{
		if (!open)
			return;
		array<bytearray> remove; // bytesr is technically safe, removing from staticmap won't rehash, but it's documented as UB so let's not
		for (auto node : smap)
		{
			if (!loaded.contains((cstring)node.key))
				remove.append(node.key);
		}
		for (bytearray& by : remove)
		{
puts("garbage collect "+cstring(by));
			smap.remove(by);
		}
puts("removed "+tostring(remove.size())+" cache entries, "+tostring(smap.size())+" remaining");
	}
};

class impl {
public:
	GtkWindow* wnd;
	
	chanview* cv;
	GtkStack* stack;
	
	array<protocol*> protos;
	
	int ngroup = 0;
	
	chanbase* cur_chan = NULL;
	
	int x = INT_MAX;
	int y = INT_MAX;
	unsigned width = 400;
	unsigned height = 600;
	unsigned cvw = 60;
	unsigned uvw = 60;
	
	uint32_t chan_serial = 0;
	
	array<chanbase*> all_chans;
	array<chanbase*> lazy_chans;
	
	waiter_fn<void, void> idle_color_timer;
	
	string ondisconnect;
	time_t next_ondisconnect = 0;
	unsigned ondisconnect_minimum = 0;
	
	imgcache_t imgcache;
	
	bool runloop_exit = false;
	
	void execute(string cfgpath)
	{
		//without this, inputview turns super stupid
		//I don't know how early it must be set, so do it as fast as possible
		g_object_set(gtk_settings_get_default(), "gtk-enable-animations", false, NULL);
		wnd = GTK_WINDOW(gtk_window_new(
#ifdef ARLIB_GUI_GTK3
GTK_WINDOW_TOPLEVEL
#endif
		));
		
		this->cv = chanview::create();
		cv->onfocus(bind_this(&impl::cv_focus_cb));
		cv->onclose(bind_this(&impl::cv_onclose_cb));
		
		this->stack = GTK_STACK(gtk_stack_new());
		gtk_stack_set_hhomogeneous(stack, true);
		gtk_stack_set_vhomogeneous(stack, true);
		gtk_stack_set_transition_type(stack, GTK_STACK_TRANSITION_TYPE_NONE);
		
		if (!cfgpath)
			cfgpath = file::exedir()+"russian.cfg";
		string cfgtext = file::readall(cfgpath);
		
		int lock_fd = open(cfgpath, O_RDONLY|O_CLOEXEC);
		if (lock_fd < 0) goto no_config_exit;
		if (flock(lock_fd, LOCK_EX|LOCK_NB) < 0)
		{
			puts("russian: already running");
			return;
		}
		
		imgcache.fn = "imgcache.bin";
		bmldeserialize(cfgtext, [&](bmldeserializer& s) {
			s.items(
				"test", [&](bmldeserializer& s, cstring name) { protos.append(protocol::create_testp(this, s, name)); },
				"irc", [&](bmldeserializer& s, cstring name) { protos.append(protocol::create_irc(this, s, name)); },
				"matrix", [&](bmldeserializer& s, cstring name) { protos.append(protocol::create_matrix(this, s, name)); },
				"discord", [&](bmldeserializer& s, cstring name) { protos.append(protocol::create_discord(this, s, name)); },
				"todo", [&](bmldeserializer& s, cstring name) { protos.append(protocol::create_todo(this, s, name)); },
				"webhook", [&](bmldeserializer& s, cstring name) { protos.append(protocol::create_webhook(this, s, name)); },
				"window", [&](bmldeserializer& s) {
					s.items("width", width, "height", height, "x", x, "y", y, "chanlist", cvw, "userlist", uvw);
				},
				"imgcache", imgcache.fn,
				"ondisconnect", [&](bmldeserializer& s, cstring command) {
					ondisconnect = command;
					s.items("delay", ondisconnect_minimum);
				}
			);
		});
		
		if (!this->cur_chan)
		{
		no_config_exit:
			GtkDialog* dialog = GTK_DIALOG(gtk_message_dialog_new(NULL, (GtkDialogFlags)0,
			                               GTK_MESSAGE_ERROR, GTK_BUTTONS_CLOSE, "No config found, or no servers in config"));
			gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(dialog),
			               "Make sure %srussian.cfg exists and contains valid data.\n"
			               "Copy russian-tmpl.cfg and adapt it to your needs.",
			               (const char*)file::exedir().c_str());
			
			auto [fn, ptr] = decompose_lambda([](GtkDialog* self, gint response_id, gpointer user_data) {
				exit(0);
			});
			g_signal_connect_swapped(dialog, "response", G_CALLBACK(fn), ptr);
			gtk_dialog_run(dialog);
			exit(1); // should be unreachable
		}
		set_idles();
		
		GtkGrid* grid = GTK_GRID(gtk_grid_new());
		gtk_widget_set_size_request(cv->gtkwidget(), cvw, 0);
		gtk_widget_set_vexpand(cv->gtkwidget(), true);
		gtk_grid_attach(grid, cv->gtkwidget(),   0,0, 1,1);
		gtk_grid_attach(grid, GTK_WIDGET(stack), 1,0, 1,1);
		
#ifdef ARLIB_GUI_GTK3
		auto onclose_cb = decompose_lambda([this](GdkEvent* event, GtkWidget* widget) -> gboolean
		{
			gtk_widget_hide(widget);
			runloop_exit = true;
			return GDK_EVENT_STOP;
		});
		g_signal_connect_swapped(wnd, "delete-event", G_CALLBACK(onclose_cb.fp), onclose_cb.ctx);
#else
		auto onclose_cb = decompose_lambda([this](GtkWindow* self) -> gboolean
		{
			runloop_exit = true;
			return GDK_EVENT_STOP;
		});
		g_signal_connect_swapped(wnd, "close-request", G_CALLBACK(onclose_cb.fp), onclose_cb.ctx);
#endif
		
		auto onkb_cb = decompose_lambda(
			[this](guint keyval, guint keycode, GdkModifierType state, GtkEventControllerKey* self) -> gboolean
		{
			GdkModifierType mods = (GdkModifierType)(state & (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_ALT_MASK));
			
			GtkWidget* target;
			
			if (keyval == GDK_KEY_Page_Up || keyval == GDK_KEY_Page_Down)
			{
				if (mods == 0)
				{
					gtk_event_controller_key_forward(self, cur_chan->tv->gtkwidget());
					cur_chan->tv->user_input();
					return GDK_EVENT_STOP;
				}
				if (mods == GDK_CONTROL_MASK)
				{
					cv->move_focus((keyval == GDK_KEY_Page_Up) ? -1 : 1);
					return GDK_EVENT_STOP;
				}
			}
			
			//anything that affects the input widget must cause a refocus
			//that includes, but is not limited to:
			//- printables
			//- backspace, delete
			//- ctrl-v, formatting
			//- ctrl-shift-u
			//- navigation (up, down, left, right, home, end)
			//however, ctrl-c (including the ctrl) must stay on the focus widget
			//
			//this one refocuses if it detects any of the above, not otherwise; it could be made more aggressive if desired
			//maybe even send all keyboard to textview, except (ctrl-)pgup/dn, and ctrl-c if inputview lacks selection
			
			bool to_input = false;
			
			if (gdk_keyval_to_unicode(keyval) != 0 || // oddly enough, this can report backspace/delete too
				keyval == GDK_KEY_Up || keyval == GDK_KEY_Down ||
				keyval == GDK_KEY_Left || keyval == GDK_KEY_Right ||
				keyval == GDK_KEY_Home || keyval == GDK_KEY_End ||
				(keyval >= GDK_KEY_dead_grave && keyval <= GDK_KEY_dead_greek) || // silly, but I couldn't find a
				false)                                                            // better way to detect dead keys
			{
				to_input = true;
			}
			
			if (mods & (GDK_CONTROL_MASK | GDK_ALT_MASK))
			{
				to_input = false;
			}
			// c-a, c-v and c-s-u are gtk-defined ways to interact with textviews, the others are specific to here
			// c-c is explicitly not included
			if ((mods & GDK_CONTROL_MASK) && (strchr("avUbkuioms", keyval) ||
			                                          keyval == GDK_KEY_Home || keyval == GDK_KEY_End))
			{
				to_input = true;
			}
			
			if (to_input)
			{
				cur_chan->iv->grab_focus();
				gtk_event_controller_key_forward(self, cur_chan->iv->gtkwidget_inner());
				return GDK_EVENT_STOP;
			}
			
			return GDK_EVENT_PROPAGATE;
		});
#ifdef ARLIB_GUI_GTK3
		GtkEventController* ctrlkey = gtk_event_controller_key_new(GTK_WIDGET(wnd));
#else
		GtkEventController* ctrlkey = gtk_event_controller_key_new();
		gtk_widget_add_controller(GTK_WIDGET(wnd), ctrlkey);
#endif
		gtk_event_controller_set_propagation_phase(ctrlkey, GTK_PHASE_CAPTURE);
		g_signal_connect_swapped(ctrlkey, "key-pressed", G_CALLBACK(onkb_cb.fp), onkb_cb.ctx);
		//g_signal_connect_swapped(wnd, "key-press-event", G_CALLBACK(onkb_cb.fp), onkb_cb.ctx);
		
		//lazy-loading the channels keeps screwing up, initialize them as soon as possible
		g_idle_add([](void* user_data) -> gboolean
			{
				impl* this_ = (impl*)user_data;
				if (this_->lazy_chans)
				{
					chanbase* chan = this_->lazy_chans.pop_tail();
					if (!chan->hidden)
						this_->render(chan);
					return G_SOURCE_CONTINUE;
				}
				return G_SOURCE_REMOVE;
			}, this);
		
#ifdef ARLIB_GUI_GTK3
		auto any_event = decompose_lambda([this](GdkEvent* event, GtkWidget* widget) -> gboolean
		{
			cur_chan->tv->user_input(event->type);
			return GDK_EVENT_PROPAGATE;
		});
		g_signal_connect_swapped(wnd, "event", G_CALLBACK(any_event.fp), any_event.ctx);
#else
		auto any_event = decompose_lambda([this](GdkEvent* event, GtkEventControllerLegacy* self) -> gboolean
		{
			cur_chan->tv->user_input(gdk_event_get_event_type(event));
			return GDK_EVENT_PROPAGATE;
		});
		GtkEventController* ctrl = gtk_event_controller_legacy_new();
		gtk_widget_add_controller(GTK_WIDGET(wnd), ctrl);
		gtk_event_controller_set_propagation_phase(ctrl, GTK_PHASE_CAPTURE);
		g_signal_connect_swapped(ctrl, "event", G_CALLBACK(any_event.fp), any_event.ctx);
#endif
		
#ifdef ARLIB_GUI_GTK3
		gtk_container_add(GTK_CONTAINER(wnd), GTK_WIDGET(grid));
#else
		gtk_window_set_child(wnd, GTK_WIDGET(grid));
#endif
		gtk_window_set_resizable(wnd, true);
		if (width && height) gtk_window_set_default_size(wnd, width, height);
		
#ifdef ARLIB_GUI_GTK3
		gtk_widget_show_all(GTK_WIDGET(wnd));
#else
		gtk_widget_show(GTK_WIDGET(wnd));
#endif
		
		if (x != INT_MAX && y != INT_MAX)
		{
#ifdef ARLIB_GUI_GTK3
			gdk_window_move(gtk_widget_get_window(GTK_WIDGET(wnd)), x, y);
#else
			// why is gtk like this
			GdkSurface* surf = gtk_native_get_surface(gtk_widget_get_native(GTK_WIDGET(wnd)));
			XMoveWindow(gdk_x11_display_get_xdisplay(gdk_surface_get_display(surf)), gdk_x11_surface_get_xid(surf), x, y);
#endif
		}
		
#ifdef ARLIB_GUI_GTK4
		fix_xi2_because_gtk_refuses_to(wnd);
#endif
		
		while (!runloop_exit)
			runloop2::step();
		
		for (protocol* proto : protos)
		{
			delete proto;
		}
		protos.reset();
	}
	
	void set_idles()
	{
		time_t now = time(NULL);
		time_t next_check = now+IDLE_TIMEOUT;
		for (chanbase* chan : all_chans)
		{
			if (chan->cvb_imp != chanbase::imp_none || (chan->flags & chanbase::f_no_focus))
				continue;
			if (chan->last_activity <= now-IDLE_TIMEOUT)
			{
				chan->cvb_imp = chanbase::imp_idle;
				if (cur_chan != chan)
					chan->cvb->color_fg(0x666666);
			}
			else
				next_check = min(next_check, chan->last_activity+IDLE_TIMEOUT);
		}
		idle_color_timer = {};
		([](impl* self, time_t next_check)->async<void>{
			co_await runloop2::await_timeout(timestamp::from_native({ next_check, 0 }));
			self->set_idles();
		}(this, next_check)).then(&idle_color_timer);
	}
	
	//Initializes all widgets and adds it to the GtkStack.
	void render(chanbase* chan)
	{
		if (cur_chan->grid)
			return;
		
		chan->grid = GTK_GRID(gtk_grid_new());
		
		gtk_grid_attach(chan->grid, chan->tv->gtkwidget(), 1,0, 1,1);
		gtk_widget_set_hexpand(chan->tv->gtkwidget(), true);
		gtk_widget_set_vexpand(chan->tv->gtkwidget(), true);
		
		gtk_grid_attach(chan->grid, chan->iv->gtkwidget(), 1,1, 1,1);
		gtk_widget_set_hexpand(chan->iv->gtkwidget(), true);
		
		if (chan->uv)
		{
			gtk_widget_set_size_request(chan->uv->gtkwidget(), uvw, 0);
			gtk_grid_attach(chan->grid, chan->uv->gtkwidget(), 2,0, 1,2);
			gtk_widget_set_vexpand(chan->uv->gtkwidget(), true);
		}
		
#ifdef ARLIB_GUI_GTK3
		gtk_widget_show_all(GTK_WIDGET(chan->grid));
		gtk_container_add(GTK_CONTAINER(stack), GTK_WIDGET(chan->grid));
#else
		gtk_stack_add_child(stack, GTK_WIDGET(chan->grid));
#endif
		
		//scroll position is often wrong on first switch to channel, unless initialized like this already
		g_idle_add_full(G_PRIORITY_DEFAULT_IDLE+3, [](void* user_data) -> gboolean
			{
				// with some nasty timeout because it's STILL not enough in all cases
				g_timeout_add(100/*ms*/, [](void* user_data) -> gboolean
					{
						chanbase* chan = (chanbase*)user_data;
						gtk_widget_set_sensitive(chan->tv->gtkwidget(), false);
						gtk_widget_set_sensitive(chan->tv->gtkwidget(), true);
						// TODO: this will mess up if I start disabling iv on untalkable channels
						gtk_widget_set_sensitive(chan->iv->gtkwidget(), false);
						gtk_widget_set_sensitive(chan->iv->gtkwidget(), true);
						return G_SOURCE_REMOVE;
					}, user_data);
				return G_SOURCE_REMOVE;
			}, (void*)chan, NULL);
	}
	
	void cv_focus_cb(void* userdata)
	{
		chanbase* new_chan = (chanbase*)userdata;
		// Gtk sometimes likes calling the selection function multiple times...
		// ignore that, calling tv->user_input() on a freshly lazy-instantiated textview discards the scroll position
		if (cur_chan == new_chan) return;
		
		new_chan->pgroup->last_focus = new_chan;
		
		bool has_focus = true;
		if (cur_chan)
		{
			has_focus = cur_chan->iv->has_focus();
			cur_chan->tv->user_input();
			
			// if activity was within last 2s, assume user didn't see it and leave channel marked as unread
			if (cur_chan->last_activity <= time(NULL)-DONT_MARK_READ_TIMEOUT)
				cur_chan->cvb_imp = chanbase::imp_none;
			if (cur_chan->last_activity <= time(NULL)-IDLE_TIMEOUT)
				cur_chan->cvb_imp = chanbase::imp_idle;
			
			cur_chan->set_color();
		}
		this->cur_chan = new_chan;
		cur_chan->tv->user_input();
		
		render(cur_chan);
		gtk_stack_set_visible_child(this->stack, GTK_WIDGET(cur_chan->grid));
		if (has_focus)
			cur_chan->iv->grab_focus();
		
		//cvb can be NULL during object construction
		if (cur_chan->cvb)
			cur_chan->cvb->color_fg(-1);
		
		gtk_window_set_title(wnd, new_chan->name+" - " APPNAME);
		
//#if !GTK_CHECK_VERSION(3,22,0)
		// workaround for some pixel cache invalidation bug, fixed long ago
		// to reproduce:
		// - switch to channel X
		// - switch away
		// - let 5 messages appear in channel X
		// - switch back to channel X
		// this is easiest done using the test protocol
		
		gtk_widget_set_sensitive(cur_chan->tv->gtkwidget(), false);
		gtk_widget_set_sensitive(cur_chan->tv->gtkwidget(), true);
//#endif
	}
	void cv_onclose_cb(void* userdata)
	{
		chanbase* chan = (chanbase*)userdata;
		chan->parent->close_chan(*chan);
	}
	
	void remove_chan(chanbase* ch)
	{
		all_chans.remove(all_chans.find(ch));
		size_t lazy_idx = lazy_chans.find(ch);
		if (lazy_idx != (size_t)-1) lazy_chans.remove(lazy_idx);
	}
};

group::group(protocol* parent, cstring name, uint32_t flags, anyptr userdata)
	: chanbase(parent, this, name, flags, userdata), last_focus(this)
{
	// keep this seemingly-pointless assignment, cv_focus_cb can get called by this chanview->child call
	cvb = NULL;
	cvb = parent->parent->cv->child(name, !(flags&f_no_focus), this);
	
	cvb->sort_as(parent->parent->ngroup++, "");
	if (flags&f_no_focus)
	{
		cvb->color_fg(0x666666); // if changing this, also change russian.h::chanbase::set_available
		cvb->set_strike(true);
	}
}
channel::channel(protocol* parent, group* pgroup, chanview::group* pchan, cstring name, uint32_t flags, anyptr userdata)
	: chanbase(parent, pgroup, name, flags, userdata)
{
	cvb = NULL;
	cvb = pchan->child(name, !(flags&f_no_focus), this);
	
	if (flags&f_no_focus)
	{
		cvb->color_fg(0x666666);
		cvb->set_strike(true);
	}
	if (!(flags&f_hidden))
		((chanview::channel*)cvb)->set_hidden(false);
}
static string readlines(file& logfile, size_t& lines)
{
	if (!logfile) return "";
	
	string text = logfile.read(logfile.size());
	size_t start = text.length();
	if (!start) return "";
	start--; // the file always ends with a \n, which shouldn't be included
	while (start > 0)
	{
		if (text[start] == '\n')
		{
			lines--;
			if (lines == 0)
			{
				start++;
				break;
			}
		}
		start--;
	}
	return text.substr(start, ~0);
}
chanbase::chanbase(protocol* parent, group* pgroup, cstring name, uint32_t flags, anyptr userdata)
	: parent(parent), pgroup(pgroup), userdata(userdata), name(name)
{
	serial = ++parent->parent->chan_serial;
	
	if (flags&f_no_focus)
	{
		flags |= f_no_logs|f_no_users;
	}
	this->flags = flags;
	
	// we can get two channels with the same name, causing various confusion
	// we choose to not care, it's rare
	for (size_t i=0;i<name.length();i++)
	{
		if (name[i] == '/') {}
		else if (name[i] == '.' && !name_fn) {}
		else name_fn += name[i];
	}
	if (!name_fn) name_fn = "_";
	
	string scrollback = "";
	
	if (!(flags&f_no_logs))
	{
		file prev;
		time_t now = time(NULL);
		log_open(prev, now, false);
		logrotate = 1; // some trickery to avoid creating empty log files
		
		if (!(flags&f_no_scrollback))
		{
			size_t linesleft = 100;
			scrollback = readlines(prev, linesleft);
			if (linesleft)
			{
				log_open(prev, month_prev(now), false);
				if (prev) scrollback = readlines(prev, linesleft)+scrollback;
			}
		}
	}
	scrollback = scrollback.replace(string::nul(), "");
	if (!scrollback.isutf8())
	{
		// can happen if two russians write the log simultaneously, if two channels get the same name,
		// or if someone manually mangles the local data
		scrollback = "[WARNING: corrupt scrollback]";
	}
	
	if (flags & f_no_focus)
	{
		this->tv = NULL;
		this->iv = NULL;
	}
	else
	{
		this->tv = textview::create(flags & f_less_indent);
		tv->scrollback(scrollback);
		tv->on_scroll_state([this](bool now_at_bottom) {
				this->now_at_bottom = now_at_bottom;
				this->set_name();
				this->iv->set_warning(!now_at_bottom);
			});
		tv->on_context_menu([this](array<textview::ctxaction>& actions, cstrnul msgid) {
				this->parent->contextmenu(*this, msgid, actions);
			});
		tv->on_internal_link([this](string text) { this->parent->ilink(text); });
		
		this->iv = inputview::create(parent->valid_fmt);
		iv->set_onactivate([this](cstrnul text) {
				for (protocol* p : this->parent->parent->protos)
				{
					if (p->global_action(*this, this->serial, text) == protocol::ga_handled) return;
				}
				this->parent->action(*this, text);
			});
		//iv->set_onmovecaret(bind_this(&chanbase::inputmove_cb));
		
		parent->parent->lazy_chans.append(this);
	}
	
	if (flags & f_no_users)
	{
		this->uv = NULL;
	}
	else
	{
		this->uv = userview::create();
		uv->onactivate([this](cstrnul name) { this->parent->begin_private(*this, name); });
	}
	
	this->grid = NULL;
	parent->parent->all_chans.append(this);
}

time_t chanbase::month_prev(time_t t)
{
	struct tm stm;
	localtime_r(&t, &stm);
	
	stm.tm_sec = 0;
	stm.tm_min = 0;
	stm.tm_hour = 0;
	stm.tm_mday = 1;
	if (stm.tm_mon == 0)
	{
		stm.tm_year--;
		stm.tm_mon = 12;
	}
	stm.tm_mon--;
	
	return mktime(&stm);
}
time_t chanbase::month_start(time_t t)
{
	struct tm stm;
	localtime_r(&t, &stm);
	
	stm.tm_sec = 0;
	stm.tm_min = 0;
	stm.tm_hour = 0;
	stm.tm_mday = 1;
	
	return mktime(&stm);
}
time_t chanbase::month_next(time_t t)
{
	struct tm stm;
	localtime_r(&t, &stm);
	
	stm.tm_sec = 0;
	stm.tm_min = 0;
	stm.tm_hour = 0;
	stm.tm_mday = 1;
	stm.tm_mon++;
	if (stm.tm_mon == 12)
	{
		stm.tm_year++;
		stm.tm_mon = 0;
	}
	
	return mktime(&stm);
}

static const char * timefmt_short = "%H:%M:%S";
static const char * timefmt_long = "%Y-%m-%d %H:%M:%S";
string time_to_str(time_t t, const char * fmt)
{
	struct tm t_tm = *localtime(&t);
	
	if (!fmt)
	{
		time_t now = time(NULL);
		struct tm now_tm = *localtime(&now);
		
		bool today = (now_tm.tm_year == t_tm.tm_year && now_tm.tm_yday == t_tm.tm_yday) || (t > now-900 && t < now+900);
		fmt = (today ? timefmt_short : timefmt_long);
	}
	
	char buf[128];
	strftime(buf, sizeof(buf), fmt, &t_tm);
	return buf;
}
#define MKSPANS_NUM 1 // mkspans inserts this many spans before 'bodyspans'.
static array<span> mkspans(time_t at, arrayview<span> bodyspans)
{
	array<span> spans;
	if (bodyspans)
	{
		static const span headspans[MKSPANS_NUM] = {};
		spans = headspans;
		if (at != 0)
			spans[0] = "["+time_to_str(at)+"] ";
		spans += bodyspans;
	}
	return spans;
}
void chanbase::log_open(file& f, time_t at, bool create) const
{
	file::mkdir(file::exedir()+"logs/");
	file::mkdir(file::exedir()+"logs/"+pgroup->name_fn+"/");
	
	struct tm stm;
	localtime_r(&at, &stm);
	
	char timebuf[64];
	strftime(timebuf, sizeof(timebuf), " %Y-%m", &stm);
	f.open(file::exedir()+"logs/"+pgroup->name_fn+"/"+name_fn+timebuf+".log", create ? file::m_write : file::m_read);
}
void chanbase::log(time_t at, arrayview<span> spans)
{
	time_t now = time(NULL);
	if (logrotate == 1) goto do_rotate;
	if (!logfile) return;
	
	if (now >= logrotate)
	{
	do_rotate:
		log_open(logfile, now, true);
		logfile.seek(logfile.size());
		logrotate = month_next(now);
	}
	
	string tmp;
	if (at != 0) tmp = "["+time_to_str(at, timefmt_long)+"] ";
	for (size_t i=0;i<spans.size();i++) tmp += spans[i].text.replace("\n", "\n               ");
	tmp += "\n";
	
	logfile.write(tmp);
}
void chanbase::message_at(cstring prev, bool after, cstring newid, bool is_scrollback,
                          importance_t imp, time_t at, arrayview<span> spans)
{
	parent->parent->imgcache.peek(tv, spans);
	if (this->parent->parent->cur_chan == this && last_activity < time(NULL)-2)
		cvb_imp = imp_none;
	cvb_imp = max(cvb_imp, imp);
	if (this->parent->parent->cur_chan != this)
		set_color();
	if (!is_scrollback)
		last_activity = max(last_activity, at);
	
	array<span> bodyspans = mkspans(at, spans);
	tv->message_at(prev, after, newid, bodyspans, imp <= imp_none);
	if (!is_scrollback) log(at, spans);
}
void chanbase::message_edit(cstring id, time_t at, arrayview<span> bodyspans, unsigned editslot)
{
	parent->parent->imgcache.peek(tv, bodyspans);
	array<span> spans = mkspans(at, bodyspans);
	if (spans[MKSPANS_NUM + editslot].text)
		spans[MKSPANS_NUM + editslot].text = "<ERROR: editslot was nonempty "+spans[MKSPANS_NUM + editslot].text+">";
	if (tv->message_exists(id) && at >= time(NULL)-4*3600) // if old, it's probably offscreen
	{
		tv->message_edit_visible(id, spans);
		spans[MKSPANS_NUM + editslot].text = "EDIT: "; // so logs show it as an edit
	}
	else
	{
		spans[MKSPANS_NUM + editslot].text = "EDIT: ";
		tv->message(id, spans);
	}
	log(at, spans.skip(MKSPANS_NUM));
}
void chanbase::message_delete(cstring id, time_t at)
{
	if (tv->message_exists(id))
		tv->message_edit_visible(id, NULL);
	//TODO: else print error
}
void chanbase::message_edit_true(cstring id, time_t at, arrayview<span> bodyspans)
{
	parent->parent->imgcache.peek(tv, bodyspans);
	array<span> spans = mkspans(at, bodyspans);
	if (tv->message_exists(id))
		tv->message_replace(id, spans);
	//TODO: else print error
}
void chanbase::message_replace_image(cstring id, textview::image* prev, textview::image* next)
{
	if (tv->message_exists(id))
		tv->message_replace_image(id, prev, next);
	//TODO: else print error
}

void chanbase::rename(cstring newname)
{
	if (this->name == newname) return;
	if (this == this->parent->parent->cur_chan)
	{
		gtk_window_set_title(this->parent->parent->wnd, newname+" - " APPNAME);
	}
	this->name = newname;
	set_name();
}
void chanbase::set_name()
{
	cvb->rename((now_at_bottom ? "" : "â†‘ ") + this->name, this->name);
}
chanbase::~chanbase()
{
	delete cvb; // delete this first, deleting the chanview makes textview switch to another channel and accesses buf
	if (tv) parent->parent->imgcache.delete_textview(tv);
	if (tv) delete tv; // cvb always exists, others don't if channel was never focused, or if it's unfocusable
	if (uv) delete uv;
	if (iv) delete iv;
	if (grid) g_object_unref(grid);
	parent->parent->remove_chan(this);
}

unsigned protocol::get_line_height() { return parent->cur_chan->tv->lineheight(); }

#ifdef ARLIB_GUI_GTK3
static void clip_image_cb(GtkClipboard* clipboard, GdkPixbuf* pixbuf, void* data)
{
	function<void(arrayview<uint8_t>)>* callback_p = (function<void(arrayview<uint8_t>)>*)data;
	char* buf = nullptr;
	size_t bufsiz = 0;
	if (pixbuf) gdk_pixbuf_save_to_buffer(pixbuf, &buf, &bufsiz, "png", NULL, NULL);
	(*callback_p)(arrayview<uint8_t>((uint8_t*)buf, bufsiz));
	g_free(buf);
	delete callback_p;
}
void protocol::clipboard_get_image_png(function<void(arrayview<uint8_t>)> callback)
{
	function<void(arrayview<uint8_t>)>* callback_p = new function<void(arrayview<uint8_t>)>(std::move(callback));
	gtk_clipboard_request_image(gtk_clipboard_get(GDK_SELECTION_CLIPBOARD), clip_image_cb, callback_p);
}
#else
void protocol::clipboard_get_image_png(function<void(arrayview<uint8_t>)> callback)
{
	struct state {
		//GdkClipboard* clip;
		function<void(arrayview<uint8_t>)> cb;
	};
	auto cb = [](GObject* source_object, GAsyncResult* res, void* user_data) {
		state* st = (state*)user_data;
		
		GdkTexture* tex = gdk_clipboard_read_texture_finish(GDK_CLIPBOARD(source_object), res, NULL);
		
		// TODO: enable this on gtk >= 4.5
		
		//GBytes* by = gdk_texture_save_to_png_bytes(tex);
		//size_t pngsize;
		//const void * png = g_bytes_get_data(by, &pngsize);
		//st->cb(arrayview<uint8_t>((uint8_t*)png, pngsize));
		//g_bytes_unref(by);
		//g_object_unref(tex);
		
		GdkPixbuf* pix = gdk_pixbuf_get_from_texture(tex);
		
		char* buf = nullptr;
		size_t bufsiz = 0;
		gdk_pixbuf_save_to_buffer(pix, &buf, &bufsiz, "png", NULL, NULL);
		st->cb(arrayview<uint8_t>((uint8_t*)buf, bufsiz));
		g_free(buf);
		
		g_object_unref(pix);
		g_object_unref(tex);
		delete st;
	};
	// gtk4 has a synchronous api if the content provider is in the same process,
	// but two ways to do the same thing is just silly, and this program can't provide images anyways.
	state* st = new state({ std::move(callback) });
	gdk_clipboard_read_texture_async(gtk_widget_get_clipboard(GTK_WIDGET(parent->wnd)), NULL, cb, st);
}
#endif

void protocol::clipboard_set_text(cstring text)
{
#ifdef ARLIB_GUI_GTK3
	gtk_clipboard_set_text(gtk_clipboard_get(GDK_SELECTION_CLIPBOARD), (char*)text.bytes().ptr(), text.length());
#else
	gdk_clipboard_set_text(gtk_widget_get_clipboard(GTK_WIDGET(parent->wnd)), text.c_str());
#endif
}

bool protocol::channel_valid(chanbase* at, uint32_t serial)
{
	for (chanbase* ch : parent->all_chans)
	{
		if (ch->serial == serial && at == ch)
			return true;
	}
	return false;
}

void protocol::disconnected()
{
	if (time(NULL) < parent->next_ondisconnect) return;
	if (!parent->ondisconnect) return;
	parent->next_ondisconnect = time(NULL) + parent->ondisconnect_minimum;
	system(parent->ondisconnect);
}

void protocol::open_link(cstring url)
{
	//firefox doesn't properly tell gtk that the link is open, so cursor gets stuck on 'opening...' for a few seconds
	//g_app_info_launch_default_for_uri(url.c_str(), NULL, NULL);
	system("x-www-browser '"+url.replace("'","'\"'\"'")+"' &");
}

void protocol::open_links(arrayview<cstring> urls)
{
	// it's safe to ignore quotes if input matches [A-Za-z0-9.-_/]+, but no real point
	// loop of open_link() gives a 10 second delay for some links if many are opened too quickly
	string command = "x-www-browser";
	for (cstring url : urls)
		command += " '"+url.replace("'","'\"'\"'")+"'";
	system(command+" &");
}

textview::image* protocol::image_create_url(cstring addr, size_t width, size_t height)
{
	return parent->imgcache.image_create(addr, width, height);
}

}



#ifdef ARLIB_GUI_GTK4
static bytearray pack_gresource(cstring name, bytesr body)
{
	array<cstring> nameparts = name.cspliti("/");
	array<bytestreamw_dyn::pointer> filename_start;
	array<bytestreamw_dyn::pointer> body_start;
	array<bytestreamw_dyn::pointer> body_end;
	
	bytestreamw_dyn by;
	by.text("GVariant"); // signature
	by.u32l(0); // version
	by.u32l(0); // options
	
	by.u32l(0x18); // root directory start
	bytestreamw_dyn::pointer root_end = by.ptr32();
	
	by.u32l(0); // bloom size
	by.u32l(1); // hash buckets (bucketing all to the same place is lazy, but for such a small resource pack, it makes no difference)
	
	by.u32l(0); // hash bucket start
	
	uint32_t id = 0;
	uint32_t hash = 5381;
	for (cstring s : nameparts)
	{
		for (uint8_t ch : s.bytes())
		{
			hash = (hash*33) + (int8_t)ch;
		}
		by.u32l(hash);
		by.u32l(id-1); // parent "directory"
		
		filename_start.append(by.ptr32());
		by.u16l(s.length());
		if (id == nameparts.size()-1)
			by.u8('v');
		else
			by.u8('L');
		by.u8(0);
		
		body_start.append(by.ptr32());
		body_end.append(by.ptr32());
		
		id++;
	}
	root_end.fill32l();
	
	id = 0;
	for (cstring s : nameparts)
	{
		if (id == nameparts.size()-1)
			break;
		body_start[id].fill32l();
		by.u32l(id+1);
		body_end[id].fill32l();
		
		id++;
	}
	
	by.align64();
	body_start[id].fill32l();
	by.u32l(body.size());
	by.u32l(0); // flags
	by.bytes(body);
	by.u8(0);
	
	by.u8(0);
	by.text("(uuay)");
	body_end[id].fill32l();
	
	id = 0;
	for (cstring s : nameparts)
	{
		filename_start[id++].fill32l();
		by.strnul(s);
	}
	
	return by.finish();
}
#endif

int main(int argc, char** argv)
{
#ifdef ARLIB_GUI_GTK3
	// XInput2 likes to eat the first scroll event after the mouse entering the window
	// this function kills XI2 so I get sane behavior
	// this mostly shows up in chanview any_event_cb, but not exclusively
	gdk_disable_multidevice();
#endif
	
	arlib_init();
	g_set_prgname("russian");
	chdir(file::exedir().c_str());
	
#ifdef ARLIB_GUI_GTK3
	GInputStream* is = g_memory_input_stream_new_from_data(resources::icon, sizeof(resources::icon), NULL);
	GdkPixbuf* pix = gdk_pixbuf_new_from_stream_at_scale(is, 64, 64, true, NULL, NULL);
	gtk_window_set_default_icon(pix);
#else
	bytearray by = pack_gresource("/russian/scalable/apps/russian.svg", resources::icon);
	g_resources_register(g_resource_new_from_data(g_bytes_new(by.ptr(), by.size()), NULL));
	
	gtk_icon_theme_add_resource_path(gtk_icon_theme_get_for_display(gdk_display_get_default()), "/russian/");
	gtk_window_set_default_icon_name("russian");
#endif
	
setvbuf(stdout, NULL, _IONBF, 0);
rlimit lim;
lim.rlim_cur = 512*1024*1024;
lim.rlim_max = RLIM_INFINITY;
setrlimit(RLIMIT_CORE, &lim);
	
	russian::impl ru;
	ru.execute(argv[1] ? argv[1] : "");
	return 0;
}
