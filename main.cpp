#ifndef ARGUI_GTK3
#error gtk only
#endif

#include "russian.h"

//todo list:
//X find suitable textview
//X add textview
//X add channel list
//X make input box work
//- make input box multiline
//- make runloop support sockets
//- make channel list a two-column device?
//- define internal api for protocols
//- config reader
//- irc
//- discord
//- todo list / calendar
//- input box syntax highlighting - GtkSourceView (apt libgtksourceview-3.0-dev)? seems to support tab completion too

#include <gtk/gtk.h>

#if !GTK_CHECK_VERSION(3,16,0)
//this is somewhat glitchy (textview works fine, but channel list gets scrollbar), but there's no better option for old gtks
#define GTK_POLICY_EXTERNAL GTK_POLICY_AUTOMATIC
#endif


class widget_gtk : public widget_base { WIDGET_BASE
public:
	widget_gtk(uint8_t widthprio, uint8_t heightprio, GtkWidget* widget)
	{
		this->widget = widget;
		this->widthprio = widthprio;
		this->heightprio = heightprio;
	}
};
#define widget_create_gtk(...) (new widget_gtk(__VA_ARGS__))

GtkWidget* gtk_wrap_scroll(GtkPolicyType horz, GtkPolicyType vert, GtkWidget* child)
{
	GtkScrolledWindow* scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	gtk_scrolled_window_set_policy(scrollview, horz, vert);
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), child);
	return GTK_WIDGET(scrollview);
}

GtkWidget* gtk_wrap_minsize(int x, int y, GtkWidget* widget)
{
	gtk_widget_set_size_request(widget, x, y);
	return widget;
}

textview::buffer* make_textbuf(textview* text, size_t n)
{
	textview::buffer* buf = text->child();
	
	static textview::image* img = NULL;
	if (!img)
	{
		static const uint8_t bytes[] = {
			0x47,0x49,0x46,0x38,0x39,0x61,0x10,0x00,0x10,0x00,0xf2,0x00,0x00,0x00,0x00,0x00,
			0x8c,0x59,0x18,0xde,0xa2,0x39,0xff,0xfb,0x00,0xff,0xdb,0x21,0xef,0xf3,0xff,0x00,
			0x00,0x00,0x00,0x00,0x00,0x21,0xf9,0x04,0x01,0x00,0x00,0x06,0x00,0x2c,0x00,0x00,
			0x00,0x00,0x10,0x00,0x10,0x00,0x00,0x03,0x45,0x08,0xb6,0xdc,0x0d,0xd0,0x49,0x03,
			0x41,0x51,0x73,0x59,0x78,0xb1,0xdc,0xd0,0x50,0x7d,0x62,0x04,0x94,0x1e,0x85,0x6a,
			0x44,0x85,0x01,0xed,0xc8,0xba,0xb0,0xfb,0xd0,0xb8,0x83,0xdb,0xdf,0xee,0x04,0x40,
			0x8d,0x0c,0x18,0x30,0x04,0x06,0x03,0x42,0xf1,0xd4,0x32,0x12,0x90,0xc5,0x00,0x41,
			0xa0,0x94,0x56,0xa7,0x4a,0x06,0x11,0x8b,0x25,0x4e,0x88,0xde,0x46,0x02,0x00,0x3b
		};
		img = new textview::image(bytes, 16, 16);
	}
	
	textview::span msgparts[3];
	msgparts[0].text = "mun";
	msgparts[1].img = img;
	msgparts[1].text = "https://floating.muncher.se/muncher.png";
	msgparts[2].text = "cher";
	
	while (n--) buf->message(NULL, 0, msgparts);
	
	return buf;
}


int main(int argc, char * argv[])
{
	window_init(&argc, &argv);
	
	static textview* text = textview::create();
	static textview::buffer* active;
	
	chanview* chans = chanview::create();
	chans->onfocus([](void* userdata){ active = (textview::buffer*)userdata; text->set_buf(active); });
	chanview::guild*   chan1 = chans->child("1 Muncher",  make_textbuf(text, 1));
	chanview::channel* chan2 = chan1->child("2 Munchers", make_textbuf(text, 2));
	chanview::guild*   chan3 = chans->child("3 Munchers", make_textbuf(text, 3));
	
	static widget_textbox* input;
	
	window* wnd = window_create(
		widget_create_layout_horz(
			widget_create_gtk(3, 4,
				gtk_wrap_minsize(60, 0,
					gtk_wrap_scroll(GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC,
						chans->gtkwidget()
					)
				)
			),
			widget_create_layout_vert(
				widget_create_gtk(4, 4,
					//I'd rather have NEVER than this one, but that makes textview refuse to shrink if that would change word wrapping
					gtk_wrap_scroll(GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC,
						GTK_WIDGET(text->gtkwidget())
					)
				),
				//widget_create_gtk(4, 1,
				//	gtk_wrap_scroll(GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC,
				//		GTK_WIDGET(text->gtkwidget())
				//	)
				//)
				input = widget_create_textbox()
					->set_onactivate([](cstring text)
						{
							if (!text) return;
							
							textview::span msg[1];
							msg[0].text = text;
							active->message("", 0, msg);
							
							input->set_text("");
						}
					)
					->focus()
			)
		)
	);
	
	
	wnd->set_visible(true);
	wnd->set_resizable(true, NULL);
	wnd->set_title("ЯUSSIAN MALWДRE");
	wnd->resize(571, 665);
	
	wnd->set_onclose(&window::exit_runloop);
	
	//runloop::global()->set_fd(0, do_stdin);
	runloop::global()->enter();
	
	delete wnd;
}
