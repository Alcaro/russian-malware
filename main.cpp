#include "russian.h"

#ifndef ARGUI_NONE
#ifndef ARGUI_GTK3
#error gtk only
#endif

//todo list

//high prio:
//- tab complete
//    use https://developer.gnome.org/gtk3/stable/GtkOverlay.html on textview to show color/etc hints
//- global commands
//    /in, /1w
//    /ar (via cgi, uses a temp message to the current channel even if cross-group)
//- highlights
//- shift-click closes channel
//- keeping state - either find a way to nondestructively parse and edit the config, or a separate file
//- figure out which features I actually need

//medium prio:
//- todo-list server
//- channel temperature meter, tells how many messages happened in the last 5 minutes
//- input box syntax highlighting
//- user list powerlevels
//- Copy as - IRC | HTML | unformatted | without timestamps | etc

//low prio:
//- message editing leaves a diff, rather than just the old message
//- find or create diff function for the above
//- make channel list a two-column device?
//- track cross-channel messages, like joins
//- irc bouncer
//- figure out how bouncer interacts with the last-read flags
//- sharing activity flags between channels
//- how to edit messages? double click them?
//- topic box

#include <gtk/gtk.h>



namespace russian {

class hintview : nocopy {
public:
	GtkOverlay* overlay;
	
	GtkWidget* main; // main widget
	GtkWidget* sub; // child widget, placed on top of the main widget
	
	int x;
	int main_scrollwidth;
	
	hintview(GtkWidget* main, GtkWidget* sub)
	{
{
GtkTextView* contents = GTK_TEXT_VIEW(gtk_text_view_new());
gtk_text_buffer_insert_at_cursor(gtk_text_view_get_buffer(contents), "floating\nmuncher", -1);
sub = GTK_WIDGET(contents);
}
		this->main = main;
		
		// yes, a GtkScrolledWindow with scrollbar policy NEVER/NEVER is silly, but it's the easiest way to add a border
		// I tried various kinds of css, but border, outline margin and padding didn't seem to do anything when I tried
		// (as a bonus, it's guaranteed to match textview's border)
		GtkScrolledWindow* sub_wrap = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
		gtk_scrolled_window_set_policy(sub_wrap, GTK_POLICY_NEVER, GTK_POLICY_NEVER);
		gtk_scrolled_window_set_shadow_type(sub_wrap, GTK_SHADOW_IN);
		gtk_container_add(GTK_CONTAINER(sub_wrap), sub);
		this->sub = GTK_WIDGET(sub_wrap);
		
		overlay = GTK_OVERLAY(gtk_overlay_new());
		gtk_container_add(GTK_CONTAINER(overlay), main);
		gtk_overlay_add_overlay(overlay, GTK_WIDGET(sub_wrap));
		
		gboolean(*place_child_cb)(GtkOverlay* overlay, GtkWidget* widget, GdkRectangle* allocation, void* user_data) =
		                       [](GtkOverlay* overlay, GtkWidget* widget, GdkRectangle* allocation, void* user_data) -> gboolean
		{
			hintview* this_ = (hintview*)user_data;
			
			GtkRequisition sub_size;
			gtk_widget_get_preferred_size(this_->sub, NULL, &sub_size);
			
			int main_width = gtk_widget_get_allocated_width(this_->main) - this_->main_scrollwidth;
			int main_height = gtk_widget_get_allocated_height(this_->main);
			
			allocation->x = min(this_->x, main_width - sub_size.width);
			allocation->y = main_height - sub_size.height;
			allocation->width = sub_size.width;
			allocation->height = sub_size.height;
			
			return TRUE;
		};
		g_signal_connect(overlay, "get-child-position", G_CALLBACK(place_child_cb), this);
		
		main_scrollwidth = 0;
		if (GTK_IS_SCROLLED_WINDOW(main))
		{
			GtkWidget* scroll = gtk_scrolled_window_get_vscrollbar(GTK_SCROLLED_WINDOW(main));
			if (scroll)
			{
				int width;
				gtk_widget_get_preferred_width(scroll, NULL, &width);
				main_scrollwidth = width;
			}
		}
		
		this->x = 0;
	}
	
	int width()
	{
		return gtk_widget_get_allocated_width(main);
	}
	
	//If x is too high, it's clamped. Negative is undefined behavior.
	void move(int x)
	{
		this->x = x;
		gtk_widget_queue_resize(GTK_WIDGET(overlay));
	}
	
	GtkWidget* gtkwidget() { return (GtkWidget*)overlay; }
};

class impl {
public:
	textview* tv;
	chanview* cv;
	userview* uv;
	inputview* input;
	hintview* hv;
	
	array<protocol*> protos; // useful for debugging, less useful for anything else
	
	int ngroup = 0;
	
	chanbase* cur_chan = NULL;
	
	int x = INT_MAX;
	int y = INT_MAX;
	unsigned width = 0;
	unsigned height = 0;
	
	impl()
	{
		//without this, input view turns super stupid
		//don't know how early it must be set, so do it as fast as possible
		g_object_set(gtk_settings_get_default(), "gtk-enable-animations", false, NULL);
		
		this->tv = textview::create();
		
		this->uv = userview::create();
		uv->onactivate(bind_this(&impl::uv_activate_cb));
		
		this->cv = chanview::create();
		cv->onfocus(bind_this(&impl::cv_focus_cb));
		
		this->input = inputview::create();
		input->set_onactivate(bind_this(&impl::input_cb));
		input->set_onmovecaret(bind_this(&impl::inputmove_cb));
		
		this->hv = new hintview(tv->gtkwidget(), NULL);
		
		bmlunserialize_impl s(file::readall(file::exepath()+"config.txt"));
		
		ser_enter(s)
		{
			//if (s.next() == "discord") ;
			if (s.next() == "irc") protos.append(protocol::create_irc(this, s));
			if (s.next() == "test") protos.append(protocol::create_testp(this, s));
			if (s.next() == "window")
			{
				ser_enter(s)
				{
					s.item("width", width);
					s.item("height", height);
					s.item("x", x);
					s.item("y", y);
				}
			}
		}
		
		GtkGrid* grid = GTK_GRID(gtk_grid_new());
		gtk_widget_set_size_request(cv->gtkwidget(), 60, 0);
		gtk_widget_set_size_request(uv->gtkwidget(), 60, 0);
		gtk_grid_attach(grid, cv->gtkwidget(),    0,0, 1,2);
		gtk_grid_attach(grid, hv->gtkwidget(),    1,0, 1,1);
		gtk_grid_attach(grid, uv->gtkwidget(),    2,0, 1,2);
		gtk_grid_attach(grid, input->gtkwidget(), 1,1, 1,1);
		
		//gtk_widget_set_hexpand(GTK_WIDGET(overlay), true);
		//gtk_widget_set_vexpand(GTK_WIDGET(overlay), true);
		
		gtk_widget_set_hexpand(tv->gtkwidget(), true);
		gtk_widget_set_hexpand(input->gtkwidget(), true);
		gtk_widget_set_vexpand(cv->gtkwidget(), true);
		gtk_widget_set_vexpand(tv->gtkwidget(), true);
		gtk_widget_set_vexpand(uv->gtkwidget(), true);
		
		GtkWindow* wnd = GTK_WINDOW(gtk_window_new(GTK_WINDOW_TOPLEVEL));
		gtk_container_add(GTK_CONTAINER(wnd), GTK_WIDGET(grid));
		gtk_window_set_resizable(wnd, true);
		gtk_window_set_title(wnd, APPNAME);
		if (width && height) gtk_window_resize(wnd, width, height);
		
		//extra variable because I don't trust G_CALLBACK to do anything sensible with a lambda
		gboolean(*onclose_cb)(GtkWidget* widget, GdkEvent* event, void* user_data) =
		                   [](GtkWidget* widget, GdkEvent* event, void* user_data) -> gboolean
		{
			runloop::global()->exit();
			gtk_widget_hide(widget);
			return GDK_EVENT_STOP;
		};
		g_signal_connect(wnd, "delete-event", G_CALLBACK(onclose_cb), this);
		
		gboolean(*onkb_gtk)(GtkWidget* widget, GdkEventKey* event, void* user_data) =
		                 [](GtkWidget* widget, GdkEventKey* event, void* user_data) -> gboolean
		{
			//this doesn't seem needed
			//if (gtk_text_view_im_context_filter_keypress(this_->view, event))
			//{
			//	return GDK_EVENT_STOP;
			//}
			
			//TODO: make this conditional on which widget is currently focused, topic box doesn't want input stolen
			impl* this_ = (impl*)user_data;
			
			GdkModifierType mods = (GdkModifierType)(event->state & (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_MOD1_MASK));
			
			if (event->keyval == GDK_KEY_Page_Up || event->keyval == GDK_KEY_Page_Down)
			{
				if (mods == 0)
				{
					this_->tv->do_scroll(event);
					return GDK_EVENT_STOP;
				}
				if (mods == GDK_CONTROL_MASK)
				{
					this_->cv->move_focus((event->keyval == GDK_KEY_Page_Up) ? -1 : 1);
					return GDK_EVENT_STOP;
				}
			}
			
			//anything that affects the input widget must cause a refocus
			//that includes, but is not limited to:
			//- printables
			//- backspace, delete
			//- ctrl-v, formatting
			//- ctrl-shift-u
			//- navigation (up, down, left, right, home, end)
			//however, ctrl-c (including the ctrl) must stay on the focus widget
			//
			//this one refocuses if it detects any of the above, not otherwise; it could be made more aggressive if desired
			
			bool to_input = false;
			
			if (gdk_keyval_to_unicode(event->keyval) != 0 || // oddly enough, this can report backspace/delete too
				event->keyval == GDK_KEY_Up || event->keyval == GDK_KEY_Down ||
				event->keyval == GDK_KEY_Left || event->keyval == GDK_KEY_Right ||
				event->keyval == GDK_KEY_Home || event->keyval == GDK_KEY_End ||
				false)
			{
				to_input = true;
			}
			
			if (event->state & (GDK_CONTROL_MASK | GDK_MOD1_MASK))
			{
				to_input = false;
			}
			if ((event->state & GDK_CONTROL_MASK) && strchr("bkuiovU", event->keyval))
			{
				to_input = true;
			}
			
			if (to_input)
			{
				this_->input->grab_focus();
			}
			
			return GDK_EVENT_PROPAGATE;
		};
		g_signal_connect(wnd, "key-press-event", G_CALLBACK(onkb_gtk), this);
		
		gboolean(*any_event)(GtkWidget* widget, GdkEvent* event, void* user_data) =
						  [](GtkWidget* widget, GdkEvent* event, void* user_data) -> gboolean
		{
			((textview*)user_data)->user_input(event->type);
			return GDK_EVENT_PROPAGATE;
		};
		g_signal_connect(wnd, "event", G_CALLBACK(any_event), this->tv);
		
		gtk_widget_show_all(GTK_WIDGET(wnd));
		if (cur_chan->flags & chanbase::f_no_users)
			gtk_widget_hide(uv->gtkwidget());
		
		if (x != INT_MAX && y != INT_MAX) gdk_window_move(gtk_widget_get_window(GTK_WIDGET(wnd)), x, y);
		input->grab_focus();
		
		runloop::global()->enter();
		
		for (protocol* proto : protos)
		{
			delete proto;
		}
		protos.reset();
		
		exit(0); // make sure various pointers are still live on the stack, so they don't look like memory leaks
	}
	
	void cv_focus_cb(void* userdata)
	{
		chanbase* new_chan = (chanbase*)userdata;
		new_chan->pgroup->last_focus = new_chan;
		
		if (this->cur_chan)
		{
			input->store_get(&this->cur_chan->inputst);
		}
		
		this->cur_chan = new_chan;
		tv->set_buf(cur_chan->buf);
		
		input->store_set(&this->cur_chan->inputst);
		if (!(cur_chan->flags & chanbase::f_no_users))
		{
			uv->bind(this->cur_chan->userdat);
			gtk_widget_show(uv->gtkwidget());
		}
		else
		{
			gtk_widget_hide(uv->gtkwidget());
		}
		
		//can be NULL during object construction
		if (this->cur_chan->cvb)
		{
			this->cur_chan->cvb_imp = chanbase::imp_none;
			this->cur_chan->cvb->color(-1);
		}
	}
	void input_cb(cstring text)
	{
		if (!text) return;
		cur_chan->parent->action(text, cur_chan->userdata);
	}
	void inputmove_cb(int x)
	{
		hv->move(x);
	}
	void uv_activate_cb(cstring name)
	{
		cur_chan->parent->begin_private(name);
	}
};

group::group(protocol* parent, cstring name, uint32_t flags, void* userdata)
	: chanbase(parent, this, name, flags, userdata), last_focus(this)
{
	// keep this seemingly-pointless assignment, cv_focus_cb can get called by this chanview->child call
	cvb = NULL;
	cvb = parent->parent->cv->child(name, !(flags&f_no_focus), this);
	
	cvb->sort_as(parent->parent->ngroup++, "");
}
channel::channel(protocol* parent, group* pgroup, chanview::group* pchan, cstring name, uint32_t flags, void* userdata)
	: chanbase(parent, pgroup, name, flags, userdata)
{
	cvb = NULL;
	cvb = pchan->child(name, !(flags&f_no_focus), this);
}
static string readlines(file& logfile, size_t& lines)
{
	string text = logfile.read(logfile.size());
	size_t start = text.length();
	if (!start) return "";
	start--; // the file always ends with a \n, no need to include it
	while (start > 0)
	{
		if (text[start] == '\n')
		{
			lines--;
			if (lines == 0)
			{
				start++;
				break;
			}
		}
		start--;
	}
	return text.substr(start, ~0);
}
chanbase::chanbase(protocol* parent, group* pgroup, cstring name, uint32_t flags, void* userdata)
	: parent(parent), pgroup(pgroup), userdata(userdata), name(name)
{
	if (flags&f_no_focus)
	{
		flags |= f_no_logs|f_no_users;
	}
	this->flags = flags;
	
	for (size_t i=0;i<name.length();i++)
	{
		if (name[i] == '/') {}
		else if (name[i] == '.' && !name_fn) {}
		else name_fn += name[i];
	}
	
	string scrollback = "";
	
	if (!(flags&f_no_logs))
	{
		time_t now = time(NULL);
		log_open(logfile, now, true);
		logrotate = month_next(now);
		
		size_t linesleft = 100;
		scrollback = readlines(logfile, linesleft);
		if (linesleft)
		{
			file prev;
			log_open(prev, month_prev(now), false);
			if (prev) scrollback = readlines(prev, linesleft)+scrollback;
		}
	}
	
	buf = parent->parent->tv->child(scrollback);
}

time_t chanbase::month_prev(time_t t)
{
	struct tm stm;
	localtime_r(&t, &stm);
	
	stm.tm_sec = 0;
	stm.tm_min = 0;
	stm.tm_hour = 0;
	stm.tm_mday = 1;
	if (stm.tm_mon == 0)
	{
		stm.tm_year--;
		stm.tm_mon = 12;
	}
	stm.tm_mon--;
	
	return mktime(&stm);
}
time_t chanbase::month_start(time_t t)
{
	struct tm stm;
	localtime_r(&t, &stm);
	
	stm.tm_sec = 0;
	stm.tm_min = 0;
	stm.tm_hour = 0;
	stm.tm_mday = 1;
	
	return mktime(&stm);
}
time_t chanbase::month_next(time_t t)
{
	struct tm stm;
	localtime_r(&t, &stm);
	
	stm.tm_sec = 0;
	stm.tm_min = 0;
	stm.tm_hour = 0;
	stm.tm_mday = 1;
	stm.tm_mon++;
	if (stm.tm_mon == 12)
	{
		stm.tm_year++;
		stm.tm_mon = 0;
	}
	
	return mktime(&stm);
}
static string timestr(time_t at)
{
	char buf[128];
	strftime(buf, sizeof(buf), "%H:%M:%S", localtime(&at));
	return buf;
}
#define MKSPANS_NUM 3 // mkspans inserts this many spans before 'bodyspans'.
static array<span> mkspans(time_t at, arrayview<span> bodyspans)
{
	array<span> spans;
	if (bodyspans)
	{
		span headspans[] = {
			{ "[" },
			{ timestr(at) },
			{ "] " },
		};
		static_assert(ARRAY_SIZE(headspans) == MKSPANS_NUM);
		spans = headspans;
		spans += bodyspans;
	}
	return spans;
}
void chanbase::log_open(file& f, time_t at, bool create) const
{
	file::mkdir(file::exepath()+"logs/");
	file::mkdir(file::exepath()+"logs/"+pgroup->name_fn+"/");
	
	struct tm stm;
	localtime_r(&at, &stm);
	
	char timebuf[64];
	strftime(timebuf, sizeof(timebuf), " %Y-%m", &stm);
	f.open(file::exepath()+"logs/"+pgroup->name_fn+"/"+name_fn+timebuf+".log", create ? file::m_write : file::m_read);
}
void chanbase::log(time_t at, arrayview<span> spans)
{
	if (!logfile) return;
	
	struct tm stm;
	localtime_r(&at, &stm);
	
	time_t now = time(NULL);
	if (now >= logrotate)
	{
		log_open(logfile, now, true);
		logrotate = month_next(now);
	}
	
	char timebuf[64];
	strftime(timebuf, sizeof(timebuf), "[%Y-%m-%d %H:%M:%S] ", &stm);
	string tmp = timebuf;
	for (size_t i=0;i<spans.size();i++) tmp += spans[i].text;
	tmp += "\n";
	
	logfile.write(tmp);
}
void chanbase::message(cstring id, importance_t imp, time_t at, arrayview<span> bodyspans)
{
	if (this->parent->parent->cur_chan != this)
	{
		cvb_imp = max(cvb_imp, imp);
		static const uint32_t colors[] = { (uint32_t)-1, 0x990000, 0xFF0000, 0x00C0FF };
		cvb->color(colors[cvb_imp]);
	}
	
	array<span> spans = mkspans(at, bodyspans);
	buf->message(id, spans);
	log(at, bodyspans);
}
void chanbase::message_edit(cstring id, time_t at, arrayview<span> bodyspans, unsigned editslot)
{
	array<span> spans = mkspans(at, bodyspans);
	if (buf->message_exists(id))
	{
		buf->message_edit_visible(id, spans);
	}
	else
	{
		spans[MKSPANS_NUM + editslot].text = "EDIT: ";
		buf->message(id, spans);
	}
	log(at, spans.skip(MKSPANS_NUM));
}
void chanbase::message_delete(cstring id, time_t at)
{
	if (buf->message_exists(id))
		buf->message_edit_visible(id, NULL);
}
void chanbase::message_delete_true(cstring id)
{
	if (buf->message_exists(id))
		buf->message_delete(id);
}
void group::message_temp(importance_t imp, time_t at, arrayview<span> bodyspans)
{
	if (this->parent->parent->cur_chan != this->last_focus)
	{
		last_focus->cvb_imp = max(last_focus->cvb_imp, imp);
		static const uint32_t colors[] = { (uint32_t)-1, 0x990000, 0xFF0000, 0x00C0FF };
		last_focus->cvb->color(colors[last_focus->cvb_imp]);
	}
	
	array<span> spans = mkspans(at, bodyspans);
	last_focus->buf->message("", spans);
}

}
#endif


int main(int argc, char** argv)
{
	string ircbouncer;
	
	argparse args;
	args.add("ircbouncer", &ircbouncer);
	
	args.add_cli();
	
	arlib_init(args, argv);
	
	if (ircbouncer)
	{
		russian::do_irc_bouncer(ircbouncer);
		return 0;
	}
	
#ifndef ARGUI_NONE
	if (args.has_gui())
	{
		new russian::impl();
		return 0;
	}
#endif
	puts("russian: GUI not enabled and no alternative mode of operation specified");
	return 1;
}
