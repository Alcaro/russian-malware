#include "arlib.h"

#ifndef ARGUI_GTK3
#error gtk only
#endif

#include <gtk/gtk.h>

//a selection bound may not lie between a GdkPixbuf and the alt-text tag, or inside the tag
// if it does, it must be put on the far side of the image
//since the alt-text tag always lies to the right of the image, this simplifies to
// 'if a selection bound points inside, or to the start of, an alt-ext tag, move it to the end of said tag'
//which further simplifies to 'if the pointed-to character is inside the tag, move to the tag end'
GtkTextIter img_alt_adjusted_iter_from_mark(GtkTextBuffer* buffer,
                                  GtkTextMark* mark,
                                  GtkTextTag* tag,
                                  bool* do_move)
{
	GtkTextIter ret;
	gtk_text_buffer_get_iter_at_mark(buffer, &ret, mark);
	if (gtk_text_iter_has_tag(&ret, tag))
	{
		*do_move = true;
		gtk_text_iter_forward_to_tag_toggle(&ret, tag);
	}
	return ret;
}

void img_alt_update_selection(GtkTextBuffer* buffer, GtkTextTag* tag)
{
	bool do_move = false;
	GtkTextIter insert = img_alt_adjusted_iter_from_mark(buffer, gtk_text_buffer_get_insert(         buffer), tag, &do_move);
	GtkTextIter sbound = img_alt_adjusted_iter_from_mark(buffer, gtk_text_buffer_get_selection_bound(buffer), tag, &do_move);
	
	if (do_move)
	{
		gtk_text_buffer_select_range(buffer, &insert, &sbound);
	}
}

void img_alt_on_select(GObject* gobject, GParamSpec* pspec, gpointer user_data)
{
	img_alt_update_selection(GTK_TEXT_BUFFER(gobject), GTK_TEXT_TAG(user_data));
}

GtkTextTag* img_alt_init(GtkTextBuffer* buffer)
{
	GtkTextTag* tag = gtk_text_tag_new("select-only");
	g_object_set(tag, "scale", (gdouble)0.5, NULL);
	gtk_text_tag_table_add(gtk_text_buffer_get_tag_table(buffer), tag);
	
	//this doesn't do anything if selection-bound moves without cursor moving, but as far as I've seen,
	// user can't move it to any place other than 'right where main cursor is' which is always a valid position
	//(okay, code can move it, but it won't.)
	g_signal_connect(buffer, "notify::cursor-position", G_CALLBACK(img_alt_on_select), tag);
	return tag;
}

void gtk_text_buffer_insert_pixbuf_with_alt(
              GtkTextBuffer* buffer, GtkTextIter* iter, GdkPixbuf* pixbuf, const gchar * text, gint len)
{
	GtkTextTag* tag = gtk_text_tag_table_lookup(gtk_text_buffer_get_tag_table(buffer), "select-only");
	if (!tag) tag = img_alt_init(buffer);
	
	gtk_text_buffer_insert_pixbuf(buffer, iter, pixbuf);
	gtk_text_buffer_insert_with_tags(buffer, iter, text, len, tag, NULL);
}





class widget_gtk : public widget_base { WIDGET_BASE
public:
	widget_gtk(GtkWidget* widget, uint8_t widthprio, uint8_t heightprio)
	{
		this->widget = widget;
		this->widthprio = widthprio;
		this->heightprio = heightprio;
	}
};
#define widget_create_gtk(...) (new widget_gtk(__VA_ARGS__))

GtkTextView* textview;
GtkTextBuffer* textbuf;
GtkTextTagTable* texttags;
GtkTextTag* texttag_imgalt;

void do_stdin(uintptr_t fd)
{
	char line[4096];
	size_t len = read(fd, line, 4095);
	if (len > 0 && line[len-1] == '\n') len--;
	line[len] = '\0';
	
	GtkTextIter pos;
	
	array<byte> bytes = file::read(line);
	GInputStream* is = g_memory_input_stream_new_from_data(bytes.ptr(), bytes.size(), NULL);
	GdkPixbuf* pix = gdk_pixbuf_new_from_stream_at_scale(is, 16, 16, true, NULL, NULL);
	
	gtk_text_buffer_get_selection_bounds(textbuf, &pos, NULL);
	gtk_text_buffer_insert_pixbuf_with_alt(textbuf, &pos, pix, line, -1);
	
	g_object_unref(is);
	g_object_unref(pix);
}

int main(int argc, char * argv[])
{
	window_init(&argc, &argv);
	
	texttags = gtk_text_tag_table_new();
	textbuf = gtk_text_buffer_new(texttags);
	textview = GTK_TEXT_VIEW(gtk_text_view_new_with_buffer(textbuf));
	
	gtk_text_view_set_wrap_mode(textview, GTK_WRAP_WORD_CHAR);
	GtkScrolledWindow* scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	//I don't want AUTOMATIC horizontal policy, I want NEVER
	//but without it, the textview refuses to shrink the window if that would change word wrapping
	//I probably want EXTERNAL, but it only exists since 3.16, Ubuntu 14.04 has 3.10
	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrollview), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(textview));
	
	window* wnd = window_create(
		widget_create_layout_horz(
			widget_create_layout_vert(
				widget_create_gtk(GTK_WIDGET(scrollview), 4, 4),
				widget_create_textbox()
			)
		)
	);
	
	
	wnd->set_visible(true);
	wnd->set_resizable(true, NULL);
	wnd->set_title("ЯUSSIAN MALWДRE");
	
	wnd->set_onclose(&window::exit_runloop);
	
	runloop::global()->set_fd(0, do_stdin);
	runloop::global()->enter();
	
	delete wnd;
}
