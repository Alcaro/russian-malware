#include "arlib.h"
#include "russian.h"

#ifndef ARGUI_GTK3
#error gtk only
#endif

#define DEBUG_TEXTVIEW 1

#include <gtk/gtk.h>

#if !GTK_CHECK_VERSION(3,16,0)
#define GTK_POLICY_EXTERNAL GTK_POLICY_AUTOMATIC
#endif

class textview {
	GtkTextView* view;
	GtkTextTagTable* tags;
	
	GtkTextTag* t_imgalt;
	
	textview()
	{
		tags = gtk_text_tag_table_new();
		view = GTK_TEXT_VIEW(gtk_text_view_new());
		
		gtk_text_view_set_wrap_mode(view, GTK_WRAP_WORD_CHAR);
		
#if !DEBUG_TEXTVIEW
		//known bugs if not readonly:
		//- backspacing images removes the alt-text, one character at the time
		//- left arrow has no effect if beside an image, you end up back where you started
		//no known bugs in mouse selection
		gtk_text_view_set_editable(view, false);
		gtk_text_view_set_cursor_visible(view, false);
#endif
		
		t_imgalt = gtk_text_tag_new("select-only");
#if DEBUG_TEXTVIEW
		g_object_set(t_imgalt, "scale", (gdouble)0.5, NULL);
#else
		g_object_set(t_imgalt, "scale", (gdouble)0, NULL);
#endif
		gtk_text_tag_table_add(tags, t_imgalt);
	}
	
public:
	class image {
		friend class textview;
		friend class buffer;
		GdkPixbuf* pix;
	public:
		image(arrayview<byte> bytes, size_t width, size_t height)
		{
			GInputStream* is = g_memory_input_stream_new_from_data(bytes.ptr(), bytes.size(), NULL);
			pix = gdk_pixbuf_new_from_stream_at_scale(is, width, height, true, NULL, NULL);
			g_object_unref(is);
		}
		~image()
		{
			g_object_unref(pix);
		}
	};
	struct span {
		string text;
		
		//If this is non-null, 'text' isn't shown. However, it is used; it's the alt-text if copied.
		//However, most other fields do nothing (though bgcol probably works).
		image* img = NULL;
		
		//Hidden text shows up if copied, but isn't normally visible. Use for formatting codes, like IRC's \x02 bold.
		bool hidden = false;
		
		bool bold = false;
		bool underline = false;
		bool italics = false;
		bool strike = false;
		
		static const constexpr uint32_t colors[16] = {
			//rrggbb
			0xcccccc, 0x000000, 0x3535b3, 0x2a8c2a,
			0xd02a2a, 0x6f2828, 0x80267f, 0xdc721d,
			0xd9a641, 0x3dcc3d, 0x195555, 0x27d6c0,
			0x4545e6, 0xda31da, 0x6c6c6c, 0xafafaf,
		};
		uint8_t fgcol = -1;
		uint8_t bgcol = -1;
	};
	class buffer {
		friend class textview;
		textview* parent;
		GtkTextBuffer* buf;
		
		//a selection bound may not lie between a GdkPixbuf and the alt-text tag, or inside the tag
		// if it does, it must be put on the far side of the image
		//since the alt-text tag always lies to the right of the image, this simplifies to
		// 'if a selection bound points inside, or to the start of, an alt-ext tag, move it to the end of said tag'
		//which further simplifies to 'if the pointed-to character is inside the tag, move to after the tag end'
		static GtkTextIter imgalt_get_iter(GtkTextBuffer* buf,
		                                   GtkTextMark* mark,
		                                   GtkTextTag* t_imgalt,
		                                   bool* do_move)
		{
			GtkTextIter ret;
			gtk_text_buffer_get_iter_at_mark(buf, &ret, mark);
			if (gtk_text_iter_has_tag(&ret, t_imgalt))
			{
				*do_move = true;
				gtk_text_iter_forward_to_tag_toggle(&ret, t_imgalt);
			}
			return ret;
		}
		
		static void imgalt_update(GtkTextBuffer* buf, GtkTextTag* t_imgalt)
		{
			bool do_move = false;
			GtkTextIter insert = imgalt_get_iter(buf, gtk_text_buffer_get_insert(         buf), t_imgalt, &do_move);
			GtkTextIter sbound = imgalt_get_iter(buf, gtk_text_buffer_get_selection_bound(buf), t_imgalt, &do_move);
			
			if (do_move)
			{
				gtk_text_buffer_select_range(buf, &insert, &sbound);
			}
		}
		
		static void imgalt_cb(GObject* gobject, GParamSpec* pspec, gpointer user_data)
		{
			imgalt_update(GTK_TEXT_BUFFER(gobject), GTK_TEXT_TAG(user_data));
		}
		
		buffer(textview* parent)
		{
			this->parent = parent;
			this->buf = gtk_text_buffer_new(parent->tags);
			//this doesn't do anything if selection-bound moves without cursor moving, but as far as I've seen,
			// user can't move it to any place other than 'right where main cursor is' which is always a valid position
			//(okay, code can move it, but it won't.)
			g_signal_connect(this->buf, "notify::cursor-position", G_CALLBACK(imgalt_cb), parent->t_imgalt);
		}
		
	public:
		//If 'id' has already been seen, it will be replaced.
		//The message may contain linebreaks, but should not end with one unless you actually want that.
		void message(cstring id, time_t at, arrayview<span> spans)
		{
			//TODO: care about id/at
			
			GtkTextIter iter;
			gtk_text_buffer_get_end_iter(buf, &iter);
			for (size_t i=0;i<spans.size();i++)
			{
				const span& sp = spans[i];
				if (sp.img)
				{
					gtk_text_buffer_insert_pixbuf(buf, &iter, sp.img->pix);
				}
				
				size_t start_offset = gtk_text_iter_get_offset(&iter);
				gtk_text_buffer_insert(buf, &iter, sp.text, sp.text.length());
				
				GtkTextIter start;
				gtk_text_buffer_get_iter_at_offset(buf, &start, start_offset);
				if (sp.img) gtk_text_buffer_apply_tag(buf, parent->t_imgalt, &start, &iter);
				//TODO: check other formats and apply them
			}
			
			gtk_text_buffer_insert(buf, &iter, "\n", 1);
		}
	};
	buffer* child()
	{
		return new buffer(this);
	}
	void set_buf(buffer* buf)
	{
		gtk_text_view_set_buffer(view, buf->buf);
	}
	
	static textview* create()
	{
		return new textview();
	}
	GtkWidget* gtkwidget()
	{
		return GTK_WIDGET(view);
	}
};





class chanview {
	enum {
		col_name,
		col_attr,
		col_userdata,
		col_count
	};
	GtkTreeStore* store;
	GtkTreeView* view;
	
	function<void(void* userdata)> focus_cb;
	
	chanview()
	{
		store = gtk_tree_store_new(3, G_TYPE_STRING, PANGO_TYPE_ATTR_LIST, G_TYPE_POINTER);
		
		view = GTK_TREE_VIEW(gtk_tree_view_new());
		
		GtkTreeViewColumn* col = gtk_tree_view_column_new();
		GtkCellRenderer* renderer = gtk_cell_renderer_text_new();
		gtk_tree_view_append_column(view, col);
		gtk_tree_view_column_pack_start(col, renderer, TRUE);
		gtk_tree_view_column_add_attribute(col, renderer, "text", 0);
		gtk_cell_renderer_text_set_fixed_height_from_font(GTK_CELL_RENDERER_TEXT(renderer), 1);
		
		gtk_tree_view_set_model(view, GTK_TREE_MODEL(store));
		gtk_tree_selection_set_mode(gtk_tree_view_get_selection(view), GTK_SELECTION_BROWSE);
		gtk_tree_view_set_headers_visible(view, false);
		
		gtk_tree_view_set_enable_tree_lines(view, true);
		gtk_tree_view_expand_all(view);
		
		g_signal_connect(G_OBJECT(gtk_tree_view_get_selection(view)), "changed", G_CALLBACK(onfocus_sig_nat), this);
		
		//TODO: do I enable these?
		gtk_tree_view_set_show_expanders(view, false);
		gtk_tree_view_set_level_indentation(view, 19);
		
		//TODO: figure out if this is helpful or annoying
		gtk_tree_view_set_hover_selection(view, true);
	}
	
	
public:
	enum color_t {
		c_none,
		c_low, // someone joined/etc
		c_msg,
		c_highlight
	};
	
private:
	class chanbase : nocopy {
		friend class chanview;
	protected:
		chanview* parent;
		GtkTreeRowReference* row;
		
		chanbase(chanview* parent, GtkTreeRowReference* parentrow, cstring name, void* userdata)
		{
			this->parent = parent;
			
			GtkTreeIter parentiter;
			
			if (parentrow)
			{
				GtkTreePath* path = gtk_tree_row_reference_get_path(parentrow);
				gtk_tree_model_get_iter(GTK_TREE_MODEL(parent->store), &parentiter, path);
				gtk_tree_path_free(path);
			}
			
			GtkTreeIter iter;
			gtk_tree_store_append(parent->store, &iter, parentrow ? &parentiter : NULL);
			gtk_tree_store_set(parent->store, &iter,
			                   col_name, (const char*)name.c_str(),
			                   col_userdata, userdata,
			                   -1);
			
			GtkTreePath* path = gtk_tree_model_get_path(GTK_TREE_MODEL(parent->store), &iter);
			this->row = gtk_tree_row_reference_new(GTK_TREE_MODEL(parent->store), path);
			gtk_tree_view_expand_to_path(parent->view, path);
			gtk_tree_path_free(path);
		}
		
	public:
		void color();
		//if the notification is dismissed in one of these channels, they all turn black
		static void color(arrayview<chanbase> group);
		
	protected:
		~chanbase() {} // TODO
	};
	
public:
	class channel : public chanbase {
		friend class chanview;
		channel(chanview* parent, GtkTreeRowReference* parentrow, cstring name, void* userdata) : chanbase(parent, parentrow, name, userdata) {}
		
	public:
		
		~channel() {} // TODO
	};
	
	//'Guild' is a stupid name for IRC, but calling it Server on Discord is even dumber, and they need the same name.
	//IRC has an irritating mix between Server/Network, anyways, so neither of those names is fully appropriate.
	class guild : public chanbase {
		friend class chanview;
		guild(chanview* parent, GtkTreeRowReference* parentrow, cstring name, void* userdata) : chanbase(parent, parentrow, name, userdata) {}
		
	public:
		channel* child(cstring name, void* userdata)
		{
			return new channel(parent, row, name, userdata);
		}
		
		~guild() {} // TODO
	};
	
	static chanview* create()
	{
		return new chanview();
	}
	GtkWidget* gtkwidget()
	{
		return GTK_WIDGET(view);
	}
	
private:
	static void onfocus_sig_nat(GtkTreeSelection* sel, void* userdata)
	{
		chanview* this_ = (chanview*)userdata;
		this_->onfocus_sig(sel);
	}
	void onfocus_sig(GtkTreeSelection* sel)
	{
		GtkTreeModel* model;
		GtkTreeIter iter;
		
		if (gtk_tree_selection_get_selected(sel, &model, &iter))
		{
			void* userdata;
			gtk_tree_model_get(model, &iter, col_userdata, &userdata, -1);
			this->focus_cb(userdata);
		}
	}
public:
	//There's only one onfocus function per channel view object, but the userdata can vary per guild/channel.
	void onfocus(function<void(void* userdata)> callback)
	{
		focus_cb = callback;
	}
	
	//If userdata is NULL, the guild root can't be focused. Use if there is no obvious equivalent of IRC's server tab.
	guild* child(cstring name, void* userdata)
	{
		return new guild(this, NULL, name, userdata);
	}
	
	~chanview() {} // TODO
};





class widget_gtk : public widget_base { WIDGET_BASE
public:
	widget_gtk(uint8_t widthprio, uint8_t heightprio, GtkWidget* widget)
	{
		this->widget = widget;
		this->widthprio = widthprio;
		this->heightprio = heightprio;
	}
};
#define widget_create_gtk(...) (new widget_gtk(__VA_ARGS__))

GtkWidget* gtk_wrap_scroll(GtkPolicyType horz, GtkPolicyType vert, GtkWidget* child)
{
	GtkScrolledWindow* scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	gtk_scrolled_window_set_policy(scrollview, horz, vert);
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), child);
	return GTK_WIDGET(scrollview);
}

GtkWidget* gtk_wrap_minsize(int x, int y, GtkWidget* widget)
{
	gtk_widget_set_size_request(widget, x, y);
	return widget;
}

textview::buffer* make_textbuf(textview* text, size_t n)
{
	textview::buffer* buf = text->child();
	
	static textview::image* img = NULL;
	if (!img)
	{
		static const uint8_t bytes[] = {
			0x47,0x49,0x46,0x38,0x39,0x61,0x10,0x00,0x10,0x00,0xf2,0x00,0x00,0x00,0x00,0x00,
			0x8c,0x59,0x18,0xde,0xa2,0x39,0xff,0xfb,0x00,0xff,0xdb,0x21,0xef,0xf3,0xff,0x00,
			0x00,0x00,0x00,0x00,0x00,0x21,0xf9,0x04,0x01,0x00,0x00,0x06,0x00,0x2c,0x00,0x00,
			0x00,0x00,0x10,0x00,0x10,0x00,0x00,0x03,0x45,0x08,0xb6,0xdc,0x0d,0xd0,0x49,0x03,
			0x41,0x51,0x73,0x59,0x78,0xb1,0xdc,0xd0,0x50,0x7d,0x62,0x04,0x94,0x1e,0x85,0x6a,
			0x44,0x85,0x01,0xed,0xc8,0xba,0xb0,0xfb,0xd0,0xb8,0x83,0xdb,0xdf,0xee,0x04,0x40,
			0x8d,0x0c,0x18,0x30,0x04,0x06,0x03,0x42,0xf1,0xd4,0x32,0x12,0x90,0xc5,0x00,0x41,
			0xa0,0x94,0x56,0xa7,0x4a,0x06,0x11,0x8b,0x25,0x4e,0x88,0xde,0x46,0x02,0x00,0x3b
		};
		img = new textview::image(bytes, 16, 16);
	}
	
	textview::span msgparts[3];
	msgparts[0].text = "mun";
	msgparts[1].img = img;
	msgparts[1].text = "https://floating.muncher.se/muncher.png";
	msgparts[2].text = "cher";
	
	while (n--) buf->message(NULL, 0, msgparts);
	
	return buf;
}


int main(int argc, char * argv[])
{
	window_init(&argc, &argv);
	
	static textview* text = textview::create();
	
	chanview* chans = chanview::create();
	chanview::guild*   chan1 = chans->child("1 Muncher",  make_textbuf(text, 1));
	chanview::channel* chan2 = chan1->child("2 Munchers", make_textbuf(text, 2));
	chanview::guild*   chan3 = chans->child("3 Munchers", make_textbuf(text, 3));
	chans->onfocus([](void* userdata){ text->set_buf((textview::buffer*)userdata); });
	
	window* wnd = window_create(
		widget_create_layout_horz(
			widget_create_gtk(3, 4,
				gtk_wrap_minsize(60, 0,
					gtk_wrap_scroll(GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC,
						chans->gtkwidget()
					)
				)
			),
			widget_create_layout_vert(
				widget_create_gtk(4, 4,
					//I'd rather have NEVER than this one, but that makes textview refuse to shrink if that would change word wrapping
					gtk_wrap_scroll(GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC,
						GTK_WIDGET(text->gtkwidget())
					)
				),
				widget_create_textbox()
			)
		)
	);
	
	
	wnd->set_visible(true);
	wnd->set_resizable(true, NULL);
	wnd->set_title("ЯUSSIAN MALWДRE");
	wnd->resize(571, 665);
	
	wnd->set_onclose(&window::exit_runloop);
	
	//runloop::global()->set_fd(0, do_stdin);
	runloop::global()->enter();
	
	delete wnd;
}
