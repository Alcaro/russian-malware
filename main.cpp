#include "russian.h"

#ifndef ARGUI_NONE
#ifndef ARGUI_GTK3
#error gtk only
#endif

//todo list

//high prio:
//- join, quit, part, kick

//medium prio:
//- bouncer
//- figure out how bouncer interacts with the last-read flags
//- sharing activity flags between channels
//- tab complete
//- channel temperature meter, tells how many messages happened in the last 5 minutes

//output box:
//X find suitable textview
//X add textview
//X preserve scroll position
//    with a bool 'atBottom' which can only be changed by explicit user action, not resize
//    if false, flag channel as having activity
//X message editing
//- message editing leaves a diff, rather than just the old message
//- find or create diff function for the above
//X lose focus on any input, except ctrl-c; forward events to input box
//    gtk_widget_event(GtkWidget* widget, GdkEvent* event)
//  alternatively, pass ctrl-c on input box to output box if there's no selection
//    on signal GtkTextView copy-clipboard on inputview:
//      if not gtk_text_buffer_get_selection_bounds(gtk_text_view_get_buffer(inputview), NULL, NULL):
//        GtkClipboard* clipboard = gtk_widget_get_clipboard(GTK_WIDGET(outputview), GDK_SELECTION_CLIPBOARD);
//        gtk_text_buffer_copy_clipboard(gtk_text_view_get_buffer(outputview), clipboard);

//channel list:
//X add channel list
//- make channel list a two-column device?
//X track activity (including cross-channel messages, like joins)
//- track cross-channel messages, like joins
//- lose focus
//X wheel should switch channel, not scroll
//- channel temperature meter, tells how many messages happened in the last 5 minutes

//input box:
//X make input box work
//- make input box a separate source file, it's about as complex as the other two widgets
//X make input box multiline
//- input box syntax highlighting
//- keyboard input - tab
//X keyboard input - IRC formatting
//- keyboard input - IRC formatting only on IRC
//X keyboard input - up/down (repeat line)
//- keyboard input - shift-enter after up/down to edit
//    or double click a message?
//X keyboard input - pgup/pgdn (scroll outbox)
//X keyboard input - ctrl-pgup/dn (switch channel)
//X preserve input per channel, including cursor position

//protocols:
//X define internal api for protocols
//X irc
//- irc bouncer - connecting
//- irc bouncer - the actual stuff
//- discord
//- todo list

//misc:
//X make runloop support sockets
//X make runloop support timeouts
//X make every socket user use new poller mechanism
//X config reader
//- userlist?
//- topic?
//- port to Qt because Gtk is a nyarglebargle?

#include <gtk/gtk.h>

#if !GTK_CHECK_VERSION(3,16,0)
//this is somewhat glitchy (textview works fine, but channel list gets scrollbar), but there's no better option for old gtks
#define GTK_POLICY_EXTERNAL GTK_POLICY_AUTOMATIC
#endif


namespace russian {
class inputview {
#if GTK_CHECK_VERSION(3,22,0)
	GtkScrolledWindow* scrollview;
#endif
	GtkTextView* view;
	
	function<void(cstring text)> onactivate;
	function<void(GdkEventKey* event)> onscroll;
	function<void(int dir)> onswitchfocus;
	
public:
	static inputview* create() { return new inputview; }
	inputview()
	{
		view = GTK_TEXT_VIEW(gtk_text_view_new());
		gtk_text_view_set_wrap_mode(view, GTK_WRAP_WORD_CHAR);
		
		g_signal_connect(view, "key-press-event", G_CALLBACK(inputview::onkeydown_nat), this);
		//could fiddle with signal "move-cursor" to allow messing with keybindings
		//but on the other hand, this program is designed for exactly one user, who says hardcoding pgup/pgdn is fine
		
		gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_LEFT, 4);
		gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_RIGHT, 4);
		gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_TOP, 4);
		gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_BOTTOM, 4);
		
#if GTK_CHECK_VERSION(3,22,0)
		scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
		gtk_scrolled_window_set_policy(scrollview, GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC);
		gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
		gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(view));
		
		gtk_scrolled_window_set_propagate_natural_height(scrollview, true);
		gtk_scrolled_window_set_max_content_height(scrollview, 150);
#endif
	}
	static bool onkeydown_nat(GtkWidget* widget, GdkEventKey* event, gpointer user_data)
	{
		inputview* obj = (inputview*)user_data;
		if (gtk_text_view_im_context_filter_keypress(obj->view, event))
		{
			return true;
		}
		
		GdkModifierType mods = (GdkModifierType)(event->state & (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_MOD1_MASK));
		
		if (mods == GDK_CONTROL_MASK)
		{
			const char * add = NULL;
			if (event->keyval == 'b') add = "\x02";
			if (event->keyval == 'k') add = "\x03";
			if (event->keyval == 'u') add = "\x1F";
			if (event->keyval == 'i') add = "\x1D";
			if (event->keyval == 'o') add = "\x0F";
			if (add) { gtk_text_buffer_insert_at_cursor(gtk_text_view_get_buffer(obj->view), add, -1); return TRUE; }
		}
		
		if (event->keyval == GDK_KEY_Return)
		{
			GtkTextBuffer* buf = gtk_text_view_get_buffer(obj->view);
			
			gchar* text;
			g_object_get(buf, "text", &text, NULL);
			obj->onactivate(text);
			g_free(text);
			
			gtk_text_buffer_set_text(buf, "", 0);
			
			return true;
		}
		if (event->keyval == GDK_KEY_Page_Up || event->keyval == GDK_KEY_Page_Down)
		{
			if (mods == GDK_CONTROL_MASK)
			{
				obj->onswitchfocus((event->keyval == GDK_KEY_Page_Up) ? -1 : 1);
			}
			else
			{
				obj->onscroll(event);
			}
			return true;
		}
		return false;
	}
	
	void set_onactivate(function<void(cstring text)> onactivate)
	{
		this->onactivate = onactivate;
	}
	void set_onscroll(function<void(GdkEventKey* event)> onscroll)
	{
		this->onscroll = onscroll;
	}
	void set_onswitchfocus(function<void(int dir)> onswitchfocus)
	{
		this->onswitchfocus = onswitchfocus;
	}
	void grab_focus() { gtk_widget_grab_focus(GTK_WIDGET(view)); }
	
	//TODO: after splitting inputview to a separate file, make this a struct instead of separate components
	//russian::chanbase currently contains these members, struct needs to be in header so chanbase can use it
	void store_get(string* text, size_t* textpos)
	{
		gchar* text_raw;
		g_object_get(gtk_text_view_get_buffer(view), "text", &text_raw, NULL);
		*text = text_raw;
		g_free(text_raw);
		
		gint textpos_raw;
		g_object_get(gtk_text_view_get_buffer(view), "cursor-position", &textpos_raw, NULL);
		*textpos = textpos_raw;
	}
	void store_set(cstring text, size_t textpos)
	{
		GtkTextBuffer* buf = gtk_text_view_get_buffer(view);
		gtk_text_buffer_set_text(buf, (char*)text.bytes().ptr(), text.bytes().size());
		
		GtkTextIter iter;
		gtk_text_buffer_get_iter_at_offset(buf, &iter, textpos);
		gtk_text_buffer_select_range(buf, &iter, &iter);
	}
	
	GtkWidget* gtkwidget()
	{
#if GTK_CHECK_VERSION(3,22,0)
		return (GtkWidget*)scrollview;
#else
		return (GtkWidget*)view;
#endif
	}
};

class impl {
public:
	textview* tv;
	chanview* cv;
	//widget_textbox* input;
	inputview* input;
	
	chanbase* cur_chan = NULL;
	
	int x = 0;
	int y = 0;
	unsigned width = 0;
	unsigned height = 0;
	
	impl()
	{
		//without this, input view turns super stupid
		//don't know how early it must be set, so do it as fast as possible
		g_object_set(gtk_settings_get_default(), "gtk-enable-animations", false, NULL);
		
		this->tv = textview::create();
		
		this->cv = chanview::create();
		cv->onfocus(bind_this(&impl::cv_focus_cb));
		
		this->input = inputview::create();
		input->set_onactivate(bind_this(&impl::input_cb));
		input->set_onscroll(bind_ptr(&textview::do_scroll, this->tv));
		input->set_onswitchfocus(bind_ptr(&chanview::move_focus, this->cv));
		
		bmlunserialize_impl s(file::readall(file::exepath()+"config.txt"));
		
		ser_enter(s)
		{
			//if (s.next() == "discord") ;
			if (s.next() == "irc") protocol::create_irc(this, s);
			if (s.next() == "test") protocol::create_testp(this, s);
			if (s.next() == "window")
			{
				ser_enter(s)
				{
					s.item("width", width);
					s.item("height", height);
					s.item("x", x);
					s.item("y", y);
				}
			}
		}
		
		GtkGrid* grid = GTK_GRID(gtk_grid_new());
		gtk_widget_set_size_request(cv->gtkwidget(), 60, 0);
		gtk_grid_attach(grid, cv->gtkwidget(),    0,0, 1,2);
		gtk_grid_attach(grid, tv->gtkwidget(),    1,0, 1,1);
		gtk_grid_attach(grid, input->gtkwidget(), 1,1, 1,1);
		
		gtk_widget_set_hexpand(tv->gtkwidget(), true);
		gtk_widget_set_hexpand(input->gtkwidget(), true);
		gtk_widget_set_vexpand(cv->gtkwidget(), true);
		gtk_widget_set_vexpand(tv->gtkwidget(), true);
		
		GtkWindow* wnd = GTK_WINDOW(gtk_window_new(GTK_WINDOW_TOPLEVEL));
		gtk_container_add(GTK_CONTAINER(wnd), GTK_WIDGET(grid));
		gtk_window_set_resizable(wnd, true);
		gtk_window_set_title(wnd, "ЯUSSIAN MALWДRE");
		if (width && height) gtk_window_resize(wnd, width, height);
		
		//extra variable because I don't trust G_CALLBACK to do anything sensible with a lambda
		gboolean(*onclose_cb)(GtkWidget* widget, GdkEvent* event, gpointer user_data) =
			[](GtkWidget* widget, GdkEvent* event, gpointer user_data)->gboolean {
				runloop::global()->exit();
				return GDK_EVENT_STOP;
			};
		g_signal_connect(wnd, "delete-event", G_CALLBACK(onclose_cb), this);
		
		gboolean(*onkb_gtk)(GtkWidget* widget, GdkEventKey* event, gpointer user_data) =
			[](GtkWidget* widget, GdkEventKey* event, gpointer user_data)->gboolean {
				impl* this_ = (impl*)user_data;
				//TODO: make this conditional on which widget is currently focused, topic box doesn't want input stolen
				
				bool to_input = false;
				
				if (gdk_keyval_to_unicode(event->keyval)!=0 ||
					event->keyval == GDK_KEY_Up || event->keyval == GDK_KEY_Down ||
					event->keyval == GDK_KEY_Left || event->keyval == GDK_KEY_Right ||
					event->keyval == GDK_KEY_Home || event->keyval == GDK_KEY_End ||
					false)
				{
					to_input = true;
				}
				
				if (event->state & (GDK_CONTROL_MASK | GDK_MOD1_MASK))
				{
					to_input = false;
				}
				if ((event->state & GDK_CONTROL_MASK) && (event->keyval == GDK_KEY_V || event->keyval == GDK_KEY_v))
				{
					to_input = true;
				}
				
				if (to_input)
				{
					this_->input->grab_focus();
				}
				return GDK_EVENT_PROPAGATE;
			};
		g_signal_connect(wnd, "key-press-event", G_CALLBACK(onkb_gtk), this);
		
		gtk_widget_show_all(GTK_WIDGET(wnd));
		
		if (x || y) gdk_window_move(gtk_widget_get_window(GTK_WIDGET(wnd)), x, y);
		input->grab_focus();
		
		runloop::global()->enter();
	}
	
	void cv_focus_cb(void* userdata)
	{
		chanbase* new_chan = (chanbase*)userdata;
		
		if (this->cur_chan)
		{
			input->store_get(&this->cur_chan->input_text, &this->cur_chan->input_pos);
		}
		
		this->cur_chan = new_chan;
		tv->set_buf(cur_chan->buf);
		
		input->store_set(this->cur_chan->input_text, this->cur_chan->input_pos);
		
		this->cur_chan->cvb_imp = chanbase::imp_none;
		this->cur_chan->cvb->color(-1);
	}
	void input_cb(cstring text)
	{
		if (!text) return;
		cur_chan->parent->action(text, cur_chan->userdata);
	}
};

group::group(protocol* parent, cstring name, void* userdata)
	: chanbase(parent, this, name, userdata)
{
	cvb = parent->parent->cv->child(name, this);
}
channel::channel(protocol* parent, group* pgroup, chanview::group* pchan, cstring name, void* userdata)
	: chanbase(parent, pgroup, name, userdata)
{
	cvb = pchan->child(name, this);
}
static string readlines(file& logfile, size_t& lines)
{
	string text = logfile.read(logfile.size());
	size_t start = text.length();
	if (!start) return "";
	start--; // the file always ends with a \n, no need to include it
	while (start > 0)
	{
		if (text[start] == '\n')
		{
			lines--;
			if (lines == 0)
			{
				start++;
				break;
			}
		}
		start--;
	}
	return text.substr(start, ~0);
}
chanbase::chanbase(protocol* parent, group* pgroup, cstring name, void* userdata)
	: parent(parent), pgroup(pgroup), userdata(userdata), name(name)
{
	for (size_t i=0;i<name.length();i++)
	{
		if (name[i] == '/') {}
		else if (name[i] == '.' && !name_fn) {}
		else name_fn += name[i];
	}
	
	time_t now = time(NULL);
	log_open(logfile, now, true);
	logrotate = month_next(now);
	
	size_t linesleft = 100;
	string scrollback = readlines(logfile, linesleft);
	if (linesleft)
	{
		file prev;
		log_open(prev, month_prev(now), false);
		if (prev) scrollback = readlines(prev, linesleft)+scrollback;
	}
	
	buf = parent->parent->tv->child(scrollback);
}
void chanbase::rename(cstring newname)
{
	cvb->rename(newname);
}

time_t chanbase::month_prev(time_t t)
{
	struct tm stm;
	localtime_r(&t, &stm);
	
	stm.tm_sec = 0;
	stm.tm_min = 0;
	stm.tm_hour = 0;
	stm.tm_mday = 1;
	if (stm.tm_mon == 0)
	{
		stm.tm_year--;
		stm.tm_mon = 12;
	}
	stm.tm_mon--;
	
	return mktime(&stm);
}
time_t chanbase::month_start(time_t t)
{
	struct tm stm;
	localtime_r(&t, &stm);
	
	stm.tm_sec = 0;
	stm.tm_min = 0;
	stm.tm_hour = 0;
	stm.tm_mday = 1;
	
	return mktime(&stm);
}
time_t chanbase::month_next(time_t t)
{
	struct tm stm;
	localtime_r(&t, &stm);
	
	stm.tm_sec = 0;
	stm.tm_min = 0;
	stm.tm_hour = 0;
	stm.tm_mday = 1;
	stm.tm_mon++;
	if (stm.tm_mon == 12)
	{
		stm.tm_year++;
		stm.tm_mon = 0;
	}
	
	return mktime(&stm);
}
static string timestr(time_t at)
{
	char buf[128];
	strftime(buf, sizeof(buf), "%H:%M:%S", localtime(&at));
	return buf;
}
static array<span> mkspans(time_t at, cstring source, arrayview<span> bodyspans)
{
	array<span> spans;
	if (bodyspans)
	{
		if (source)
		{
			span headspans[] = {
				{ "[" },
				{ timestr(at) },
				{ "] <" },
				{ source },
				{ "> " },
			};
			spans = headspans;
		}
		else
		{
			span headspans[] = {
				{ "[" },
				{ timestr(at) },
				{ "] ** " },
			};
			spans = headspans;
		}
		spans += bodyspans;
	}
	return spans;
}
void chanbase::log_open(file& f, time_t at, bool create) const
{
	file::mkdir(file::exepath()+"logs/");
	file::mkdir(file::exepath()+"logs/"+pgroup->name_fn+"/");
	
	struct tm stm;
	localtime_r(&at, &stm);
	
	char timebuf[64];
	strftime(timebuf, sizeof(timebuf), " %Y-%m", &stm);
	f.open(file::exepath()+"logs/"+pgroup->name_fn+"/"+name_fn+timebuf+".log", create ? file::m_write : file::m_read);
}
void chanbase::log(time_t at, cstring type, cstring source, arrayview<span> spans)
{
	struct tm stm;
	localtime_r(&at, &stm);
	
	time_t now = time(NULL);
	if (now >= logrotate)
	{
		log_open(logfile, now, true);
		logrotate = month_next(now);
	}
	
	char timebuf[64];
	strftime(timebuf, sizeof(timebuf), "[%Y-%m-%d %H:%M:%S] ", &stm);
	string tmp = timebuf;
	if (source) tmp += "<"+source+"> ";
	else tmp += "** ";
	tmp += type;
	for (size_t i=0;i<spans.size();i++) tmp += spans[i].text;
	tmp += "\n";
	
	logfile.write(tmp);
}
void chanbase::message(cstring id, importance_t imp, time_t at, cstring source, arrayview<span> bodyspans)
{
	if (this->parent->parent->cur_chan != this)
	{
		cvb_imp = max(cvb_imp, imp);
		static const uint32_t colors[] = { (uint32_t)-1, 0x990000, 0xFF0000, 0x00C0FF };
		cvb->color(colors[cvb_imp]);
	}
	
	array<span> spans = mkspans(at, source, bodyspans);
	buf->message(id, spans);
	log(at, "", source, bodyspans);
}
void chanbase::message_edit(cstring id, time_t at, cstring source, arrayview<span> bodyspans)
{
	array<span> spans = mkspans(at, source, bodyspans);
	buf->message_edit_visible(id, spans);
	log(at, "EDIT: ", source, bodyspans);
}
void chanbase::message_delete(cstring id, time_t at)
{
	buf->message_edit_visible(id, NULL);
}
void chanbase::message_delete_true(cstring id)
{
	buf->message_delete(id);
}
}
#endif


int main(int argc, char** argv)
{
	string ircbouncer;
	
	argparse args;
	args.add("ircbouncer", &ircbouncer);
	
	args.add_cli();
	
	arlib_init(args, argv);
	
	if (ircbouncer)
	{
		russian::do_irc_bouncer(ircbouncer);
		return 0;
	}
	
#ifndef ARGUI_NONE
	if (args.has_gui())
	{
		new russian::impl();
		return 0;
	}
#endif
	puts("russian: GUI not enabled and no alternative mode of operation specified");
	return 1;
}
