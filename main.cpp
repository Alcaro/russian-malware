#ifndef ARGUI_GTK3
#error gtk only
#endif

#include "russian.h"

//todo list

//output box:
//X find suitable textview
//X add textview
//X preserve scroll position
//    with a bool 'atBottom' which can only be changed by explicit user action, not resize
//    if false, flag channel as having activity
//X message editing
//- lose focus on any input, except ctrl-c; forward events to input box
//    gtk_widget_event(GtkWidget* widget, GdkEvent* event)
//  alternatively, pass ctrl-c on input box to output box if there's no selection
//    on signal GtkTextView copy-clipboard on inputview:
//      if not gtk_text_buffer_get_selection_bounds(gtk_text_view_get_buffer(inputview), NULL, NULL):
//        GtkClipboard* clipboard = gtk_widget_get_clipboard(GTK_WIDGET(outputview), GDK_SELECTION_CLIPBOARD);
//        gtk_text_buffer_copy_clipboard(gtk_text_view_get_buffer(outputview), clipboard);

//channel list:
//X add channel list
//- make channel list a two-column device?
//- track activity (including cross-channel messages, like joins)
//- lose focus

//input box:
//X make input box work
//- make input box a separate source file, it's about as complex as the other two widgets
//X make input box multiline
//- input box syntax highlighting
//- keyboard input - tab
//- keyboard input - up/down (repeat line)
//- keyboard input - pgup/pgdn (scroll outbox)
//- keyboard input - ctrl-pgup/dn (switch channel)
//- preserve state per channel (including cursor position)

//protocols:
//X define internal api for protocols
//X irc
//- discord
//- todo list / calendar

//misc:
//X make runloop support sockets
//X make runloop support timeouts
//X make every socket user use new poller mechanism
//X config reader
//- userlist?
//- topic?
//- port to Qt because Gtk is a nyarglebargle?

#include <gtk/gtk.h>

#if !GTK_CHECK_VERSION(3,16,0)
//this is somewhat glitchy (textview works fine, but channel list gets scrollbar), but there's no better option for old gtks
#define GTK_POLICY_EXTERNAL GTK_POLICY_AUTOMATIC
#endif


class widget_gtk : public widget_base { WIDGET_BASE
public:
	widget_gtk(uint8_t widthprio, uint8_t heightprio, GtkWidget* widget)
	{
		this->widget = widget;
		this->widthprio = widthprio;
		this->heightprio = heightprio;
	}
};
#define widget_create_gtk(...) (new widget_gtk(__VA_ARGS__))

GtkWidget* gtk_wrap_scroll(GtkPolicyType horz, GtkPolicyType vert, GtkWidget* child)
{
	GtkScrolledWindow* scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	gtk_scrolled_window_set_policy(scrollview, horz, vert);
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), child);
	return GTK_WIDGET(scrollview);
}

GtkWidget* gtk_wrap_minsize(int x, int y, GtkWidget* widget)
{
	gtk_widget_set_size_request(widget, x, y);
	return widget;
}



namespace russian {
class inputview {
	GtkScrolledWindow* scrollview;
	GtkTextView* view;
	
	function<void(cstring text)> onactivate;
public:
	static inputview* create() { return new inputview; }
	inputview()
	{
		view = GTK_TEXT_VIEW(gtk_text_view_new());
		gtk_text_view_set_wrap_mode(view, GTK_WRAP_WORD_CHAR);
		
		//gtk_entry_set_activates_default(view, false);
		//g_signal_connect(view, "activate", G_CALLBACK(inputview::onactivate_nat), this);
		g_signal_connect(view, "key-press-event", G_CALLBACK(inputview::onkeydown_nat), this);
		
		gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_LEFT, 4);
		gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_RIGHT, 4);
		gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_TOP, 4);
		gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_BOTTOM, 4);
		
		scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
		gtk_scrolled_window_set_policy(scrollview, GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC);
		gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
		gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(view));
		
		gtk_scrolled_window_set_propagate_natural_height(scrollview, true);
		gtk_scrolled_window_set_max_content_height(scrollview, 150);
	}
	//static void onactivate_nat(GtkEntry* entry, gpointer user_data)
	//{
	//	inputview* obj = (inputview*)user_data;
	//	obj->onactivate(gtk_entry_get_text(obj->view));
	//	gtk_entry_set_text(obj->view, "");
	//}
	static bool onkeydown_nat(GtkWidget* widget, GdkEvent* event, gpointer user_data)
	{
		inputview* obj = (inputview*)user_data;
		if (gtk_text_view_im_context_filter_keypress(obj->view, &event->key))
		{
			return true;
		}
		
		if (event->key.keyval == GDK_KEY_Return)
		{
			
			GtkTextBuffer* buf = gtk_text_view_get_buffer(obj->view);
			GtkTextIter start;
			GtkTextIter end;
			gtk_text_buffer_get_start_iter(buf, &start);
			gtk_text_buffer_get_end_iter(buf, &end);
			gchar* text = gtk_text_buffer_get_text(buf, &start, &end, FALSE);
			
			obj->onactivate(text);
			g_free(text);
			gtk_text_buffer_set_text(buf, "", 0);
			
			return true;
		}
		return false;
	}
	void set_onactivate(function<void(cstring text)> onactivate)
	{
		this->onactivate = onactivate;
	}
	GtkWidget* gtkwidget() { return (GtkWidget*)scrollview; }
};

class impl {
public:
	textview* tv;
	chanview* cv;
	//widget_textbox* input;
	inputview* input;
	
	chanbase* cur_chan;
	
	int x = 0;
	int y = 0;
	unsigned width = 0;
	unsigned height = 0;
	
	impl()
	{
		//without this, input view turns super stupid
		g_object_set(gtk_settings_get_default(), "gtk-enable-animations", false, NULL);
		
		this->tv = textview::create();
		
		this->cv = chanview::create();
		cv->onfocus(bind_this(&impl::cv_focus_cb));
		
		this->input = inputview::create();
		input->set_onactivate(bind_this(&impl::input_cb));
		
		bmlunserialize_impl s(file::read(file::exepath()+"config.txt"));
		
		ser_enter(s)
		{
			//if (s.next() == "discord") ;
			if (s.next() == "irc") protocol::create_irc(this, s);
			if (s.next() == "test") protocol::create_testp(this, s);
			if (s.next() == "window")
			{
				ser_enter(s)
				{
					s.item("width", width);
					s.item("height", height);
					s.item("x", x);
					s.item("y", y);
				}
			}
		}
		
		window* wnd = window_create(
			widget_create_layout_horz(
				widget_create_gtk(3, 4,
					gtk_wrap_minsize(60, 0,
						gtk_wrap_scroll(GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC,
							cv->gtkwidget()
						)
					)
				),
				widget_create_layout_vert(
					widget_create_gtk(4, 4,
						tv->gtkwidget()
					),
					widget_create_gtk(4, 1,
						input->gtkwidget()
					)
				)
			)
		);
		
		wnd->set_resizable(true, NULL);
		wnd->set_title("ЯUSSIAN MALWДRE");
		if (width && height) wnd->resize(width, height);
		wnd->set_visible(true);
		if (x || y) wnd->set_pos(x, y);
		
		wnd->set_onclose(&window::exit_runloop);
		
		runloop::global()->enter();
	}
	
	void cv_focus_cb(void* userdata)
	{
		this->cur_chan = (chanbase*)userdata;
		tv->set_buf(cur_chan->buf);
	}
	void input_cb(cstring text)
	{
		if (!text) return;
		cur_chan->parent->action(text, cur_chan->userdata);
	}
};

group::group(protocol* parent, cstring name, void* userdata, bool gapless)
	: chanbase(parent, name, userdata, gapless)
{
	cvb = parent->parent->cv->child("("+name+")", this);
}
channel::channel(protocol* parent, chanview::group* pchan, cstring name, void* userdata, bool gapless)
	: chanbase(parent, name, userdata, gapless)
{
	cvb = pchan->child("("+name+")", this);
}
chanbase::chanbase(protocol* parent, cstring name, void* userdata, bool gapless)
	: parent(parent), buf(parent->parent->tv->child()), userdata(userdata), name(name), available(false), gapless(gapless)
{}
void chanbase::set_available(time_t at, bool available)
{
	if (available == this->available) return;
	this->available = available;
	
	if (!available)
	{
		cvb->rename("("+name+")");
		span sp[] = { { "Disconnected" } };
		this->message(gapless ? "@russian::disconnect" : "", at, "", sp);
	}
	else
	{
		cvb->rename(name);
		if (gapless)
		{
			this->message("@russian::disconnect", at, "", NULL);
			//TODO
		}
		else
		{
			span sp[] = { { "Now talking in "+name } };
			this->message("", at, "", sp);
		}
	}
}
static string timestr(time_t at)
{
	char buf[128];
	strftime(buf, sizeof(buf), "%H:%M:%S", localtime(&at));
	return buf;
}
void chanbase::message(cstring id, time_t at, cstring source, arrayview<span> bodyspans)
{
	//TODO: mark activity in chanview
	array<span> spans;
	if (bodyspans)
	{
		if (source)
		{
			span headspans[] = {
				{ "[" },
				{ timestr(at) },
				{ "] <" },
				{ source },
				{ "> " },
			};
			spans = headspans;
		}
		else
		{
			span headspans[] = {
				{ "[" },
				{ timestr(at) },
				{ "] ** " },
			};
			spans = headspans;
		}
		spans += bodyspans;
	}
	buf->message(id, spans);
}
}


int main(int argc, char** argv)
{
	arlib_init(NULL, argv);
	
	new russian::impl();
}
