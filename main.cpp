#ifndef ARGUI_GTK3
#error gtk only
#endif

#include "russian.h"

//todo list
//core:
//- track activity state of channels (including cross-channel messages)

//output box:
//X find suitable textview
//X add textview
//- preserve scroll position
//    with a bool 'atBottom' which can only be changed by explicit user action, not resize
//    if false, flag channel as having activity

//channel list:
//X add channel list
//- make channel list a two-column device?
//- track activity

//input box:
//X make input box work
//- make input box multiline
//- input box syntax highlighting - GtkSourceView (apt libgtksourceview-3.0-dev)? seems to support tab completion too
//- tab completion

//protocols:
//X define internal api for protocols
//- irc
//- discord
//- todo list / calendar

//misc:
//X make runloop support sockets
//X make runloop support timeouts
//- make every socket user use new poller mechanism
//- config reader
//- userlist
//- topic

#include <gtk/gtk.h>

#if !GTK_CHECK_VERSION(3,16,0)
//this is somewhat glitchy (textview works fine, but channel list gets scrollbar), but there's no better option for old gtks
#define GTK_POLICY_EXTERNAL GTK_POLICY_AUTOMATIC
#endif


class widget_gtk : public widget_base { WIDGET_BASE
public:
	widget_gtk(uint8_t widthprio, uint8_t heightprio, GtkWidget* widget)
	{
		this->widget = widget;
		this->widthprio = widthprio;
		this->heightprio = heightprio;
	}
};
#define widget_create_gtk(...) (new widget_gtk(__VA_ARGS__))

GtkWidget* gtk_wrap_scroll(GtkPolicyType horz, GtkPolicyType vert, GtkWidget* child)
{
	GtkScrolledWindow* scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	gtk_scrolled_window_set_policy(scrollview, horz, vert);
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), child);
	return GTK_WIDGET(scrollview);
}

GtkWidget* gtk_wrap_minsize(int x, int y, GtkWidget* widget)
{
	gtk_widget_set_size_request(widget, x, y);
	return widget;
}



namespace russian {
class impl {
public:
	textview* tv;
	chanview* cv;
	widget_textbox* input;
	
	chanbase* cur_chan;
	
	void serialize(bmlunserialize_impl& s)
	{
		if (s.next() == "discord") ;
		if (s.next() == "irc") protocol::create_irc(this, s);
		if (s.next() == "test") protocol::create_testp(this, s);
	}
	
	impl()
	{
		this->tv = textview::create();
		
		this->cv = chanview::create();
		cv->onfocus(bind_this(&impl::cv_focus_cb));
		
		bmlunserialize_to(file::read("/home/alcaro/Desktop/russian/config.txt"), *this);
		
		window* wnd = window_create(
			widget_create_layout_horz(
				widget_create_gtk(3, 4,
					gtk_wrap_minsize(60, 0,
						gtk_wrap_scroll(GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC,
							cv->gtkwidget()
						)
					)
				),
				widget_create_layout_vert(
					widget_create_gtk(4, 4,
						//I'd rather have NEVER than this one, but that makes textview refuse to
						// shrink if that would change word wrapping
						gtk_wrap_scroll(GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC,
							tv->gtkwidget()
						)
					),
					//widget_create_gtk(4, 1,
					//	gtk_wrap_scroll(GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC,
					//		GTK_WIDGET(text->gtkwidget())
					//	)
					//)
					input = widget_create_textbox()
						->set_onactivate(bind_this(&impl::input_cb))
						->focus()
				)
			)
		);
		
		wnd->set_resizable(true, NULL);
		wnd->set_title("ЯUSSIAN MALWДRE");
		wnd->resize(571, 665);
		wnd->set_visible(true);
		
		wnd->set_onclose(&window::exit_runloop);
		
		runloop::global()->enter();
	}
	
	void cv_focus_cb(void* userdata)
	{
		this->cur_chan = (chanbase*)userdata;
		tv->set_buf(cur_chan->buf);
	}
	void input_cb(cstring text)
	{
		if (!text) return;
		cur_chan->parent->action(text, cur_chan->userdata);
		input->set_text("");
	}
};

group::group(protocol* parent, cstring name, void* userdata) : chanbase(parent, userdata)
{
	this->cvb = parent->parent->cv->child(name, this);
}
channel::channel(protocol* parent, chanview::group* pchan, cstring name, void* userdata) : chanbase(parent, userdata)
{
	this->cvb = pchan->child(name, this);
}
chanbase::chanbase(protocol* parent, void* userdata)
{
	this->parent = parent;
	this->buf = parent->parent->tv->child();
	this->userdata = userdata;
}
void chanbase::message(cstring id, time_t at, arrayview<span> spans)
{
	//TODO: mark activity in chanview
	buf->message(id, spans);
}
}


int main(int argc, char * argv[])
{
	window_init(&argc, &argv);
	
	new russian::impl();
}
