#include "arlib.h"

#ifndef ARGUI_GTK3
#error gtk only
#endif

#define DEBUG_TEXTVIEW 1


#include <gtk/gtk.h>

#if !GTK_CHECK_VERSION(3,16,0)
#define GTK_POLICY_EXTERNAL GTK_POLICY_AUTOMATIC
#else
#error test the above
#endif

//a selection bound may not lie between a GdkPixbuf and the alt-text tag, or inside the tag
// if it does, it must be put on the far side of the image
//since the alt-text tag always lies to the right of the image, this simplifies to
// 'if a selection bound points inside, or to the start of, an alt-ext tag, move it to the end of said tag'
//which further simplifies to 'if the pointed-to character is inside the tag, move to after the tag end'
GtkTextIter img_alt_adjusted_iter_from_mark(GtkTextBuffer* buffer,
                                  GtkTextMark* mark,
                                  GtkTextTag* tag,
                                  bool* do_move)
{
	GtkTextIter ret;
	gtk_text_buffer_get_iter_at_mark(buffer, &ret, mark);
	if (gtk_text_iter_has_tag(&ret, tag))
	{
		*do_move = true;
		gtk_text_iter_forward_to_tag_toggle(&ret, tag);
	}
	return ret;
}

void img_alt_update_selection(GtkTextBuffer* buffer, GtkTextTag* tag)
{
	bool do_move = false;
	GtkTextIter insert = img_alt_adjusted_iter_from_mark(buffer, gtk_text_buffer_get_insert(         buffer), tag, &do_move);
	GtkTextIter sbound = img_alt_adjusted_iter_from_mark(buffer, gtk_text_buffer_get_selection_bound(buffer), tag, &do_move);
	
	if (do_move)
	{
		gtk_text_buffer_select_range(buffer, &insert, &sbound);
	}
}

void img_alt_on_select(GObject* gobject, GParamSpec* pspec, gpointer user_data)
{
	img_alt_update_selection(GTK_TEXT_BUFFER(gobject), GTK_TEXT_TAG(user_data));
}

void gtk_text_buffer_prepare_pixbuf_with_alt(GtkTextBuffer* buffer)
{
	GtkTextTag* tag = gtk_text_tag_table_lookup(gtk_text_buffer_get_tag_table(buffer), "select-only");
	if (!tag)
	{
		tag = gtk_text_tag_new("select-only");
#if DEBUG_TEXTVIEW
		g_object_set(tag, "scale", (gdouble)0.5, NULL);
#else
		g_object_set(tag, "scale", (gdouble)0, NULL);
#endif
		gtk_text_tag_table_add(gtk_text_buffer_get_tag_table(buffer), tag);
	}
	
	//this doesn't do anything if selection-bound moves without cursor moving, but as far as I've seen,
	// user can't move it to any place other than 'right where main cursor is' which is always a valid position
	//(okay, code can move it, but it won't.)
	g_signal_connect(buffer, "notify::cursor-position", G_CALLBACK(img_alt_on_select), tag);
}

//The alt-text is copied if the image is selected and user presses Ctrl-C.
//WARNING: Messes up keyboard navigation. If using this, turn off cursor visibility and make the GtkTextView readonly.
//Known bugs if you don't:
//- Backspacing the image removes the alt-text, one character at the time
//- Left arrow has no effect if beside an image, you end up back where you started
//Mouse selection is (as far as I know) bug-free.
void gtk_text_buffer_insert_pixbuf_with_alt(
              GtkTextBuffer* buffer, GtkTextIter* iter, GdkPixbuf* pixbuf, const gchar * text, gint len)
{
	GtkTextTag* texttag = gtk_text_tag_table_lookup(gtk_text_buffer_get_tag_table(buffer), "select-only");
	
	//size_t pos = gtk_text_iter_get_offset(iter);
	gtk_text_buffer_insert_pixbuf(buffer, iter, pixbuf);
	
	//unusable - only the left half of my image gets events
	//GtkTextTag* imgtag = gtk_text_tag_table_lookup(gtk_text_buffer_get_tag_table(buffer), "img-hover");
	//if (!imgtag)
	//{
	//	imgtag = gtk_text_tag_new("img-hover");
	//	g_signal_connect(imgtag, "event", G_CALLBACK(img_alt_on_imgevent), texttag);
	//	gtk_text_tag_table_add(gtk_text_buffer_get_tag_table(buffer), imgtag);
	//}
	//
	//GtkTextIter iter_orig;
	//gtk_text_buffer_get_iter_at_offset(buffer, &iter_orig, pos);
	//gtk_text_buffer_apply_tag(buffer, imgtag, &iter_orig, iter);
	
	gtk_text_buffer_insert_with_tags(buffer, iter, text, len, texttag, NULL);
}





struct chdata {
	string name;
	GtkTextBuffer* buf;
};
struct chgroup {
	string name;
	GtkTextBuffer* buf;
	array<chdata> channels;
};
array<chgroup> groups;

GtkTreeModel* create_model()
{
	GtkTreeStore* treestore = gtk_tree_store_new(2, G_TYPE_STRING, G_TYPE_POINTER);
	
	for (size_t gid=0;gid<groups.size();gid++)
	{
		chgroup& group = groups[gid];
		
		GtkTreeIter treegroup;
		gtk_tree_store_append(treestore, &treegroup, NULL);
		gtk_tree_store_set(treestore, &treegroup, 0, (const char*)group.name, 1, group.buf, -1);
		
		for (size_t id=0;id<group.channels.size();id++)
		{
			chdata& channel = group.channels[id];
			
			GtkTreeIter treechild;
			gtk_tree_store_append(treestore, &treechild, &treegroup);
			gtk_tree_store_set(treestore, &treechild, 0, (const char*)channel.name, 1, channel.buf, -1);
		}
	}
	
	//gtk_tree_store_append(treestore, &group, NULL);
	//gtk_tree_store_set(treestore, &group, 0, "#CaffieNET", -1);
	//
	//gtk_tree_store_append(treestore, &channel, &group);
	//gtk_tree_store_set(treestore, &channel, 0, "#smwc", -1);
	//
	//gtk_tree_store_append(treestore, &group, NULL);
	//gtk_tree_store_set(treestore, &group, 0, "#BitlBee", -1);
	
	return GTK_TREE_MODEL(treestore);
}

GtkTextView* textview;
GtkTextTagTable* texttags;

void switch_channel(GtkTreeSelection* sel, void* userdata)
{
	GtkTreeModel* model;
	GtkTreeIter iter;
	
	GtkTextBuffer* buf;
	
	if (gtk_tree_selection_get_selected (sel, &model, &iter))
	{
		gtk_tree_model_get (model, &iter, 1, &buf, -1);
		gtk_text_view_set_buffer(textview, buf);
	}
}

GtkTreeView* create_treeview()
{
	GtkTreeModel* model = create_model();
	GtkTreeView* view = GTK_TREE_VIEW(gtk_tree_view_new());
	
	GtkTreeViewColumn* col = gtk_tree_view_column_new();
	GtkCellRenderer* renderer = gtk_cell_renderer_text_new();
  gtk_tree_view_append_column(view, col);
	gtk_tree_view_column_pack_start(col, renderer, TRUE);
	gtk_tree_view_column_add_attribute(col, renderer, "text", 0);
	gtk_cell_renderer_text_set_fixed_height_from_font(GTK_CELL_RENDERER_TEXT(renderer), 1);
	
	gtk_tree_view_set_model(view, model);
	gtk_tree_selection_set_mode(gtk_tree_view_get_selection(view), GTK_SELECTION_BROWSE);
	gtk_tree_view_set_headers_visible(view, false);
	
	gtk_tree_view_set_enable_tree_lines(view, true);
	gtk_tree_view_expand_all(view);
	
	g_signal_connect(G_OBJECT(gtk_tree_view_get_selection(view)), "changed", G_CALLBACK(switch_channel), NULL);
	
	//TODO: do I enable these?
	gtk_tree_view_set_show_expanders(view, false);
	gtk_tree_view_set_level_indentation(view, 19);
	
	//TODO: figure out if this is helpful or annoying
	gtk_tree_view_set_hover_selection(view, true);
	
	return view;
}





//class widget_tree : public widget_base { WIDGET_BASE
//};
//#define widget_create_tree(...) (new widget_tree(__VA_ARGS__))





class widget_gtk : public widget_base { WIDGET_BASE
public:
	widget_gtk(uint8_t widthprio, uint8_t heightprio, GtkWidget* widget)
	{
		this->widget = widget;
		this->widthprio = widthprio;
		this->heightprio = heightprio;
	}
};
#define widget_create_gtk(...) (new widget_gtk(__VA_ARGS__))

void add_image(GtkTextBuffer* buf, cstring path)
{
	GtkTextIter pos;
	
	array<byte> bytes = file::read(path);
	GInputStream* is = g_memory_input_stream_new_from_data(bytes.ptr(), bytes.size(), NULL);
	GdkPixbuf* pix = gdk_pixbuf_new_from_stream_at_scale(is, 16, 16, true, NULL, NULL);
	
	gtk_text_buffer_get_selection_bounds(buf, &pos, NULL);
	gtk_text_buffer_insert_pixbuf_with_alt(buf, &pos, pix, path.c_str(), -1);
	
	g_object_unref(is);
	g_object_unref(pix);
}

//void do_stdin(uintptr_t fd)
//{
	//char line[4096];
	//size_t len = read(fd, line, 4095);
	//if (len > 0 && line[len-1] == '\n') len--;
	//line[len] = '\0';
	//
	//add_image(line);
//}

GtkWidget* gtk_wrap_scroll(GtkPolicyType horz, GtkPolicyType vert, GtkWidget* child)
{
	GtkScrolledWindow* scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	gtk_scrolled_window_set_policy(scrollview, horz, vert);
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), child);
	return GTK_WIDGET(scrollview);
}

GtkWidget* gtk_wrap_minsize(int x, int y, GtkWidget* widget)
{
	gtk_widget_set_size_request(widget, x, y);
	return widget;
}


GtkTextBuffer* make_textbuf()
{
	GtkTextBuffer* buf = gtk_text_buffer_new(texttags);
	gtk_text_buffer_prepare_pixbuf_with_alt(buf);
	return buf;
}

GtkTextBuffer* make_textbuf_with(size_t n)
{
	GtkTextBuffer* buf = make_textbuf();
	
	while (n)
	{
		gtk_text_buffer_insert_at_cursor(buf, "mun", -1);
		add_image(buf, "https://floating.muncher.se/muncher.png");
		gtk_text_buffer_insert_at_cursor(buf, "cher", -1);
		
		n--;
	}
	
	return buf;
}


int main(int argc, char * argv[])
{
	window_init(&argc, &argv);
	
	texttags = gtk_text_tag_table_new();
	textview = GTK_TEXT_VIEW(gtk_text_view_new());
	
	gtk_text_view_set_wrap_mode(textview, GTK_WRAP_WORD_CHAR);
	
#if !DEBUG_TEXTVIEW
	gtk_text_view_set_editable(textview, false);
	gtk_text_view_set_cursor_visible(textview, false);
#endif
	
	
	
	
	groups[0].name = "1 Muncher";
	groups[0].buf = make_textbuf_with(1);
	groups[0].channels[0].name = "2 Munchers";
	groups[0].channels[0].buf = make_textbuf_with(2);
	groups[1].name = "3 Munchers";
	groups[1].buf = make_textbuf_with(3);
	GtkTreeView* treeview = create_treeview();
	
	
	
	
	
	window* wnd = window_create(
		widget_create_layout_horz(
			widget_create_gtk(3, 4,
				gtk_wrap_minsize(60, 0,
					gtk_wrap_scroll(GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC,
						GTK_WIDGET(treeview)
					)
				)
			),
			widget_create_layout_vert(
				widget_create_gtk(4, 4,
					//I'd rather have NEVER than this one, but that makes textview refuse to shrink if that would change word wrapping
					gtk_wrap_scroll(GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC,
						GTK_WIDGET(textview)
					)
				),
				widget_create_textbox()
			)
		)
	);
	
	
	wnd->set_visible(true);
	wnd->set_resizable(true, NULL);
	wnd->set_title("ЯUSSIAN MALWДRE");
	wnd->resize(571, 665);
	
	wnd->set_onclose(&window::exit_runloop);
	
	//runloop::global()->set_fd(0, do_stdin);
	runloop::global()->enter();
	
	delete wnd;
}
