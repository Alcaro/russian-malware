#include "russian.h"
#include <sys/resource.h>

#ifndef ARGUI_GTK3
#error gtk only
#endif

//todo list

//verification:
//null

//top prio:
//- discord: outgoing highlights
//- textview: make bottom lock stickier; only scroll (mouse/touchpad), drag (scrollbar), and pgup/dn (and heavy activity) should unstick
//- chanview: leaving a channel with activity less than 1000ms ago should leave it marked active (must increase last activity precision)
//- figure out which features I actually need

//high prio:
//- create class textview_impl so all the privates get out of the header
//- pasting images from clipboard
//- tab complete
//- irc: rename query windows on /nick
//- discord: find some way to split discord.cpp, it's getting uncomfortably big
//- global commands
//    /in, /1w
//    /ar (via cgi, uses a temp message to the current channel even if cross-group)
//- textview: custom ctrl-c handler and remove scale=0.0 hack; it works for textview, but not inputview, and they should do the same
//- create all visible textviews in g_idle_add

//medium prio:
//- discord: switch from std::regex to https://github.com/hanickadot/compile-time-regular-expressions, once I switch to C++17
//- discord: userlist per guild
//- discord: userlist per channel (permission-aware)
//- discord: edit/delete (needs tab complete)
//- discord: make channel/etc links clickable
//- discord: irc->discord format translator
//    and /md or /raw command, for bot commands that won't parse markdown
//- discord: username colors
//- discord: implement various state change handlers: user joined, channel renamed, etc
//- discord: render attachments inline
//- discord: non-square emoji should be centered, not bottom-aligned
//- discord: auto mark afk if machine is 5min idle
//    int dummy;
//    if (DPMSQueryExtension(dpy, &dummy, &dummy) && DPMSCapable(dpy))
//    {
//        CARD16 state = DPMSModeOn;
//        BOOL onoff;
//        DPMSInfo(dpy, &state, &onoff);
//        if (onoff && state != DPMSModeOn)
//            // screen is off, so machine is idle
//- discord: CHANNEL_DELETE should mark channel unavailable, and tell why; other rare messages should be processed too
//- textview: protocol-callback links (as opposed to the current hardcoded browser-only links)
//    discord: webhooks can say [Example](<https://www.example.com/>) (bots and humans can't); find the rules, and how to represent that
//- textview: allow small amounts of mouse movement when clicking a link
//- textview: give insert/selection-bound left gravity
//- discord/textview: when deleting message, ask protocol for larger image, rather than resizing twice
//- main: somewhere to print errors if a protocol refers to a nonexistent message in bad ways
//- inputview: syntax highlighting
//- inputview: indentation on line wrap
//- todo-list protocol
//- user list powerlevels
//- Copy as - IRC | HTML | unformatted | without timestamps | etc
//    needs textview ctrl-c handler

//low prio, some of those probably shouldn't be done at all:
//- message editing leaves a diff, rather than just the old message
//- find or create diff function for the above
//- topic box
//- turn clicked links purple, and figure out if that makes sense
//- discord: guild tab should contain status messages (joins, powerlevels, etc) about the guild, rather than being unfocusable
//- discord: move avatars and emoji out of the json blob
//- discord: estimate server time to improve temp message timestamp
//- discord: user rename should rename the query window too (TODO: how to make that not rearrange them?)
//- discord: pins
//- discord: voice
//- discord: replace {std,boost}::regex with a compile-time regex parser
//- discord: <#1234> on a voice channel or channel category should render as '#General' in plaintext, not #deleted-channel
//- discord: set last-read markers server-side
//- discord: use the server-side last-read markers (low prio, pointless with only a single computer)
//- discord: hide channels I can't access (low prio, they auto hide after a few days)
//- textview: put mouse on link, switch channel, move mouse to not on link, switch back. this should update cursor
//- textview: paint clicked links purple
//- textview: gtk_text_view_set_top_margin for inputview, rather than side windows
//- textview: shrunk images should ask the protocol for a smaller one, rather than gdk_pixbuf_scale_simple, to avoid some generation loss
//    there's no way to do that without making a mess; it's impossible to go from GdkPixbuf* to textview::image*
//      (map<GdkPixbuf*, image*> would have lifetime issues)
//      multiple textview::image for same GdkPixbuf would make comparison annoying,
//      changing image* to image would make lifetime management tricky, and I can't see any other implementation
//- textview: make message_replace_image work on shrunk images
//    same caveats as the above

//zero prio, I will not implement these (I wouldn't reject a well-written PR, though I can't promise it won't break at random intervals):
//- macos support
//- windows support
//    I don't have those installed, and it would require a lot of effort for zero (to me) gain
//- inputview: dehardcode the selection colors with warning enabled
//    I'd love a PR showing how to do that, I couldn't find it myself
//- dark theme
//    the bulk of the work should be done by a GTK+ stylesheet, but providing one,
//    documenting how to use it, and dehardcoding a couple of colors, would be an improvement
//    (assuming Gtk stylesheets have stopped breaking with every single version...)
//- discord: extract cookies from chrome/chromium
//    I don't have that installed either; easier to install than windows, but still no personal gain
//- discord: code block syntax highlighting
//    discord uses some version of https://highlightjs.org/; translating is lots of effort for little gain,
//    while using something else would most likely bring massive amounts of nasty dependencies,
//      be annoying to integrate, and likely be slightly inaccurate
//- discord: video
//    it's undocumented
//- textview: sometimes, on switching from a channel without userview to one with, a horizontal scrollbar shows up for a short time
//    fixed on gtk>=3.16 with GTK_POLICY_EXTERNAL, likely unfixable on older gtk
//- textview: 1px left/right padding on code tags, so discord `<200b>`<200b> times 10 shows up
//    tags' padding property seems to be ignored, left-margin applies only on linebreak or word wrap
//- irc bouncer
//    with irc rapidly losing users to discord, this is no longer relevant
//- track cross-channel messages, like joins, and mark all read once one is
//    only makes sense on irc, and all other irc clients show joins separately anyways
//- figure out how bouncer interacts with the last-read flags
//    cancelled along with bouncer

#include <gtk/gtk.h>

#define IDLE_TIMEOUT 1800
#define DONT_MARK_READ_TIMEOUT 2

namespace russian {

class hintview : nocopy {
public:
	GtkOverlay* overlay;
	
	GtkWidget* main; // main widget
	GtkWidget* sub; // child widget, placed on top of the main widget
	
	int x;
	int main_scrollwidth;
	
	hintview(GtkWidget* main, GtkWidget* sub)
	{
{
GtkTextView* contents = GTK_TEXT_VIEW(gtk_text_view_new());
gtk_text_buffer_insert_at_cursor(gtk_text_view_get_buffer(contents), "floating\nmuncher", -1);
sub = GTK_WIDGET(contents);
}
		this->main = main;
		
		// yes, a GtkScrolledWindow with scrollbar policy NEVER/NEVER is silly, but it's the easiest way to add a border
		// I tried various kinds of css, but border, outline margin and padding didn't seem to do anything when I tried
		// (as a bonus, it's guaranteed to match textview's border)
		GtkScrolledWindow* sub_wrap = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
		gtk_scrolled_window_set_policy(sub_wrap, GTK_POLICY_NEVER, GTK_POLICY_NEVER);
		gtk_scrolled_window_set_shadow_type(sub_wrap, GTK_SHADOW_IN);
		gtk_container_add(GTK_CONTAINER(sub_wrap), sub);
		this->sub = GTK_WIDGET(sub_wrap);
		
		overlay = GTK_OVERLAY(gtk_overlay_new());
		gtk_container_add(GTK_CONTAINER(overlay), main);
		gtk_overlay_add_overlay(overlay, GTK_WIDGET(sub_wrap));
		
		gboolean(*place_child_cb)(GtkOverlay* overlay, GtkWidget* widget, GdkRectangle* allocation, void* user_data) =
		                       [](GtkOverlay* overlay, GtkWidget* widget, GdkRectangle* allocation, void* user_data) -> gboolean
		{
			hintview* this_ = (hintview*)user_data;
			
			GtkRequisition sub_size;
			gtk_widget_get_preferred_size(this_->sub, NULL, &sub_size);
			
			int main_width = gtk_widget_get_allocated_width(this_->main) - this_->main_scrollwidth;
			int main_height = gtk_widget_get_allocated_height(this_->main);
			
			allocation->x = min(this_->x, main_width - sub_size.width);
			allocation->y = main_height - sub_size.height;
			allocation->width = sub_size.width;
			allocation->height = sub_size.height;
			
			return TRUE;
		};
		g_signal_connect(overlay, "get-child-position", G_CALLBACK(place_child_cb), this);
		
		main_scrollwidth = 0;
		if (GTK_IS_SCROLLED_WINDOW(main))
		{
			GtkWidget* scroll = gtk_scrolled_window_get_vscrollbar(GTK_SCROLLED_WINDOW(main));
			if (scroll)
			{
				int width;
				gtk_widget_get_preferred_width(scroll, NULL, &width);
				main_scrollwidth = width;
			}
		}
		
		this->x = 0;
	}
	
	void show(bool show)
	{
		gtk_widget_set_visible(sub, show);
	}
	
	int width()
	{
		return gtk_widget_get_allocated_width(main);
	}
	
	//If x is too high, it's clamped. Negative is undefined behavior.
	void move(int x)
	{
		this->x = x;
		gtk_widget_queue_resize(GTK_WIDGET(overlay));
	}
	
	GtkWidget* gtkwidget() { return (GtkWidget*)overlay; }
};

class impl {
public:
	GtkWindow* wnd;
	
	chanview* cv;
	GtkStack* stack;
	
	array<protocol*> protos;
	
	int ngroup = 0;
	
	chanbase* cur_chan = NULL;
	
	int x = INT_MAX;
	int y = INT_MAX;
	unsigned width = 0;
	unsigned height = 0;
	unsigned cvw = 60;
	unsigned uvw = 60;
	
	set<chanbase*> all_chans;
	array<chanbase*> lazy_chans;
	
	impl()
	{
		//without this, inputview turns super stupid
		//I don't know how early it must be set, so do it as fast as possible
		g_object_set(gtk_settings_get_default(), "gtk-enable-animations", false, NULL);
		wnd = GTK_WINDOW(gtk_window_new(GTK_WINDOW_TOPLEVEL));
		
		this->cv = chanview::create();
		cv->onfocus(bind_this(&impl::cv_focus_cb));
		cv->onclose(bind_this(&impl::cv_onclose_cb));
		
		this->stack = GTK_STACK(gtk_stack_new());
		gtk_stack_set_homogeneous(stack, true);
		gtk_stack_set_transition_type(stack, GTK_STACK_TRANSITION_TYPE_NONE);
		
		bmldeserializer s(file::readall(file::exepath()+"russian.cfg"));
		
		ser_enter(s)
		{
			if (s.next() == "discord") protos.append(protocol::create_discord(this, s));
			if (s.next() == "irc") protos.append(protocol::create_irc(this, s));
			if (s.next() == "test") protos.append(protocol::create_testp(this, s));
			ser_enter(s, "window")
			{
				s.item("width", width);
				s.item("height", height);
				s.item("x", x);
				s.item("y", y);
				s.item("chanlist", cvw);
				s.item("userlist", uvw);
			}
		}
		
		if (!this->cur_chan)
		{
			GtkDialog* dialog = GTK_DIALOG(gtk_message_dialog_new(NULL, (GtkDialogFlags)0,
			                               GTK_MESSAGE_ERROR, GTK_BUTTONS_CLOSE, "No config found, or no servers in config"));
			gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(dialog),
			               "Make sure %srussian.cfg exists and contains valid data.\n"
			               "Copy russian-tmpl.cfg and adapt it to your needs.",
			               (const char*)file::exepath().c_str());
			
			gtk_dialog_run(dialog);
			gtk_widget_destroy(GTK_WIDGET(dialog));
			exit(1);
		}
		set_idles();
		
		GtkGrid* grid = GTK_GRID(gtk_grid_new());
		gtk_widget_set_size_request(cv->gtkwidget(), cvw, 0);
		gtk_widget_set_vexpand(cv->gtkwidget(), true);
		gtk_grid_attach(grid, cv->gtkwidget(),   0,0, 1,1);
		gtk_grid_attach(grid, GTK_WIDGET(stack), 1,0, 1,1);
		
		//extra variable because I don't trust G_CALLBACK to do anything sensible with a lambda
		gboolean(*onclose_cb)(GtkWidget* widget, GdkEvent* event, void* user_data) =
		                   [](GtkWidget* widget, GdkEvent* event, void* user_data) -> gboolean
		{
			gtk_widget_hide(widget);
			runloop::global()->exit();
			return GDK_EVENT_STOP;
		};
		g_signal_connect(wnd, "delete-event", G_CALLBACK(onclose_cb), this);
		
		gboolean(*onkb_gtk)(GtkWidget* widget, GdkEventKey* event, void* user_data) =
		                 [](GtkWidget* widget, GdkEventKey* event, void* user_data) -> gboolean
		{
			//TODO: make this conditional on which widget is currently focused, topic box doesn't want input stolen
			impl* this_ = (impl*)user_data;
			
			GdkModifierType mods = (GdkModifierType)(event->state & (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_MOD1_MASK));
			
			if (event->keyval == GDK_KEY_Page_Up || event->keyval == GDK_KEY_Page_Down)
			{
				if (mods == 0)
				{
					this_->cur_chan->tv->do_scroll(event);
					return GDK_EVENT_STOP;
				}
				if (mods == GDK_CONTROL_MASK)
				{
					this_->cv->move_focus((event->keyval == GDK_KEY_Page_Up) ? -1 : 1);
					return GDK_EVENT_STOP;
				}
			}
			
			//anything that affects the input widget must cause a refocus
			//that includes, but is not limited to:
			//- printables
			//- backspace, delete
			//- ctrl-v, formatting
			//- ctrl-shift-u
			//- navigation (up, down, left, right, home, end)
			//however, ctrl-c (including the ctrl) must stay on the focus widget
			//
			//this one refocuses if it detects any of the above, not otherwise; it could be made more aggressive if desired
			//maybe even send all keyboard to textview, except (ctrl-)pgup/dn, and ctrl-c if inputview lacks selection
			
			bool to_input = false;
			
			if (gdk_keyval_to_unicode(event->keyval) != 0 || // oddly enough, this can report backspace/delete too
				event->keyval == GDK_KEY_Up || event->keyval == GDK_KEY_Down ||
				event->keyval == GDK_KEY_Left || event->keyval == GDK_KEY_Right ||
				event->keyval == GDK_KEY_Home || event->keyval == GDK_KEY_End ||
				(event->keyval >= GDK_KEY_dead_grave && event->keyval <= GDK_KEY_dead_greek) || // silly, but I couldn't find a
				false)                                                                          // better way to detect dead keys
			{
				to_input = true;
			}
			
			if (event->state & (GDK_CONTROL_MASK | GDK_MOD1_MASK))
			{
				to_input = false;
			}
			// c-a, c-v and c-s-u are gtk-defined ways to interact with textviews, the others are specific to here
			// c-c is explicitly not included
			if ((event->state & GDK_CONTROL_MASK) && (strchr("avUbkuioms", event->keyval) ||
			                                          event->keyval == GDK_KEY_Home || event->keyval == GDK_KEY_End))
			{
				to_input = true;
			}
			
			if (to_input)
			{
				this_->cur_chan->iv->grab_focus();
			}
			
			return GDK_EVENT_PROPAGATE;
		};
		g_signal_connect(wnd, "key-press-event", G_CALLBACK(onkb_gtk), this);
		
		//lazy-loading the channels keeps screwing up, initialize them as soon as possible
		g_idle_add([](void* user_data) -> gboolean
			{
				impl* this_ = (impl*)user_data;
				if (this_->lazy_chans)
				{
					chanbase* chan = this_->lazy_chans.pop_tail();
					if (!chan->hidden)
						this_->render(chan);
					return G_SOURCE_CONTINUE;
				}
				return G_SOURCE_REMOVE;
			}, this);
		
		gboolean(*any_event)(GtkWidget* widget, GdkEvent* event, void* user_data) =
		                  [](GtkWidget* widget, GdkEvent* event, void* user_data) -> gboolean
		{
			((impl*)user_data)->cur_chan->tv->user_input(event->type);
			return GDK_EVENT_PROPAGATE;
		};
		g_signal_connect(wnd, "event", G_CALLBACK(any_event), this);
		
		gtk_container_add(GTK_CONTAINER(wnd), GTK_WIDGET(grid));
		gtk_window_set_resizable(wnd, true);
		if (width && height) gtk_window_resize(wnd, width, height);
		
		gtk_widget_show_all(GTK_WIDGET(wnd));
		
		if (x != INT_MAX && y != INT_MAX) gdk_window_move(gtk_widget_get_window(GTK_WIDGET(wnd)), x, y);
		
		runloop::global()->enter();
		
		for (protocol* proto : protos)
		{
			delete proto;
		}
		protos.reset();
	}
	
	void set_idles()
	{
		time_t now = time(NULL);
		time_t next_check = now+IDLE_TIMEOUT;
		for (chanbase* chan : all_chans)
		{
			if (chan->cvb_imp != chanbase::imp_none || (chan->flags & chanbase::f_no_focus))
				continue;
			if (chan->last_activity <= now-IDLE_TIMEOUT)
			{
				chan->cvb_imp = chanbase::imp_idle;
				if (cur_chan != chan)
					chan->cvb->color_fg(0x666666);
			}
			else
				next_check = min(next_check, chan->last_activity+IDLE_TIMEOUT);
		}
		runloop::global()->set_timer_abs(next_check, bind_this(&impl::set_idles));
	}
	
	//Initializes all widgets and adds it to the GtkStack.
	void render(chanbase* chan)
	{
		if (cur_chan->grid)
			return;
		
		chan->grid = GTK_GRID(gtk_grid_new());
		
		gtk_grid_attach(chan->grid, chan->tv->gtkwidget(), 1,0, 1,1);
		gtk_widget_set_hexpand(chan->tv->gtkwidget(), true);
		gtk_widget_set_vexpand(chan->tv->gtkwidget(), true);
		
		gtk_grid_attach(chan->grid, chan->iv->gtkwidget(), 1,1, 1,1);
		gtk_widget_set_hexpand(chan->iv->gtkwidget(), true);
		
		if (chan->uv)
		{
			gtk_widget_set_size_request(chan->uv->gtkwidget(), uvw, 0);
			gtk_grid_attach(chan->grid, chan->uv->gtkwidget(), 2,0, 1,2);
			gtk_widget_set_vexpand(chan->uv->gtkwidget(), true);
		}
		
		gtk_widget_show_all(GTK_WIDGET(chan->grid));
		gtk_container_add(GTK_CONTAINER(stack), GTK_WIDGET(chan->grid));
		
		//scroll position is often wrong on first switch to channel, unless initialized like this already
		g_idle_add_full(G_PRIORITY_DEFAULT_IDLE+3, [](void* user_data) -> gboolean
			{
				// with some nasty timeout because it's STILL not enough in all cases
				g_timeout_add(100/*ms*/, [](void* user_data) -> gboolean
					{
						chanbase* chan = (chanbase*)user_data;
						gtk_widget_set_sensitive(chan->tv->gtkwidget(), false);
						gtk_widget_set_sensitive(chan->tv->gtkwidget(), true);
						// TODO: this will mess up if I start disabling iv on untalkable channels
						gtk_widget_set_sensitive(chan->iv->gtkwidget(), false);
						gtk_widget_set_sensitive(chan->iv->gtkwidget(), true);
						return G_SOURCE_REMOVE;
					}, user_data);
				return G_SOURCE_REMOVE;
			}, (void*)chan, NULL);
	}
	
	void cv_focus_cb(void* userdata)
	{
		chanbase* new_chan = (chanbase*)userdata;
		// Gtk sometimes likes calling the selection function multiple times...
		// ignore that, calling tv->user_input() on a freshly lazy-instantiated textview discards the scroll position
		if (cur_chan == new_chan) return;
		
		new_chan->pgroup->last_focus = new_chan;
		
		bool has_focus = true;
		if (cur_chan)
		{
			has_focus = cur_chan->iv->has_focus();
			cur_chan->tv->user_input();
			
			// if activity was within last 2s, assume user didn't see it and leave channel marked as unread
			if (cur_chan->last_activity <= time(NULL)-DONT_MARK_READ_TIMEOUT)
				cur_chan->cvb_imp = chanbase::imp_none;
			if (cur_chan->last_activity <= time(NULL)-IDLE_TIMEOUT)
				cur_chan->cvb_imp = chanbase::imp_idle;
			
			cur_chan->set_color();
		}
		this->cur_chan = new_chan;
		cur_chan->tv->user_input();
		
		render(cur_chan);
		gtk_stack_set_visible_child(this->stack, GTK_WIDGET(cur_chan->grid));
		if (has_focus)
			cur_chan->iv->grab_focus();
		
		//cvb can be NULL during object construction
		if (cur_chan->cvb)
			cur_chan->cvb->color_fg(-1);
		
		gtk_window_set_title(wnd, new_chan->name+" - " APPNAME);
		
//#if !GTK_CHECK_VERSION(3,22,0)
		// workaround for some pixel cache invalidation bug, fixed long ago
		// to reproduce:
		// - switch to channel X
		// - switch away
		// - let 5 messages appear in channel X
		// - switch back to channel X
		// this is easiest done using the test protocol
		
		gtk_widget_set_sensitive(cur_chan->tv->gtkwidget(), false);
		gtk_widget_set_sensitive(cur_chan->tv->gtkwidget(), true);
//#endif
	}
	void cv_onclose_cb(void* userdata)
	{
		chanbase* chan = (chanbase*)userdata;
		chan->parent->close_chan(chan->userdata);
	}
};

group::group(protocol* parent, cstring name, uint32_t flags, uintptr_t userdata)
	: chanbase(parent, this, name, flags, userdata), last_focus(this)
{
	// keep this seemingly-pointless assignment, cv_focus_cb can get called by this chanview->child call
	cvb = NULL;
	cvb = parent->parent->cv->child(name, !(flags&f_no_focus), this);
	
	cvb->sort_as(parent->parent->ngroup++, "");
	if (flags&f_no_focus)
	{
		cvb->color_fg(0x666666); // if changing this, also change russian.h::chanbase::set_available
		cvb->set_strike(true);
	}
}
channel::channel(protocol* parent, group* pgroup, chanview::group* pchan, cstring name, uint32_t flags, uintptr_t userdata)
	: chanbase(parent, pgroup, name, flags, userdata)
{
	cvb = NULL;
	cvb = pchan->child(name, !(flags&f_no_focus), this);
	
	if (flags&f_no_focus)
	{
		cvb->color_fg(0x666666);
		cvb->set_strike(true);
	}
}
static string readlines(file& logfile, size_t& lines)
{
	string text = logfile.read(logfile.size());
	size_t start = text.length();
	if (!start) return "";
	start--; // the file always ends with a \n, which shouldn't be included
	while (start > 0)
	{
		if (text[start] == '\n')
		{
			lines--;
			if (lines == 0)
			{
				start++;
				break;
			}
		}
		start--;
	}
	return text.substr(start, ~0);
}
chanbase::chanbase(protocol* parent, group* pgroup, cstring name, uint32_t flags, uintptr_t userdata)
	: parent(parent), pgroup(pgroup), userdata(userdata), name(name)
{
	if (flags&f_no_focus)
	{
		flags |= f_no_logs|f_no_users;
	}
	this->flags = flags;
	
	for (size_t i=0;i<name.length();i++)
	{
		if (name[i] == '/') {}
		else if (name[i] == '.' && !name_fn) {}
		else name_fn += name[i];
	}
	
	string scrollback = "";
	
	if (!(flags&f_no_logs))
	{
		time_t now = time(NULL);
		log_open(logfile, now, true);
		logrotate = month_next(now);
		
		if (!(flags&f_no_scrollback))
		{
			size_t linesleft = 100;
			scrollback = readlines(logfile, linesleft);
			if (linesleft)
			{
				file prev;
				log_open(prev, month_prev(now), false);
				if (prev) scrollback = readlines(prev, linesleft)+scrollback;
			}
		}
		else logfile.seek(logfile.size());
	}
	scrollback = scrollback.replace(string::nul(), "");
	if (!scrollback.isutf8())
	{
		//can happen if two russians write the log simultaneously, or if someone manually mangles the local data
		scrollback = "[WARNING: corrupt scrollback]";
	}
	
	if (flags & f_no_focus)
	{
		this->tv = NULL;
		this->iv = NULL;
	}
	else
	{
		this->tv = textview::create();
		tv->scrollback(scrollback);
		tv->on_scroll_state(bind_this(&chanbase::tv_scroll_cb));
		
		this->iv = inputview::create(parent->valid_fmt);
		iv->set_onactivate(bind_this(&chanbase::input_cb));
		//iv->set_onmovecaret(bind_this(&chanbase::inputmove_cb));
		
		parent->parent->lazy_chans.append(this);
	}
	
	if (flags & f_no_users)
	{
		this->uv = NULL;
	}
	else
	{
		this->uv = userview::create();
		uv->onactivate(bind_this(&chanbase::uv_activate_cb));
	}
	
	this->grid = NULL;
	parent->parent->all_chans.add(this);
}
void chanbase::tv_scroll_cb(bool now_at_bottom)
{
	this->now_at_bottom = now_at_bottom;
	this->set_name();
	iv->set_warning(!now_at_bottom);
}
void chanbase::input_cb(cstring text) { parent->action(text, userdata); }
void chanbase::uv_activate_cb(cstring name) { parent->begin_private(name); }

time_t chanbase::month_prev(time_t t)
{
	struct tm stm;
	localtime_r(&t, &stm);
	
	stm.tm_sec = 0;
	stm.tm_min = 0;
	stm.tm_hour = 0;
	stm.tm_mday = 1;
	if (stm.tm_mon == 0)
	{
		stm.tm_year--;
		stm.tm_mon = 12;
	}
	stm.tm_mon--;
	
	return mktime(&stm);
}
time_t chanbase::month_start(time_t t)
{
	struct tm stm;
	localtime_r(&t, &stm);
	
	stm.tm_sec = 0;
	stm.tm_min = 0;
	stm.tm_hour = 0;
	stm.tm_mday = 1;
	
	return mktime(&stm);
}
time_t chanbase::month_next(time_t t)
{
	struct tm stm;
	localtime_r(&t, &stm);
	
	stm.tm_sec = 0;
	stm.tm_min = 0;
	stm.tm_hour = 0;
	stm.tm_mday = 1;
	stm.tm_mon++;
	if (stm.tm_mon == 12)
	{
		stm.tm_year++;
		stm.tm_mon = 0;
	}
	
	return mktime(&stm);
}

static const char * timefmt_short = "[%H:%M:%S] ";
static const char * timefmt_long = "[%Y-%m-%d %H:%M:%S] ";
static string timestr(time_t at, const char * fmt = NULL)
{
	struct tm at_tm = *localtime(&at);
	
	if (!fmt)
	{
		time_t now = time(NULL);
		struct tm now_tm = *localtime(&now);
		
		bool today = (now_tm.tm_year == at_tm.tm_year && now_tm.tm_yday == at_tm.tm_yday) || (at > now-900);
		fmt = (today ? timefmt_short : timefmt_long);
	}
	char buf[128];
	strftime(buf, sizeof(buf), fmt, &at_tm);
	return buf;
}
#define MKSPANS_NUM 1 // mkspans inserts this many spans before 'bodyspans'.
static array<span> mkspans(time_t at, arrayview<span> bodyspans)
{
	array<span> spans;
	if (bodyspans)
	{
		span headspans[] = {
			{ timestr(at) },
		};
		static_assert(ARRAY_SIZE(headspans) == MKSPANS_NUM);
		spans = headspans;
		spans += bodyspans;
	}
	return spans;
}
void chanbase::log_open(file& f, time_t at, bool create) const
{
	file::mkdir(file::exepath()+"logs/");
	file::mkdir(file::exepath()+"logs/"+pgroup->name_fn+"/");
	
	struct tm stm;
	localtime_r(&at, &stm);
	
	char timebuf[64];
	strftime(timebuf, sizeof(timebuf), " %Y-%m", &stm);
	f.open(file::exepath()+"logs/"+pgroup->name_fn+"/"+name_fn+timebuf+".log", create ? file::m_write : file::m_read);
}
void chanbase::log(time_t at, arrayview<span> spans)
{
	if (!logfile) return;
if (logfile.tell() != logfile.size())
{
debug_or_print();
logfile.seek(logfile.size());
}
	
	time_t now = time(NULL);
	if (now >= logrotate)
	{
		log_open(logfile, now, true);
		logrotate = month_next(now);
	}
	
	string tmp = timestr(at, timefmt_long);
	for (size_t i=0;i<spans.size();i++) tmp += spans[i].text.replace("\n", "\n               ");
	tmp += "\n";
	
	logfile.write(tmp);
}
void chanbase::message_at(cstring prev, bool after, cstring newid, bool is_scrollback,
                          importance_t imp, time_t at, arrayview<span> spans)
{
	if (this->parent->parent->cur_chan == this && last_activity < time(NULL)-2)
		cvb_imp = imp_none;
	cvb_imp = max(cvb_imp, imp);
	if (this->parent->parent->cur_chan != this)
		set_color();
	if (!is_scrollback)
		last_activity = max(last_activity, at);
	
	array<span> bodyspans = mkspans(at, spans);
	tv->message_at(prev, after, newid, bodyspans, is_scrollback);
	if (!is_scrollback) log(at, spans);
}
void chanbase::message_edit(cstring id, time_t at, arrayview<span> bodyspans, unsigned editslot)
{
	array<span> spans = mkspans(at, bodyspans);
	if (tv->message_exists(id))
	{
		tv->message_edit_visible(id, spans);
		spans[MKSPANS_NUM + editslot].text = "EDIT: "; // so logs show it as an edit
	}
	else
	{
		spans[MKSPANS_NUM + editslot].text = "EDIT: ";
		tv->message(id, spans);
	}
	log(at, spans.skip(MKSPANS_NUM));
}
void chanbase::message_delete(cstring id, time_t at)
{
	if (tv->message_exists(id))
		tv->message_edit_visible(id, NULL);
	//TODO: else print error
}
void chanbase::message_edit_true(cstring id, time_t at, arrayview<span> bodyspans)
{
	array<span> spans = mkspans(at, bodyspans);
	if (tv->message_exists(id))
		tv->message_replace(id, spans);
	//TODO: else print error
}
void chanbase::message_replace_image(cstring id, textview::image* prev, textview::image* next)
{
	if (tv->message_exists(id))
		tv->message_replace_image(id, prev, next);
	//TODO: else print error
}

void chanbase::rename(cstring newname)
{
	if (this->name == newname) return;
	if (this == this->parent->parent->cur_chan)
	{
		gtk_window_set_title(this->parent->parent->wnd, newname+" - " APPNAME);
	}
	this->name = newname;
	set_name();
}
void chanbase::set_name()
{
	cvb->rename((now_at_bottom ? "" : "â†‘ ") + this->name, this->name);
}
chanbase::~chanbase()
{
	//TODO: iirc the real fix for that bug was rearranging irc's members, I think this can safely be removed
	//if (parent->parent->cur_chan == this)
	//	parent->parent->cur_chan = nullptr; // deleting the chanview's row moves focus elsewhere, make sure that's harmless
	delete cvb; // delete this first, deleting the chanview makes textview switch to another channel and accesses buf
	if (tv) delete tv; // cvb always exists, others don't if channel was never focused, or if it's unfocusable
	if (uv) delete uv;
	if (iv) delete iv;
	if (grid) gtk_widget_destroy(GTK_WIDGET(grid));
	parent->parent->all_chans.remove(this);
}

unsigned protocol::get_line_height() { return parent->cur_chan->tv->lineheight(); }

}


int main(int argc, char** argv)
{
	// XInput2 likes to eat the first scroll event after the mouse entering the window
	// this function kills XI2 so I get sane behavior
	// this mostly shows up in chanview any_event_cb, but not exclusively
	gdk_disable_multidevice();
	
	arlib_init(NULL, argv);
	
setvbuf(stdout, NULL, _IONBF, 0);
rlimit lim;
lim.rlim_cur = 256*1024*1024;
lim.rlim_max = RLIM_INFINITY;
setrlimit(RLIMIT_CORE, &lim);
	
	russian::impl();
	return 0;
}
