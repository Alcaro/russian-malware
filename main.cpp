#include "arlib.h"
#include "russian.h"

#ifndef ARGUI_GTK3
#error gtk only
#endif

#define DEBUG_TEXTVIEW 1


#include <gtk/gtk.h>

#if !GTK_CHECK_VERSION(3,16,0)
#define GTK_POLICY_EXTERNAL GTK_POLICY_AUTOMATIC
#else
#error test the above
#endif

//a selection bound may not lie between a GdkPixbuf and the alt-text tag, or inside the tag
// if it does, it must be put on the far side of the image
//since the alt-text tag always lies to the right of the image, this simplifies to
// 'if a selection bound points inside, or to the start of, an alt-ext tag, move it to the end of said tag'
//which further simplifies to 'if the pointed-to character is inside the tag, move to after the tag end'
GtkTextIter img_alt_adjusted_iter_from_mark(GtkTextBuffer* buffer,
                                  GtkTextMark* mark,
                                  GtkTextTag* tag,
                                  bool* do_move)
{
	GtkTextIter ret;
	gtk_text_buffer_get_iter_at_mark(buffer, &ret, mark);
	if (gtk_text_iter_has_tag(&ret, tag))
	{
		*do_move = true;
		gtk_text_iter_forward_to_tag_toggle(&ret, tag);
	}
	return ret;
}

void img_alt_update_selection(GtkTextBuffer* buffer, GtkTextTag* tag)
{
	bool do_move = false;
	GtkTextIter insert = img_alt_adjusted_iter_from_mark(buffer, gtk_text_buffer_get_insert(         buffer), tag, &do_move);
	GtkTextIter sbound = img_alt_adjusted_iter_from_mark(buffer, gtk_text_buffer_get_selection_bound(buffer), tag, &do_move);
	
	if (do_move)
	{
		gtk_text_buffer_select_range(buffer, &insert, &sbound);
	}
}

void img_alt_on_select(GObject* gobject, GParamSpec* pspec, gpointer user_data)
{
	img_alt_update_selection(GTK_TEXT_BUFFER(gobject), GTK_TEXT_TAG(user_data));
}

void gtk_text_buffer_prepare_pixbuf_with_alt(GtkTextBuffer* buffer)
{
	GtkTextTag* tag = gtk_text_tag_table_lookup(gtk_text_buffer_get_tag_table(buffer), "select-only");
	if (!tag)
	{
		tag = gtk_text_tag_new("select-only");
#if DEBUG_TEXTVIEW
		g_object_set(tag, "scale", (gdouble)0.5, NULL);
#else
		g_object_set(tag, "scale", (gdouble)0, NULL);
#endif
		gtk_text_tag_table_add(gtk_text_buffer_get_tag_table(buffer), tag);
	}
	
	//this doesn't do anything if selection-bound moves without cursor moving, but as far as I've seen,
	// user can't move it to any place other than 'right where main cursor is' which is always a valid position
	//(okay, code can move it, but it won't.)
	g_signal_connect(buffer, "notify::cursor-position", G_CALLBACK(img_alt_on_select), tag);
}

//The alt-text is copied if the image is selected and user presses Ctrl-C.
//WARNING: Messes up keyboard navigation. If using this, turn off cursor visibility and make the GtkTextView readonly.
//Known bugs if you don't:
//- Backspacing the image removes the alt-text, one character at the time
//- Left arrow has no effect if beside an image, you end up back where you started
//Mouse selection is (as far as I know) bug-free.
void gtk_text_buffer_insert_pixbuf_with_alt(
              GtkTextBuffer* buffer, GtkTextIter* iter, GdkPixbuf* pixbuf, const gchar * text, gint len)
{
	GtkTextTag* texttag = gtk_text_tag_table_lookup(gtk_text_buffer_get_tag_table(buffer), "select-only");
	
	//size_t pos = gtk_text_iter_get_offset(iter);
	gtk_text_buffer_insert_pixbuf(buffer, iter, pixbuf);
	
	//unusable - only the left half of my image gets events
	//GtkTextTag* imgtag = gtk_text_tag_table_lookup(gtk_text_buffer_get_tag_table(buffer), "img-hover");
	//if (!imgtag)
	//{
	//	imgtag = gtk_text_tag_new("img-hover");
	//	g_signal_connect(imgtag, "event", G_CALLBACK(img_alt_on_imgevent), texttag);
	//	gtk_text_tag_table_add(gtk_text_buffer_get_tag_table(buffer), imgtag);
	//}
	//
	//GtkTextIter iter_orig;
	//gtk_text_buffer_get_iter_at_offset(buffer, &iter_orig, pos);
	//gtk_text_buffer_apply_tag(buffer, imgtag, &iter_orig, iter);
	
	gtk_text_buffer_insert_with_tags(buffer, iter, text, len, texttag, NULL);
}





class widget_gtk : public widget_base { WIDGET_BASE
public:
	widget_gtk(uint8_t widthprio, uint8_t heightprio, GtkWidget* widget)
	{
		this->widget = widget;
		this->widthprio = widthprio;
		this->heightprio = heightprio;
	}
};
#define widget_create_gtk(...) (new widget_gtk(__VA_ARGS__))

class chanview {
	enum {
		col_name,
		col_attr,
		col_userdata,
		col_count
	};
	GtkTreeStore* store;
	GtkTreeView* view;
	
	function<void(void* userdata)> focus_cb;
	
	chanview()
	{
		store = gtk_tree_store_new(3, G_TYPE_STRING, PANGO_TYPE_ATTR_LIST, G_TYPE_POINTER);
		
		view = GTK_TREE_VIEW(gtk_tree_view_new());
		
		GtkTreeViewColumn* col = gtk_tree_view_column_new();
		GtkCellRenderer* renderer = gtk_cell_renderer_text_new();
		gtk_tree_view_append_column(view, col);
		gtk_tree_view_column_pack_start(col, renderer, TRUE);
		gtk_tree_view_column_add_attribute(col, renderer, "text", 0);
		gtk_cell_renderer_text_set_fixed_height_from_font(GTK_CELL_RENDERER_TEXT(renderer), 1);
		
		gtk_tree_view_set_model(view, GTK_TREE_MODEL(store));
		gtk_tree_selection_set_mode(gtk_tree_view_get_selection(view), GTK_SELECTION_BROWSE);
		gtk_tree_view_set_headers_visible(view, false);
		
		gtk_tree_view_set_enable_tree_lines(view, true);
		gtk_tree_view_expand_all(view);
		
		g_signal_connect(G_OBJECT(gtk_tree_view_get_selection(view)), "changed", G_CALLBACK(onfocus_sig_nat), this);
		
		//TODO: do I enable these?
		gtk_tree_view_set_show_expanders(view, false);
		gtk_tree_view_set_level_indentation(view, 19);
		
		//TODO: figure out if this is helpful or annoying
		gtk_tree_view_set_hover_selection(view, true);
	}
	
	
public:
	enum color_t {
		c_none,
		c_low, // someone joined/etc
		c_msg,
		c_highlight
	};
	
private:
	class chanbase : nocopy {
		friend class chanview;
	protected:
		chanview* parent;
		GtkTreeRowReference* row;
		
		chanbase(chanview* parent, GtkTreeRowReference* parentrow, cstring name, void* userdata)
		{
			this->parent = parent;
			
			GtkTreeIter parentiter;
			
			if (parentrow)
			{
				GtkTreePath* path = gtk_tree_row_reference_get_path(parentrow);
				gtk_tree_model_get_iter(GTK_TREE_MODEL(parent->store), &parentiter, path);
				gtk_tree_path_free(path);
			}
			
			GtkTreeIter iter;
			gtk_tree_store_append(parent->store, &iter, parentrow ? &parentiter : NULL);
			gtk_tree_store_set(parent->store, &iter,
			                   col_name, (const char*)name.c_str(),
			                   col_userdata, userdata,
			                   -1);
			
			GtkTreePath* path = gtk_tree_model_get_path(GTK_TREE_MODEL(parent->store), &iter);
			this->row = gtk_tree_row_reference_new(GTK_TREE_MODEL(parent->store), path);
			gtk_tree_view_expand_to_path(parent->view, path);
			gtk_tree_path_free(path);
		}
		
	public:
		void color();
		//if the notification is dismissed in one of these channels, they all turn black
		static void color(arrayview<chanbase> group);
		
	protected:
		~chanbase() {} // TODO
	};
	
public:
	class channel : public chanbase {
		friend class chanview;
		channel(chanview* parent, GtkTreeRowReference* parentrow, cstring name, void* userdata) : chanbase(parent, parentrow, name, userdata) {}
		
	public:
		
		~channel() {} // TODO
	};
	
	//'Guild' is a stupid name for IRC, but calling it Server on Discord is even dumber, and they need the same name.
	//IRC has an irritating mix between Server/Network, anyways, so neither of those names is fully appropriate.
	class guild : public chanbase {
		friend class chanview;
		guild(chanview* parent, GtkTreeRowReference* parentrow, cstring name, void* userdata) : chanbase(parent, parentrow, name, userdata) {}
		
	public:
		channel* child(cstring name, void* userdata)
		{
			return new channel(parent, row, name, userdata);
		}
		
		~guild() {} // TODO
	};
	
	static chanview* create()
	{
		return new chanview();
	}
	GtkWidget* gtkwidget()
	{
		return GTK_WIDGET(view);
	}
	
private:
	static void onfocus_sig_nat(GtkTreeSelection* sel, void* userdata)
	{
		chanview* this_ = (chanview*)userdata;
		this_->onfocus_sig(sel);
	}
	void onfocus_sig(GtkTreeSelection* sel)
	{
		GtkTreeModel* model;
		GtkTreeIter iter;
		
		if (gtk_tree_selection_get_selected(sel, &model, &iter))
		{
			void* userdata;
			gtk_tree_model_get(model, &iter, col_userdata, &userdata, -1);
			this->focus_cb(userdata);
		}
	}
public:
	//There's only one onfocus function per channel view object, but the userdata can vary per guild/channel.
	void onfocus(function<void(void* userdata)> callback)
	{
		focus_cb = callback;
	}
	
	//If userdata is NULL, the guild root can't be focused. Use if there is no obvious equivalent of IRC's server tab.
	guild* child(cstring name, void* userdata)
	{
		return new guild(this, NULL, name, userdata);
	}
	
	~chanview() {} // TODO
};

GtkTextView* textview;
GtkTextTagTable* texttags;





//class widget_tree : public widget_base { WIDGET_BASE
//};
//#define widget_create_tree(...) (new widget_tree(__VA_ARGS__))





void add_image(GtkTextBuffer* buf, cstring path)
{
	GtkTextIter pos;
	
	static const uint8_t bytesraw[] = {
		0x47,0x49,0x46,0x38,0x39,0x61,0x10,0x00,0x10,0x00,0xf2,0x00,0x00,0x00,0x00,0x00,
		0x8c,0x59,0x18,0xde,0xa2,0x39,0xff,0xfb,0x00,0xff,0xdb,0x21,0xef,0xf3,0xff,0x00,
		0x00,0x00,0x00,0x00,0x00,0x21,0xf9,0x04,0x01,0x00,0x00,0x06,0x00,0x2c,0x00,0x00,
		0x00,0x00,0x10,0x00,0x10,0x00,0x00,0x03,0x45,0x08,0xb6,0xdc,0x0d,0xd0,0x49,0x03,
		0x41,0x51,0x73,0x59,0x78,0xb1,0xdc,0xd0,0x50,0x7d,0x62,0x04,0x94,0x1e,0x85,0x6a,
		0x44,0x85,0x01,0xed,0xc8,0xba,0xb0,0xfb,0xd0,0xb8,0x83,0xdb,0xdf,0xee,0x04,0x40,
		0x8d,0x0c,0x18,0x30,0x04,0x06,0x03,0x42,0xf1,0xd4,0x32,0x12,0x90,0xc5,0x00,0x41,
		0xa0,0x94,0x56,0xa7,0x4a,0x06,0x11,0x8b,0x25,0x4e,0x88,0xde,0x46,0x02,0x00,0x3b
	};
	arrayview<byte> bytes = bytesraw;
	
	//too slow
	//should be enabled at some point, but not now
	//array<byte> bytes = file::read(path);
	
	GInputStream* is = g_memory_input_stream_new_from_data(bytes.ptr(), bytes.size(), NULL);
	GdkPixbuf* pix = gdk_pixbuf_new_from_stream_at_scale(is, 16, 16, true, NULL, NULL);
	
	gtk_text_buffer_get_selection_bounds(buf, &pos, NULL);
	gtk_text_buffer_insert_pixbuf_with_alt(buf, &pos, pix, path.c_str(), -1);
	
	g_object_unref(is);
	g_object_unref(pix);
}

//void do_stdin(uintptr_t fd)
//{
	//char line[4096];
	//size_t len = read(fd, line, 4095);
	//if (len > 0 && line[len-1] == '\n') len--;
	//line[len] = '\0';
	//
	//add_image(line);
//}

GtkWidget* gtk_wrap_scroll(GtkPolicyType horz, GtkPolicyType vert, GtkWidget* child)
{
	GtkScrolledWindow* scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	gtk_scrolled_window_set_policy(scrollview, horz, vert);
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), child);
	return GTK_WIDGET(scrollview);
}

GtkWidget* gtk_wrap_minsize(int x, int y, GtkWidget* widget)
{
	gtk_widget_set_size_request(widget, x, y);
	return widget;
}


GtkTextBuffer* make_textbuf()
{
	GtkTextBuffer* buf = gtk_text_buffer_new(texttags);
	gtk_text_buffer_prepare_pixbuf_with_alt(buf);
	return buf;
}

GtkTextBuffer* make_textbuf_with(size_t n)
{
	GtkTextBuffer* buf = make_textbuf();
	
	while (n)
	{
		gtk_text_buffer_insert_at_cursor(buf, "mun", -1);
		add_image(buf, "https://floating.muncher.se/muncher.png");
		gtk_text_buffer_insert_at_cursor(buf, "cher", -1);
		
		n--;
	}
	
	return buf;
}


int main(int argc, char * argv[])
{
	window_init(&argc, &argv);
	
	texttags = gtk_text_tag_table_new();
	textview = GTK_TEXT_VIEW(gtk_text_view_new());
	
	gtk_text_view_set_wrap_mode(textview, GTK_WRAP_WORD_CHAR);
	
#if !DEBUG_TEXTVIEW
	gtk_text_view_set_editable(textview, false);
	gtk_text_view_set_cursor_visible(textview, false);
#endif
	
	
	
	
	chanview* chans = chanview::create();
	chanview::guild*   chan1 = chans->child("1 Muncher",  make_textbuf_with(1));
	chanview::channel* chan2 = chan1->child("2 Munchers", make_textbuf_with(2));
	chanview::guild*   chan3 = chans->child("3 Munchers", make_textbuf_with(3));
	chans->onfocus([](void* userdata){ gtk_text_view_set_buffer(textview, GTK_TEXT_BUFFER(userdata)); });
	
	
	
	
	
	window* wnd = window_create(
		widget_create_layout_horz(
			widget_create_gtk(3, 4,
				gtk_wrap_minsize(60, 0,
					gtk_wrap_scroll(GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC,
						chans->gtkwidget()
					)
				)
			),
			widget_create_layout_vert(
				widget_create_gtk(4, 4,
					//I'd rather have NEVER than this one, but that makes textview refuse to shrink if that would change word wrapping
					gtk_wrap_scroll(GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC,
						GTK_WIDGET(textview)
					)
				),
				widget_create_textbox()
			)
		)
	);
	
	
	wnd->set_visible(true);
	wnd->set_resizable(true, NULL);
	wnd->set_title("ЯUSSIAN MALWДRE");
	wnd->resize(571, 665);
	
	wnd->set_onclose(&window::exit_runloop);
	
	//runloop::global()->set_fd(0, do_stdin);
	runloop::global()->enter();
	
	delete wnd;
}
