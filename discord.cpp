#include "russian.h"
#include "discord.h"
#include "firefox.h"

// TODO: enable nocopy
// TODO: m_ws_coro lifecycle management is becoming increasingly obnoxious

#define FAKE_CONNECT 0

#if FAKE_CONNECT
#define DEBUG_ONLY
#else
#define FAKE_CONNECT 0
#endif

namespace russian {
namespace {
class snowflake {
	uint64_t n;
public:
	snowflake() { n = 0; }
	snowflake(uint64_t n) { this->n = n; }
	snowflake(cstring str) { fromstring(str, n); }
	snowflake(const JSON& json) { fromstring(json.str(), n); }
	bool init(cstring str) { return fromstring(str, n); }
	
	string str() const { return tostring(n); }
	explicit operator string() const { return tostring(n); }
	
	uint64_t num() const { return n; }
	uint64_t hash() const { return n; }
	
	explicit operator bool() const { return n != 0; }
	bool operator!() const { return n == 0; }
	
	bool operator==(const snowflake& other) const { return n == other.n; }
	bool operator!=(const snowflake& other) const { return n != other.n; }
	
	using serialize_as = string;
};
static bool operator==(cstring a, const snowflake& b) { uint64_t an; return fromstring(a, an) && b.num() == an; }

class discord : public protocol {
public:

#define USER_AGENT "ðŸ‡·ðŸ‡º" // russian flag

static string token_from_firefox(cstring email)
{
	auto[ret_email, ret_token] = firefox_profile::get_default().get_localstorage("discord.com", "email_cache", "token");
	if (ret_email == "\""+email+"\"" && ret_token)
		return ret_token.substr(1, ~1);
	else
		return "";
}

string m_server_base; // https://discord.com/api
string m_server_gateway; // wss://gateway.discord.gg/
string m_server_img; // https://cdn.discordapp.com/ // no migration plans for the forseeable future (2020-07-17)
bool m_gateway_good = false;

string m_email;
string m_token;
bool m_token_is_config;
snowflake m_my_id;
bool m_first_run = false;

websocket m_ws;
http_t m_http;
co_holder m_http_waiters;
waiter<void> m_ws_coro;
bool m_ws_coro_running = false;

bool m_enable_avatars = true;

bool m_should_heartbeat;
bool m_heartbeat_sent;
waiter<void> m_heartbeat_coro;
int m_heartbeat_interval = 30000;
time_t m_last_activity;

string m_resume_token;
string m_resume_token_prev;
int m_sequence = 0; // sequence number, for heartbeats and resumption

bool m_ping_reply = false;

bool m_fatal = false;

russian::channel* m_tmp_msg_in = NULL;

struct guild;
struct channel;
struct message;
struct user;
struct role;

struct message : nocopy {
	string id; // snowflake, plus suffix for attachments/etc (TODO: use plain snowflake, attachments should be a single message)
	snowflake author;
	
	string name_override; // for webhooks
	string avatar_override;
	
	string text;
	bool is_highlight = false;
	time_t at;
	snowflake reply_user;
	time_t reply_time = 0;
	
	bool has_thread = false; // not serialized
	
	void serialize(auto& s)
	{
		s.items("id", id,
		        "user", author,
		        "text", text,
		        "highlight", ser_include_if_true(is_highlight),
		        "time", at,
		        "user_name", ser_include_if_true(name_override),
		        "user_avatar", ser_include_if_true(avatar_override),
		        "reply_user", ser_include_if(reply_user!=snowflake(), reply_user),
		        "reply_time", ser_include_if_true(reply_time));
	}
};
enum vis_t : uint8_t {
	v_closed,   // hidden via config or manual close; appears via highlight or query activity
	v_no,       // hidden, but appears if unmuted server-side (server-side mute state is currently unknown)
	v_ifactive, // hidden, but appears if active, like queries (ignores server-side mute state)
	v_yes,      // visible
};
enum mute_t : uint8_t {
	m_no,
	m_dontknow,
	m_yes,
};
struct overrideable_name {
	string upstream;
	string override_to;
	string override_from;
	
	cstring get(cstring fallback = "<unknown>") const
	{
		if (override_to && (!override_from || upstream == override_from))
			return override_to;
		if (upstream) return upstream;
		return fallback;
	}
};
//expected guild channel visibility behavior: show if one or more of
//- guild channel unhidden in config
//- guild channel unmuted on server, and not hidden in config
//- guild channel unmuted in cache, and not hidden in config
//- guild channel highlight while online
//- guild channel highlight while offline
//- query unhidden in config (query hidden in config makes no difference)
//- query activity while online
//- query activity while offline
//cache: hidden if muted; if guild not connected, hidden if channel is currently hidden
struct channel : nocopy {
	guild* parent = NULL;
	
	vis_t visible = v_no;
	mute_t muted = m_dontknow; // server-side only; ignored for queries (if a query is consistently active, list it in the config)
	bool used = false; // set to true upon server confirmation of its existence; if false, but guild is used, remove from cache
	bool warned = false; // so /resume doesn't print every channel twice if servers change into something weird
	
	bool force_fetch_messages = false;
	
	snowflake id;
	overrideable_name name;
	
	autoptr<russian::channel> host;
	
	// can contain a message with only id, blank author/text/time
	// that one tells how much of the scrollback is read, and is useful only if no other messages exist
	array<message> scrollback;
	snowflake last_msg; // according to GUILD_CREATE::channel
	snowflake last_fetched_msg; // set to above on fetch success
	
	snowflake parent_id; // for threads; 0 if it's a normal channel
	
	//void nextmsg(cstring id, snowflake author, cstring text, bool is_highlight, time_t at)
	//{
	//	message& m = scrollback.append();
	//	m.id = id;
	//	m.author = author;
	//	m.text = text;
	//	m.is_highlight = is_highlight;
	//	m.at = at;
	//	
	//	//keep 300 messages, to ensure it won't go below 250 even if some messages are deleted
	//	if (scrollback.size() > 500)
	//		scrollback.remove_range(0, scrollback.size()-300);
	//}
	
	void nextmsg(message m)
	{
		scrollback.append(std::move(m));
		
		//keep 300 messages, to ensure it won't go below 250 even if some messages are deleted
		if (scrollback.size() > 500)
			scrollback.remove_range(0, scrollback.size()-300);
	}
	
	void setmsg(cstring id, cstring text)
	{
		for (size_t i=0;i<scrollback.size();i++)
		{
			message& m = scrollback[i];
			if (m.id == id)
			{
				if (text) m.text = text;
				else scrollback.remove(i);
				break;
			}
		}
	}
	
	message* get_msg_by_id(cstring id)
	{
		for (message& m : scrollback)
		{
			if (m.id == id) return &m;
		}
		return NULL;
	}
};
struct role : nocopy {
	guild* parent = NULL;
	snowflake id;
	overrideable_name name;
	
	bool used = false; // contents have been sent in Ready or Guild Create
	bool pingable = false;
	// TODO: don't fetch channels current user can't access, and highlight pings for current user's roles
};
struct guildemoji : nocopy {
	bool animated;
	snowflake id;
	string name;
	
	void serialize(auto& s)
	{
		s.items(
			"animated", ser_include_if_true(animated),
			"id", id,
			"name", name
		);
	}
};
struct guild : nocopy {
	snowflake id;
	overrideable_name name;
	bool online = false; // currently connected
	bool online_resume = false; // whether we'd be connected if we got a Resumed right now (false if fully connected)
	bool exists = false; // exists according to Ready
	bool used = false; // contents have been sent in Ready or Guild Create
	array<channel*> channels;
	array<guildemoji> emoji;
	array<role*> roles;
	autoptr<russian::group> host;
};

array<autoptr<guild>> m_guilds; // the first one is always for private messages or groupchats, with id "0" and name taken from config
array<autoptr<channel>> m_channels;
array<autoptr<role>> m_roles;
array<guild*> m_guild_order;
map<snowflake,guild*> m_guild_index;
map<snowflake,channel*> m_channel_index;
map<snowflake,role*> m_role_index;

struct user : nocopy {
	snowflake id;
	overrideable_name name;
	
	bool used = false;
	bool is_webhook = false;
	
	bool mute_ping = false;
	bool mute_activity = false;
	bool mute_sponge = false;
	bool mute_loose_u = false;
	bool mute_guildemoji = false;
	bool mute_delete = false;
	
	int8_t ping_reply = -1; // -1 - see parent, 0 - don't ping, 1 - yes ping
	
	string avatar; // hex blob, or blank
};
map<snowflake,user> m_users;

autoptr<discord_emoji> m_emoji;
autoptr<discord_format> m_format;
array<const discord_emoji::emoji*> m_emoji_avatars; // always sorted same way each run, same order as emoji.json

channel* m_current_msg_chan; // only used, and only valid, in the format_external callback
cstring m_current_msg; // most of the time, it's a dangling pointer
                       // used to set m_guildemoji_unloaded

string m_cachename;

file m_rawlog;

struct scrollback_data {
	snowflake chan;
	snowflake msg_from;
	time_t time_from;
};
array<scrollback_data> m_fetch_scrollback;
waiter<void> m_scrollback_coro;


enum status_t { st_game, st_stream, st_listen, st_watch, st_custom, st_none = -1 };

status_t m_status_type = st_none;
string m_status;

void set_visible_status(status_t type, cstring text)
{
	m_status_type = type;
	m_status = text;
	if (m_ws)
		send_visible_status();
}

void send_visible_status()
{
	JSONw json;
	json["op"] = 3; // Status Update
	json["d"]["since"] = nullptr;
	if (m_status_type == st_none)
	{
		json["d"]["game"] = nullptr;
	}
	if (m_status_type == st_game)
	{
		json["d"]["game"]["type"] = st_game;
		json["d"]["game"]["name"] = m_status;
	}
	if (m_status_type == st_custom)
	{
		json["d"]["activities"][0]["type"] = st_custom;
		json["d"]["activities"][0]["name"] = "Custom Status";
		json["d"]["activities"][0]["state"] = m_status;
	}
	json["d"]["status"] = "online";
	json["d"]["afk"] = false;
	send_ws(json);
}


guild* dm_guild() { return m_guilds[0]; }
bool is_dm_guild(guild* g) { return g == dm_guild(); }
guild* guild_for(snowflake id)
{
	guild* g = m_guild_index.get_or(id, NULL);
	if (LIKELY(g)) return g;
	guild* ret = m_guilds.append(new guild);
	m_guild_order.append(ret);
	m_guild_index.insert(id, ret);
	ret->id = id;
	return ret;
}

channel* channel_for(snowflake id)
{
	channel* c = m_channel_index.get_or(id, NULL);
	if (LIKELY(c)) return c;
	channel* ret = m_channels.append(new channel);
	m_channel_index.insert(id, ret);
	ret->id = id;
	return ret;
}
channel* channel_for(snowflake id, guild* g)
{
	channel* c = channel_for(id);
	if (UNLIKELY(!c->parent))
	{
		c->parent = g;
		g->channels.append(c);
	}
	return c;
}

role* role_for(snowflake id)
{
	role* r = m_role_index.get_or(id, NULL);
	if (LIKELY(r)) return r;
	role* ret = m_roles.append(new role);
	m_role_index.insert(id, ret);
	ret->id = id;
	return ret;
}
role* role_for(snowflake id, guild* g)
{
	role* r = role_for(id);
	if (UNLIKELY(!r->parent))
	{
		r->parent = g;
		g->roles.append(r);
	}
	return r;
}

cstring guild_name(guild* g, cstring fallback = "<unknown>") { return g->name.get(fallback); }
void guild_host(guild* g)
{
	cstring name = guild_name(g);
	if (!name) return;
	if (!g->host) g->host = mkgroup(name, chanbase::f_no_focus, NULL);
	g->host->set_available(g->online);
	g->host->rename(name);
}
cstring channel_name(channel* c, cstring fallback = "<unknown>") { return c->name.get(fallback); }
void channel_host(channel* c)
{
	cstring name = channel_name(c, "");
	if (!name)
	{
		if (!c->warned)
			status("ERROR: anonymous channel "+c->id.str());
		c->warned = true;
		name = "<unknown>";
	}
	if (!c->parent)
	{
		if (!c->warned)
			status("ERROR: guildless channel "+c->id.str());
		c->warned = true;
		c->parent = dm_guild();
	}
	guild* g = c->parent;
	if (!c->host) c->host = g->host->child(name, chanbase::f_no_scrollback, c);
	c->host->set_hidden(c->visible <= v_ifactive);
	c->host->set_available(g->online && c->used);
	c->host->rename(name);
	if (c->parent_id)
	{
		// TODO: sort threads after their respective channels, not just at bottom
		// probably by making channels properly nestable
		c->host->sort_idx(1);
		//channel* cp = m_channel_index.get_or(c->parent_id, NULL);
		//if (cp) c->host->sort_as(channel_name(cp) + string::nul() + name);
	}
}

cstring role_name(role* r, cstring fallback = "<unknown>") { return r->name.get(fallback); }

void rename_all()
{
	for (guild* g : m_guilds)
	{
		if (g->host)
			guild_host(g);
	}
	for (channel* c : m_channels)
	{
		if (c->host)
			channel_host(c);
	}
}

user* user_for_id(snowflake id, bool mark_used = true)
{
	user* u = &m_users.get_create(id);
	u->id = id;
	if (mark_used)
		u->used = true;
	return u;
}
user* user_for(const JSON& json, bool is_webhook)
{
	user* u = user_for_id(json["id"]);
	if (!is_webhook)
	{
		// username is the account name, lowercase and unique; don't know what these two are
		if (json["global_name"])
		{
			u->name.upstream = json["global_name"];
			if (json["display_name"] && json["display_name"].str() != json["global_name"].str())
				status("* Encountered user with both display and global names");
		}
		else if (json["username"])
		{
			u->name.upstream = json["username"];
			if (json["discriminator"])
			{
				uint16_t dis;
				if (fromstring(json["discriminator"], dis))
				{
					char buf[6];
					buf[0] = '#';
					tostring_ptr(buf+1, dis, 4);
					buf[5] = '\0';
					u->name.upstream += buf;
				}
			}
		}
		u->avatar = json["avatar"];
	}
	return u;
}
//Takes a User object, returns the username. Handles overridden names, and caches the name, in case the next call contains only ID.
//Does not support guild-specific nicks.
string username(const JSON& json, bool is_webhook)
{
	return username(user_for(json, is_webhook));
}
string username_for_id(snowflake id)
{
	user* u = m_users.get_or_null(id);
	if (u) return username(u);
	else return id.str();
}
string username(user* u, bool mark_used = true)
{
	if (mark_used) u->used = true;
	cstring ret = u->name.get("");
	if (ret) return ret;
	else return u->id.str();
}


//Sanitizes NUL and bad utf8, hex encoding the offending bytes and painting them red.
static void sanitize_spans(array<span>& out, size_t start = 0)
{
	for (size_t i = start; i < out.size(); i++)
	{
		if (UNLIKELY(out[i].text.contains_nul() || !out[i].text.isutf8()))
		{
			string danger = std::move(out[i].text); // clear out[i].text, format spans shouldn't have text
			span fmt = out.pop(i);
			
			//one span per character, it's easier and this code is super cold
			uint32_t out_idx = i;
			uint32_t idx = 0;
			while (idx < danger.length())
			{
				uint32_t cp = danger.codepoint_at(idx);
				if (cp == 0 || (cp >= 0xDC80 && cp <= 0xDCFF))
				{
					span& newsp = out.insert(out_idx++, fmt);
					newsp.fgcol = 0xFF0000;
					newsp.text = tostringhex<2>(cp&0xFF);
				}
				else
				{
					span& newsp = out.insert(out_idx++, fmt);
					newsp.text = string::codepoint(cp);
				}
			}
		}
	}
}


void status(time_t at, cstring text, chanbase::importance_t imp = chanbase::imp_status)
{
	span sp[1] = { { text } };
	puts(sp[0].text);
	if (imp == chanbase::imp_highlight) sp[0].fgcol = 0xFF0000;
	dm_guild()->host->message(imp, at, sp);
}
void status(cstring text, chanbase::importance_t imp = chanbase::imp_status)
{
	status(time(NULL), text, imp);
}
void fatal(cstring text)
{
m_fatal = true;
	span sp[1] = { { text } };
	sp[0].fgcol = 0xFF0000;
	dm_guild()->host->message(chanbase::imp_highlight, time(NULL), sp);
	dm_guild()->host->rename("ERROR - "+guild_name(dm_guild()));
	
	m_heartbeat_coro.cancel();
	m_ws_coro.cancel();
}
discord(impl* parent, json5deserializer2& s) : protocol(parent, fmt_b|fmt_k|fmt_o|fmt_m|fmt_i|fmt_s|fmt_u)
{
	guild* g_root = guild_for(cstring("0"));
	
	struct name_override {
		snowflake snow;
		cstring override_name;
		cstring override_name_from;
		void serialize(json5deserializer2& s)
		{
			SER_ENTER(s)
			{
				s.item("id", snow);
				s.item("name", override_name);
				s.item("rename-from", override_name_from);
			}
		}
	};
	array<name_override> guild_overrides; // so internal guild order matches cache, even if the config contains something
	array<name_override> role_overrides; // config doesn't know what guild a role is in
	
	string emoji_fname;
	string rawlog_fname;
	uint32_t inactive_hours = 48;
	
	SER_ENTER(s)
	{
		s.item("name", g_root->name.upstream);
		s.item("server", m_server_base);
		s.item("imgserver", m_server_img);
		s.item("email", m_email);
		s.item("token", m_token);
		s.item("emoji", emoji_fname);
		s.item("rawlog", rawlog_fname);
		s.item("cache", m_cachename);
		s.item("avatars", m_enable_avatars);
		s.item("inactive-hours", inactive_hours);
		s.item("ping", m_ping_reply);
		s.item("guilds", guild_overrides);
		s.item("roles", role_overrides);
		
		SER_NAME(s, "channels")
		{
			SER_ENTER_ARRAY(s)
			{
				uint64_t snow;
				cstring hidden_s;
				cstring mute_s;
				cstring override_name;
				cstring override_name_from;
				
				s.items("id", snow, "hidden", hidden_s, "mute", mute_s, "name", override_name, "rename-from", override_name_from);
				
				channel* c = channel_for(snow);
				bool hidden_b;
				if (hidden_s == "activity")
					c->visible = v_ifactive;
				else if (fromstring(hidden_s, hidden_b))
					c->visible = hidden_b ? v_closed : v_yes;
				bool mute_b;
				if (fromstring(mute_s, mute_b))
					c->muted = (mute_b ? m_yes : m_no);
				c->name.override_to = override_name;
				c->name.override_from = override_name_from;
			}
		}
		
		SER_NAME(s, "users")
		{
			SER_ENTER_ARRAY(s)
			{
				uint64_t snow;
				int8_t ping = -1;
				cstring override_name;
				cstring override_name_from;
				array<cstring> mutes;
				
				SER_ENTER(s)
				{
					s.item("id", snow);
					s.item("mute", mutes);
					SER_NAME(s, "ping") { bool ping2 = false; s.item(ping2); ping = ping2; }
					s.item("ping", ping);
					s.item("id", snow);
					s.item("name", override_name);
					s.item("rename-from", override_name_from);
				}
				
				user* u = user_for_id(snow);
				u->ping_reply = ping;
				for (cstring type : mutes)
				{
					if (type == "ping") u->mute_ping = true;
					if (type == "activity") u->mute_activity = true;
					if (type == "sponge") u->mute_sponge = true;
					if (type == "loose-u") u->mute_loose_u = true;
					if (type == "guildemoji") u->mute_guildemoji = true;
					if (type == "delete") u->mute_delete = true;
				}
				u->name.override_to = override_name;
				u->name.override_from = override_name_from;
			}
		}
		
		SER_NAME(s, "game")
		{
			m_status_type = st_game;
			s.item("game", m_status);
		}
		SER_NAME(s, "status")
		{
			m_status_type = st_custom;
			s.item("status", m_status);
		}
	}
	
	g_root->host = mkgroup(g_root->name.upstream, chanbase::f_no_logs|chanbase::f_no_users, NULL);
	
	if (!m_server_base) { fatal("No server configured"); return; }
	if (!m_server_img) { fatal("No image server configured"); return; }
	
	if (!m_email) { fatal("No email address configured"); return; }
	m_token_is_config = (bool)m_token;
	if (!m_token) m_token = token_from_firefox(m_email);
	if (!m_token) { fatal("No token found"); return; }
	
	m_http.wrap_socks(&autoproxy::socket_create_sslmaybe);
	m_ws.wrap_socks(&autoproxy::socket_create_sslmaybe);
	
	if (emoji_fname)
	{
		m_emoji = discord_emoji::create(file::readall(file::resolve(file::exedir(), emoji_fname)), get_line_height());
		if (m_emoji->list().size() == 0)
			status("ERROR: Couldn't load emoji library, some messages may be misparsed");
		else if (m_emoji->list().size() != 3683+3) // 3683 images + r/c/tm
			status("WARNING: Improper emoji library loaded, some messages may be misparsed");
		
		for (const discord_emoji::emoji* em : m_emoji->list())
		{
			if (!em->has_image()) continue;
			
			uint32_t n = 0;
			// and is not a ligature (most of them are duplicates (skin color) or likely provably inaccurate (flags)),
			// then it's usable as avatar
			// exceptions: the keycaps are allowed, 23 of the 24 clocks are duplicates, and fe0f doesn't count as ligature
			uint32_t firstcp = em->unicode.codepoint_at(n);
			if (firstcp >= 0x1F551 && firstcp <= 0x1F567) {}
			else if (n == em->unicode.length() || firstcp <= 0x7F ||
				(n == em->unicode.length()-3 && em->unicode.endswith(u8"\ufe0f")))
			{
				m_emoji_avatars.append(em);
			}
		}
	}
	else
	{
		m_emoji = discord_emoji::create(NULL, 0); // formatter needs an emoji handler, even if empty
		status("WARNING: No emoji library configured");
	}
	m_format = discord_format::create(m_emoji, bind_this(&discord::format_external), 0xCCCCCC);
	
	if (!m_cachename)
	{
		fatal("No cache configured");
		return;
	}
	
	//jsondeserialize safely ignores its output if input is blank
	jsondeserialize(cstring(file::readall(file::resolve(file::exedir(), m_cachename))),
		[this, inactive_hours](jsondeserializer& s)
	{
		s.items(
			"self", m_my_id,
			// discord strongly recommends caching the gateway
			// it's unclear whether that's motivated by performance concerns on their end, or client performance;
			// considering some other things I've seen, I suspect former, but it does help both
			"gateway", m_server_gateway,
			"guilds", [&](jsondeserializer& s){
				s.each_item([&](cstring key, jsondeserializer& s){
					guild* g = guild_for(key);
					s.items(
						"name", g->name.upstream,
						"roles", [&](jsondeserializer& s){
							s.each_item([&](cstring key, jsondeserializer& s){
								role* r = role_for(key, g);
								s.items("name", r->name.upstream);
							});
						},
						"emoji", g->emoji,
						"channels", [&](jsondeserializer& s){
							s.each_item([&](cstring key, jsondeserializer& s){
								channel* c = channel_for(key, g);
								bool hidden_b = true;
								s.items(
									"name", c->name.upstream,
									"parent", c->parent_id,
									"hidden", hidden_b,
									"scrollback", c->scrollback,
									// in case the channel's last_message_id isn't the last message, i.e. reordered or deleted
									"scrollbackend", c->last_fetched_msg);
								if (!hidden_b && c->visible == v_no)
								{
									time_t last_activity = 0;
									
									size_t n = c->scrollback.size();
									while (n--)
									{
										if (c->scrollback[n].author.num() == 0) continue;
										if (user_for_id(c->scrollback[n].author)->mute_activity) continue;
										last_activity = c->scrollback[n].at; // TODO: ignore guild joins
										break;
									}
									
									if (last_activity < time(NULL)-inactive_hours*3600)
										c->visible = v_ifactive;
									else
										c->visible = v_yes;
								}
							});
						}
					);
				});
			},
			"users", [&](jsondeserializer& s){
				s.each_item([&](cstring key, jsondeserializer& s){
					user* u = user_for_id(key, false);
					s.items("name", u->name.upstream, "avatar", u->avatar, "webhook", u->is_webhook);
				});
			});
	});
	if (!m_my_id)
		m_first_run = true;
	
	m_gateway_good = (m_server_gateway != "");
	
	for (name_override& no : guild_overrides)
	{
		guild* g = guild_for(no.snow);
		g->name.override_to = no.override_name;
		g->name.override_from = no.override_name_from;
	}
	for (name_override& no : role_overrides)
	{
		guild* g = guild_for(no.snow);
		g->name.override_to = no.override_name;
		g->name.override_from = no.override_name_from;
	}
	
	for (guild* g : m_guild_order)
	{
		guild_host(g);
		for (guildemoji& ge : g->emoji)
			emoji_get_img(ge.id.str()); // download em, and ensure they stay in cache
	}
	for (channel* c : m_channels)
	{
		if (!c->parent) continue; // happens if a channel is mentioned in config, but not in cache
		
		channel_host(c);
		
		span scspan[1] = { { "Loading scrollback..." } };
		c->host->message("scrollback", chanbase::imp_scrollback, time(NULL), scspan);
		for (message& m : c->scrollback)
		{
			if (m.id == "") m.id = "0";
			if (m.id == "0") continue; // skip the 'last message seen' marker
			user* u = user_for_id(m.author);
			
			span fmt;
			if (m.is_highlight)
			{
				fmt.fgcol = 0xFF0000;
				fmt.bold = true;
			}
			array<span> spans;
			add_author(spans, fmt, u, c, m);
			fmt.bold = false;
			
			if (m.reply_user)
			{
				span& sp = spans.append();
				sp.fgcol = 0xC04000;
				sp.text = "^@"+username_for_id(m.reply_user)+" "+time_to_str(m.reply_time)+"\n";
			}
			parse_format(discord_format::normal, spans, fmt, m.text, c, u, m.id);
			
			c->host->message_at("scrollback", false, m.id, chanbase::imp_scrollback, m.at, spans);
		}
	}
	
#if FAKE_CONNECT
//ws_str(file::readall(file::exedir()+"dump.log"));
//ws_str(R"x({"t":"MESSAGE_CREATE","s":296,"op":0,"d":{"type":0,"tts":false,"timestamp":"2018-10-27T12:46:02.933000+00:00","pinned":false,"nonce":null,"mentions":[],"mention_roles":[],"mention_everyone":false,"member":{"roles":[],"nick":null,"mute":false,"joined_at":"2018-08-19T12:25:54.377773+00:00","deaf":false},"id":"505723855025733643","embeds":[],"edited_timestamp":null,"content":"my personal choice would be R\"\"C:\\temp\\derp.log\"\" and R\"delim\"C:\\temp\\derp.log\"delim\"","channel_id":"480711423681495047","author":{"username":"Alcaro","id":"188322172576464896","discriminator":"3261","avatar":"e3466274aa00038c9b27e3cb0b95dae5"},"attachments":[],"guild_id":"480711423681495041"}})x");
//ws_str(R"x({"t":"MESSAGE_CREATE","s":297,"op":0,"d":{"type":0,"tts":false,"timestamp":"2018-10-27T12:46:02.933000+00:00","pinned":false,"nonce":null,"mentions":[],"mention_roles":[],"mention_everyone":false,"member":{"roles":[],"nick":null,"mute":false,"joined_at":"2018-08-19T12:25:54.377773+00:00","deaf":false},"id":"505723855025733644","embeds":[],"edited_timestamp":null,"content":"my personal choice would be R\"\"C:\\temp\\derp.log\"\" and R\"delim\"C:\\temp\\derp.log\"delim\"","channel_id":"480711423681495047","author":{"username":"Alcaro","id":"188322172576464896","discriminator":"3261","avatar":"e3466274aa00038c9b27e3cb0b95dae5"},"attachments":[],"guild_id":"480711423681495041"}})x");
//ws_str(R"x({"t":"MESSAGE_CREATE","s":298,"op":0,"d":{"type":0,"tts":false,"timestamp":"2018-10-27T12:46:02.933000+00:00","pinned":false,"nonce":null,"mentions":[],"mention_roles":[],"mention_everyone":false,"member":{"roles":[],"nick":null,"mute":false,"joined_at":"2018-08-19T12:25:54.377773+00:00","deaf":false},"id":"505723855025733645","embeds":[],"edited_timestamp":null,"content":"my personal choice would be R\"\"C:\\temp\\derp.log\"\" and R\"delim\"C:\\temp\\derp.log\"delim\"","channel_id":"480711423681495047","author":{"username":"Alcaro","id":"188322172576464896","discriminator":"3261","avatar":"e3466274aa00038c9b27e3cb0b95dae5"},"attachments":[],"guild_id":"480711423681495041"}})x");
//ws_str(R"x({"t":"MESSAGE_CREATE","s":299,"op":0,"d":{"type":0,"tts":false,"timestamp":"2018-10-27T12:46:02.933000+00:00","pinned":false,"nonce":null,"mentions":[],"mention_roles":[],"mention_everyone":false,"member":{"roles":[],"nick":null,"mute":false,"joined_at":"2018-08-19T12:25:54.377773+00:00","deaf":false},"id":"505723855025733646","embeds":[],"edited_timestamp":null,"content":"my personal choice would be R\"\"C:\\temp\\derp.log\"\" and R\"delim\"C:\\temp\\derp.log\"delim\"","channel_id":"480711423681495047","author":{"id":"236588665420251137"},"attachments":[],"guild_id":"480711423681495041"}})x");
status("ERROR: Offline mode enabled");
return;
#endif
	
	if (rawlog_fname)
		m_rawlog.open(file::resolve(file::exedir(), rawlog_fname), file::m_replace);
	
	([](discord* self)->async<void>{
		while (true)
		{
			co_await runloop2::in_ms(self->m_heartbeat_interval);
			self->heartbeat_cb();
		}
	}(this)).then(&m_heartbeat_coro);
	connect().then(&m_ws_coro);
}

void del_tmp()
{
	if (m_tmp_msg_in)
		m_tmp_msg_in->message_delete_true("tmp");
	m_tmp_msg_in = NULL;
}

textview::image* pick_avatar(uint64_t seed)
{
	if (!m_emoji_avatars.size())
		return NULL;
	return m_emoji->get_image(m_emoji_avatars[hash_shuffle(seed) % m_emoji_avatars.size()]);
}

void add_author(array<span>& spans, const span& fmt, user* u, channel* c, message& m)
{
	if (m_enable_avatars)
	{
		cstring avatar = m.avatar_override;
		if (!avatar && u) avatar = u->avatar;
		if (!avatar)
		{
			textview::image* img = pick_avatar(u->id.num());
			if (img)
			{
				spans.append(fmt).img = img;
				spans.append(fmt).text = " ";
			}
		}
		else
		{
			string url = m_server_img+"/avatars/"+u->id.str()+"/"+avatar+".png?size="+tostring(bitround(get_line_height()));
			spans.append(fmt).img = image_create_url(url, get_line_height());
			spans.append(fmt).text = " ";
		}
	}
	
	string name = m.name_override;
	if (!name) name = username(u);
	if (textview::is_rtl(name)) name = "\xE2\x80\xAA"+name;
	
	// make sure to edit type!=0 handler in do_message if editing this, or making it non-last
	spans.append(fmt).text = "<"+name+"> ";
}
void add_author(array<span>& spans, const span& fmt, const JSON& ju, channel* c, message& m, bool is_webhook)
{
	add_author(spans, fmt, user_for(ju, is_webhook), c, m);
}

static time_t iso8601_to_unix(const char * stamp)
{
	struct tm tm;
	tm.tm_isdst = false;
	sscanf(stamp, "%d-%d-%dT%d:%d:%d", &tm.tm_year,&tm.tm_mon,&tm.tm_mday, &tm.tm_hour,&tm.tm_min,&tm.tm_sec);
	tm.tm_year -= 1900;
	tm.tm_mon -= 1;
	return timegm(&tm);
}
static time_t iso8601_to_unix(JSON& json) { return iso8601_to_unix(json.str()); }

async<http_t::rsp> http_api(http_t::req q)
{
	q.loc = m_server_base + "/v9" + q.loc.path;
	q.headers.append("Authorization: "+m_token);
	q.headers.append("User-Agent: " USER_AGENT);
	if (m_rawlog)
	{
		cstring method = (q.method ? q.method : q.body ? (cstring)"POST" : (cstring)"GET");
		if (q.body.contains('\0') || q.body.size() > 10000)
			m_rawlog.write(logdate()+" << "+method+" "+q.loc.stringify()+" <snip>\n");
		else
			m_rawlog.write(logdate()+" << "+method+" "+q.loc.stringify()+" "+cstring(q.body)+"\n");
	}
	return m_http.request(q);
}

//Call with URL fragments with leading slash but without /api/v123, like "/gateway".
async<http_t::rsp> http_api(cstring path)
{
	http_t::req r;
	r.loc.path = path;
	return http_api(std::move(r));
}
async<http_t::rsp> http_api(cstring path, JSON& post)
{
	http_t::req r;
	r.loc.path = path;
	r.body = post.serialize().bytes();
	return http_api(std::move(r));
}
async<http_t::rsp> http_api(cstring method, cstring path)
{
	http_t::req r;
	r.loc.path = path;
	r.method = method;
	return http_api(std::move(r));
}
async<http_t::rsp> http_api(cstring method, cstring path, JSON& post)
{
	http_t::req r;
	r.loc.path = path;
	r.method = method;
	r.body = post.serialize().bytes();
	return http_api(std::move(r));
}

void send_ws(const JSON& json)
{
	string msg = json.serialize();
	if (m_rawlog) m_rawlog.write(logdate()+" << "+msg+"\n");
	m_ws.send(msg);
}

void disconnect(bool resumable, cstring why)
{
	//status(m_connect_state == cs_online ? m_last_activity : time(NULL), "Disconnected: "+why, chanbase::imp_none);
	status(m_last_activity, "Disconnected: "+why, chanbase::imp_none);
	if (m_rawlog) m_rawlog.write(logdate(time(nullptr))+" ** Closing WebSocket\n");
	if (!m_ws_coro_running)
		m_ws_coro.cancel();
	m_ws.reset();
	for (guild* g : m_guilds)
	{
		if (resumable) g->online_resume |= g->online;
		else g->online_resume = false;
		g->online = false;
	}
	if (!resumable)
	{
		m_resume_token = "";
		m_resume_token_prev = "";
	}
	rename_all();
	del_tmp();
	protocol::disconnected();
}
async<void> connect()
{
top:
if (m_fatal) co_return;
	
	m_heartbeat_sent = false;
	m_should_heartbeat = false;
	
	if (!m_gateway_good)
	{
		status("Locating gateway...", chanbase::imp_none);
		
		http_t::rsp r = co_await http_api("/gateway");
		if (m_rawlog)
			m_rawlog.write(logdate()+" >> "+tostring(r.status)+" "+r.text_unsafe()+"\n");
		
		JSONw json;
		if (!json.parse(r.body()))
		{
			co_await runloop2::in_ms(30000);
			goto top; // 99% of failures are timeout
		}
		m_server_gateway = json["url"];
		m_gateway_good = true;
	}
	
	if (m_rawlog) m_rawlog.write(logdate()+" ** Connecting\n");
	status("Connecting to "+m_server_gateway+"...", chanbase::imp_none);
	
	m_last_activity = time(NULL);
	co_await m_ws.connect(m_server_gateway+"?v=9&encoding=json");
	
	if (!m_ws)
	{
		co_await runloop2::in_ms(30000);
		m_gateway_good = false;
		goto top;
	}
	
	while (true)
	{
		int type;
		bytesr by = co_await m_ws.msg(&type);
		m_ws_coro_running = true;
		if (!m_ws)
		{
			if (by.size() >= 2)
				//disconnect(true, format(readu_be16(by.ptr())," ",by.skip(2)));
				disconnect(true, format(readu_be16(by.ptr())," ",tostringhex(by)));
			else
				disconnect(true, "WebSocket closed");
			if (!m_resume_token)
				co_await runloop2::in_ms(30000);
			goto top;
		}
		if (type == websocket::t_binary)
			ws_bin(by); // compressed payloads are correctly labeled as binary, while json is text
		if (type == websocket::t_text)
			ws_str(by);
		m_ws_coro_running = false;
		if (!m_ws) // if that message was a Reconnect or whatever
			goto top;
	}
}

string logdate(time_t rawtime)
{
	struct tm * timeinfo = localtime(&rawtime);
	char out[64];
	strftime(out, 64, "[%H:%M:%S]", timeinfo);
	return out;
}
string logdate()
{
	return logdate(time(NULL));
}

async<void> do_fetch_scrollback()
{
#if FAKE_CONNECT
	co_return;
#endif
	//status("Fetching scrollback of "+channel_for(m_fetch_scrollback[0]).name+" ("+m_fetch_scrollback[0]+")");
	
	scrollback_data dat = m_fetch_scrollback.pop(0);
	http_t::rsp r = co_await http_api("/channels/"+dat.chan.str()+"/messages?limit=100");
// TODO: this thing crashes when accepting a friend, immediately after receiving a []
// if hit, do not recompile without checking if ~/core exists
// delete these debug prints once the crash is fixed
	
	//with 'before' parameter: (untested)
	//with 'after' parameter:  (untested)
	//with 'around' parameter: (untested)
	//with none of the above:  messages show up NEWEST first
	channel* c = channel_for(dat.chan);
	
	if (m_rawlog) m_rawlog.write(logdate()+" >> HTTP "+r.text_unsafe()+"\n");
	
	//rate limit is per channel, so doing this at full speed is safe
	//(could even do all in parallel, but no real point)
	if (m_fetch_scrollback) m_http_waiters.add(do_fetch_scrollback());
	
	c->last_fetched_msg = c->last_msg; // do this even if it fails, to avoid confusion later
	
	JSON json(r.text());
	if (json.type() != jsonparser::enter_list)
	{
		string whynot = tostring(r.status)+" ";
		if (r.status < 0) whynot += "network failure";
		else if (json.type() == jsonparser::enter_map) whynot += tostring(json["code"].num())+" "+json["message"].str();
		else whynot += cstring(r.text_unsafe());
		// TODO: make this one clickable, click tries again
		span scspan[] = { { "[failed to load scrollback: " + whynot + "]" } };
		scspan[0].fgcol = 0xFF0000;
		c->host->message_at("scrollback", false, "scrollbackfail", chanbase::imp_scrollback, time(NULL), scspan);
		c->host->message_delete_true("scrollback");
		
		status("Failed to fetch "+channel_name(c)+" scrollback: "+whynot, chanbase::imp_none);
		co_return;
	}
	
	set<string> seenids;
	for (message& m : c->scrollback)
		seenids.add(m.id);
	
	bool found = false;
	for (int i=json.list().size()-1;i>=0;i--) // do this backwards, so log file and the new scrollback struct are ordered
	{
		snowflake msgid = json[i]["id"];
		if (found && !seenids.contains(msgid))
			do_message(json[i], false, true, false); // TODO: make the last one true if the message is older than lastread
		if (msgid == dat.msg_from)
			found = true;
	}
	
	if (!found && json) // either more than 100 messages, newly created channel, or empty list
	{
		//do not keep everything in 'scrollback', scrollback is below the messages while we want this above
		//can't do it backwards, that'd make the textual log mess up
		span scspan[1] = { { "[incomplete scrollback]" } }; // TODO: make this one clickable, click fetches more
		scspan[0].fgcol = 0xC00000;
		time_t at = iso8601_to_unix(json[json.list().size()-1]["timestamp"]);
		c->host->message_at("scrollback", false, "scrollbackfail", chanbase::imp_scrollback, at, scspan);
		
		bool found_old = false;
		bool do_print = false;
		for (int i=json.list().size()-1;i>=0;i--)
		{
			snowflake msgid = json[i]["id"];
			if (seenids.contains(msgid) && msgid.num() <= dat.msg_from.num())
				found_old = true;
			if (iso8601_to_unix(json[i]["timestamp"]) >= dat.time_from)
				do_print = true;
			for (message& m : c->scrollback)
			{
				if (m.id == msgid)
					do_print = false;
			}
			if (do_print)
				do_message(json[i], false, true, false);
		}
		if (found_old)
			c->host->message_delete_true("scrollbackfail");
	}
	
	if (c->host->message_exists("scrollback")) // TODO: check if this solves the friend request crashes. Then figure out why scrollback doesn't exist.
		c->host->message_delete_true("scrollback");
}

void do_message(JSON& jm_outer, bool is_edit, bool is_scrollback = false, bool is_read = false)
{
	// TODO: sometimes type is 21, but referenced_message is absent, there's only a
	// "message_reference":{"message_id":"123","guild_id":"456","channel_id":"789"}
	JSON& jm = ((jm_outer["type"] == 21 && jm_outer["referenced_message"]) ? jm_outer["referenced_message"] : jm_outer);
	
	channel* c = channel_for(jm_outer["channel_id"]);
	user* u = NULL;
	bool is_webhook = (jm["webhook_id"]);
	
	// can happen if user links an image, and discord fetches and embeds it
	if (!is_edit || jm["content"])
	{
	
	if (jm["author"])
	{
		u = user_for(jm["author"], is_webhook);
	}
	else
	{
		debug_warn_stack("message with no author, and not an add-embeds edit");
		snowflake msgid = jm["id"];
		if (msgid.num() == 0) return; // just discard edits of nonexistent messages...
		for (message& msg : c->scrollback)
		{
			if (msg.id == msgid)
			{
				u = user_for_id(msg.author);
				break;
			}
		}
		if (!u) return;
	}
	if (u->mute_delete) return;
	
	if (!c->host)
	{
		status("ERROR: Message to unknown channel "+tostring(c->id)+" "+jm_outer.serialize());
		channel_host(c); // otherwise it probably crashes
	}
	
	bool highlight = false;
	for (const JSON& j : jm["mentions"].list())
	{
		user_for(j, false);
		if (j["id"].str() == m_my_id)
			highlight = true;
	}
	if (u->mute_ping) highlight = false;
	
	bool by_me = (u->id == m_my_id);
	if (by_me) del_tmp();
	
	time_t at = iso8601_to_unix(jm["timestamp"]);
	
	bool normal_message = (jm["type"] == 0 /* DEFAULT */ || jm["type"] == 21 /* THREAD_STARTER_MESSAGE */ || jm["type"] == 19 /* REPLY */);
	if (!normal_message) highlight = false;
	
	chanbase::importance_t imp = (is_read          ? chanbase::imp_scrollback :
	                              by_me            ? chanbase::imp_none :
	                              highlight        ? chanbase::imp_highlight :
	                              u->mute_activity ? chanbase::imp_none :
	                              !normal_message  ? chanbase::imp_status :
	                                                 chanbase::imp_msg);
	
	if (is_scrollback && at < time(NULL)-7*86400) {} // don't make channel visible if cache is corrupt or gone, and this one is old
	else if (!highlight && u->mute_activity) {} // muted users can't make channels visible
	else if (is_dm_guild(c->parent) || highlight || (c->visible == v_ifactive && imp >= chanbase::imp_msg))
	{
		c->visible = v_yes;
		channel_host(c);
	}
	
	if (!is_edit)
	{
		if (c->last_fetched_msg == c->last_msg)
			c->last_fetched_msg = jm_outer["id"];
		c->last_msg = jm_outer["id"];
	}
	
	array<span> spans;
	size_t edit_span;
	
	message msg;
	msg.id = jm_outer["id"];
	msg.author = jm["author"]["id"];
	msg.is_highlight = highlight;
	msg.at = at;
	if (is_webhook)
	{
		if (jm["author"]["username"])
			msg.name_override = jm["author"]["username"];
		if (jm["author"]["avatar"])
			msg.avatar_override = jm["author"]["avatar"];
	}
	
	if (normal_message)
	{
		span fmt;
		if (highlight)
		{
			fmt.fgcol = 0xFF0000;
			fmt.bold = true;
		}
		add_author(spans, fmt, jm["author"], c, msg, is_webhook);
		edit_span = spans.size();
		spans.append(fmt); // spans[edit_span] must be empty
		fmt.bold = false;
		
		if (jm["message_reference"])
		{
			span& sp = spans.append();
			sp.fgcol = 0xC04000;
			if (jm["referenced_message"])
			{
				msg.reply_user = jm["referenced_message"]["author"]["id"];
				msg.reply_time = iso8601_to_unix(jm["referenced_message"]["timestamp"]);
				sp.text = "^@"+username_for_id(msg.reply_user)+" "+time_to_str(msg.reply_time)+"\n";
			}
			else
			{
				sp.text = "^@someone\n";
				msg.text += sp.text;
			}
		}
		
		discord_format::source_t markdown_type = (is_webhook ? discord_format::webhook : discord_format::normal);
		parse_format(markdown_type, spans, fmt, jm["content"], c, u, jm["id"]);
		
		msg.text += jm["content"].str();
		bool add_lf = (jm["content"] != "");
		for (const JSON& j : jm["attachments"].list())
		{
			if (add_lf) spans.append().text = "\n";
			if (add_lf) msg.text += "\n";
			add_lf = true;
			
			span& sp = spans.append();
			sp.text = j["url"];
			sp.hyperlink = true;
			
			//TODO: embed them
			//but only if filename does not start with SPOILER_
			
			msg.text += (cstring)j["url"];
		}
		
		if (jm["application"])
		{
			if (add_lf) spans.append().text = "\n";
			if (add_lf) msg.text += "\n";
			add_lf = true;
			
			span& sp = spans.append();
			sp.text = "<game invite - "+(cstring)jm["application"]["name"]+">";
			msg.text += "<game invite - "+(cstring)jm["application"]["name"]+">";
		}
		if (jm["activity"])
		{
			if (add_lf) spans.append().text = "\n";
			if (add_lf) msg.text += "\n";
			add_lf = true;
			
			span& sp = spans.append();
			sp.text = "<non-game invite - "+(cstring)jm["activity"]["party_id"]+">";
			msg.text += "<non-game invite - "+(cstring)jm["activity"]["party_id"]+">";
		}
		if (jm["poll"])
		{
			if (add_lf) spans.append().text = "\n";
			if (add_lf) msg.text += "\n";
			add_lf = true;
			
			span& sp = spans.append();
			sp.text = "<poll "+(cstring)jm["poll"]["question"]["text"]+">";
			msg.text += "<poll "+(cstring)jm["poll"]["question"]["text"]+">";
		}
		for (JSON& jms : jm["sticker_items"].list())
		{
			if (add_lf) spans.append().text = "\n";
			if (add_lf) msg.text += "\n";
			add_lf = true;
			
			span& sp = spans.append();
			sp.text = "<sticker - "+(cstring)jms["name"]+">";
			msg.text += "<sticker - "+(cstring)jms["name"]+">";
		}
		
		if (!msg.text && jm["embeds"])
		{
			// 99% of embeds are useless, and I wish I didn't need the last percent either, but some bots insist on that
			
			for (const JSON& j : jm["embeds"].list())
			{
				// TODO: rewrite this stuff, they look differently these days
				// {"type":"rich","color":6143186,"footer":{"text":"jr.0#0000 | perl | perl-5.36.0 | wandbox.org"}}
				
				//if (j["type"] == "link" || j["type"] == "image" || j["type"] == "video") continue; // just ignore those
				//if (j["type"] == "gifv" || j["type"] == "article") continue;
				//if (j["url"].str().startswith("https://twitter.com/")) continue;
				
				if (j["author"]["id"])
				{
					status("WARNING: embed with author snowflake: "+j.serialize());
				}
				if (j["title"])
				{
					if (j["url"])
					{
						// spans.append().text = j["title"].str() + " | ";
						parse_format(discord_format::embed_title, spans, span(), j["title"], c, u, jm["id"]);
						spans.append().text = " | ";
						span& sp = spans.append();
						sp.text = j["url"];
						sp.hyperlink = true;
						spans.append().text = "\n";
						msg.text += j["title"].str()+" | "+j["url"].str()+"\n";
					}
					else
					{
						parse_format(discord_format::embed_title, spans, span(), j["title"], c, u, jm["id"]);
						spans.append().text = "\n";
						msg.text += j["title"].str()+"\n";
					}
				}
				
				// TODO: verify which of these are embed_body and which aren't
				if (j["description"])
				{
					parse_format(discord_format::embed_body, spans, span(), j["description"], c, u, jm["id"]);
					spans.append().text = "\n";
					msg.text += j["description"].str()+"\n";
				}
				if (j["image"]) // TODO: verify in which order these fields should render
				{
					span& sp = spans.append();
					sp.text = j["image"]["url"];
					sp.hyperlink = true;
					msg.text += sp.text+"\n"; // don't swap with the below, that's a use-after-free
					spans.append().text = "\n";
				}
				for (const JSON& ji : j["fields"].list())
				{
					if (ji["name"])
					{
						parse_format(discord_format::embed_body, spans, span(), ji["name"], c, u, jm["id"]);
						spans.append().text = ": ";
						msg.text += ji["name"].str()+": ";
					}
					parse_format(discord_format::embed_body, spans, span(), ji["value"], c, u, jm["id"]);
					spans.append().text = "\n";
					msg.text += ji["value"].str()+"\n";
				}
				for (const JSON& ji : j["footer"].list())
				{
					parse_format(discord_format::embed_body, spans, span(), ji["text"], c, u, jm["id"]);
					spans.append().text = "\n";
					msg.text += ji["text"].str()+"\n";
				}
				if (j["author"]["name"])
				{
					span& sp = spans.append();
					sp.text = "by "+j["author"]["name"].str();
					msg.text += sp.text+"\n"; // don't swap with the below, that's a use-after-free
					spans.append().text = "\n"; // don't merge with the above span, the spans.remove() below won't like that
				}
			}
			
			if (msg.text)
			{
				spans.remove(spans.size()-1);
				msg.text = msg.text.substr(0, ~1);
			}
			else
			{
				status("WARNING: unknown embed: "+jm.serialize());
			}
		}
		
		if (!msg.text)
		{
			status("WARNING: empty message in "+channel_name(c)+": "+jm.serialize());
			msg.text = "<empty message>";
			spans.append({ "<empty message>" }).italics = true;
		}
	}
	else if (jm["type"] == 1 && jm["mentions"].list().size() == 1)
	{
		string msg_text = "added "+username(jm["mentions"][0], false)+" to the channel";
		
		span fmt;
		fmt.italics = true;
		add_author(spans, fmt, jm["author"], c, msg, is_webhook);
		spans[spans.size()-1].text = "* "+spans[spans.size()-1].text.substr(1, ~2)+" ";
		spans.append(fmt).text = msg_text;
		
		msg.text = "\\*\\*\\* _"+msg_text+"_";
		edit_span = spans.size();
		spans.append(fmt); // spans[edit_span] must be empty
	}
	else
	{
		const char * msg_types[] = {
			NULL, // DEFAULT, handled elsewhere
			"* RECIPIENT_ADD",
			"has left the chat",
			"started a call",
			"renamed the channel to",
			NULL, // 5 CHANNEL_ICON_CHANGE - never seen it, do channels even have icons?
			"pinned a message to the channel", // should be ignored, but kept for now because pinning also sends a MESSAGE_UPDATE
			"has joined the guild",
			"donated a Nitro boost",
			"donated a Nitro boost, now level 1",
			"donated a Nitro boost, now level 2",
			"donated a Nitro boost, now level 3",
			"subscribed to announcements from",
			"* UNKNOWN_TYPE_13",
			"* GUILD_DISCOVERY_DISQUALIFIED",
			"* GUILD_DISCOVERY_REQUALIFIED",
			"* GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING",
			"* GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING",
			"created a thread:",
			NULL, // REPLY, handled elsewhere
			"* APPLICATION_COMMAND",
			NULL, // THREAD_STARTER_MESSAGE, handled elsewhere
			"* GUILD_INVITE_REMINDER",
		};
		size_t msg_type = jm["type"];
		string msg_text;
		if (msg_type < ARRAY_SIZE(msg_types) && msg_types[msg_type] != NULL)
		{
			if (msg_types[msg_type][0] == '\0')
				return;
			msg_text = msg_types[msg_type];
			if (msg_text[0] == '*') status("WARNING: unexpected message type: "+jm.serialize());
		}
		else
		{
			msg_text = "* UNKNOWN_TYPE_"+tostring(msg_type);
			status("WARNING: unknown message type: "+jm.serialize());
		}
		
		if (jm["content"]) msg_text += " "+jm["content"].str();
		
		span fmt;
		fmt.italics = true;
		add_author(spans, fmt, jm["author"], c, msg, is_webhook);
		spans[spans.size()-1].text = "* "+spans[spans.size()-1].text.substr(1, ~2)+" ";
		spans.append(fmt).text = msg_text;
		
		msg.text = "\\*\\*\\* _"+msg_text+"_";
		edit_span = spans.size();
		spans.append(fmt); // spans[edit_span] must be empty
	}
	
	if (is_edit)
	{
		c->host->message_edit(jm["id"], iso8601_to_unix(jm[/*"edited_"*/"timestamp"]), spans, edit_span);
		c->setmsg(jm["id"], msg.text);
	}
	else
	{
		if (!is_scrollback)
			c->host->message(jm["id"], imp, at, spans);
		else
			c->host->message_at("scrollback", false, jm["id"], imp, at, spans);
		c->nextmsg(std::move(msg));
	}
	
	}
	
	// thread handling
	message* msg = c->get_msg_by_id(jm["id"]);
	if (!msg) return;
	
	if (((uint32_t)jm["flags"] & 32) && !msg->has_thread)
	{
		msg->has_thread = true;
		
		time_t at = msg->at;
		
		textview::span spans[1] = { { "** A thread was created" } };
		spans[0].italics = true;
		if (!is_scrollback)
			c->host->message(chanbase::imp_msg, at, spans);
		else
			c->host->message_at("scrollback", false, "", chanbase::imp_msg, at, spans);
	}
}

void load_chan(JSON& jc, guild* g)
{
	// https://discord.com/developers/docs/resources/channel#channel-object-channel-types
	if (jc["type"] == 4) return; // 0=channel, 1=private, 2=voice, 3=group-private 4=category 5=announcement
	
	channel* c = channel_for(jc["id"], g);
	c->used = true;
	const char * prefix = "";
	if (jc["type"] == 10 || jc["type"] == 11 || jc["type"] == 12)
	{
		snowflake parent = jc["parent_id"];
		c->parent_id = parent;
		prefix = "> ";
	}
	if (jc["type"] == 0 || jc["type"] == 5) prefix = "#";
	c->name.upstream = prefix + jc["name"].str();
	
	if (is_dm_guild(g))
	{
		//type 1=private, 3=group; we want both
		channel* c = channel_for(jc["id"], g);
		for (JSON& r : jc["recipient_ids"].list())
			c->name.upstream = username_for_id(r);
		for (JSON& r : jc["recipients"].list())
			c->name.upstream = username(r, false);
		if (jc["type"] == 3)
		{
			if (jc["name"])
			{
				c->name.upstream = jc["name"];
			}
			else
			{
				array<string> names = jc["recipients"].list().select([this](const JSON& j)->string { return username(j, false); });
				names += jc["recipient_ids"].list().select([this](const JSON& j)->string { return username_for_id(j); }).as_array();
				if (names.size() == 0)
					c->name.upstream = "<empty groupchat>";
				//if size==1, c->name.upstream = username(r); above is good enough
				if (names.size() == 2)
					c->name.upstream = names[0]+" and "+names[1];
				if (names.size() >= 3)
					c->name.upstream = names.slice(0, names.size()-1).join(", ") + ", and " + names[names.size()-1];
			}
		}
	}
	
	if (c->muted == m_dontknow && !is_dm_guild(g))
	{
		if (jc["type"] == 2)
			c->muted = m_yes;
		else
			c->muted = m_no;
	}
	if (c->visible == v_no && c->muted == m_no)
	{
		if (m_first_run)
			c->visible = v_ifactive;
		else
			c->visible = v_yes;
	}
	c->last_msg = jc["last_message_id"];
	channel_host(c);
	
	if (!c->scrollback)
	{
		// fetch messages in freshly created channels,
		// but mark scrollback as loaded so it won't retry if the channel is dead
		message& m = c->scrollback.append();
		m.id = "0"; // nonexistent id, so everything is shown
		m.at = 1420070400;        // discord epoch (jan 1, 2015), so it doesn't instantly hit the
		goto do_fetch_scrollback; //  'seeing messages older than latest, latest was probably deleted' check
	}
	if (c->last_msg != c->last_fetched_msg)
	{
	do_fetch_scrollback: ;
		if ((c->visible >= v_ifactive || is_dm_guild(c->parent) || c->force_fetch_messages) && !m_first_run)
		{
			bool found = false;
			for (const scrollback_data& dat : m_fetch_scrollback)
			{
				if (dat.chan == jc["id"])
					found = true;
			}
			
			// discord sometimes sends two CHANNEL_CREATE when accepting a friend request
			// no clue why, but let's not fetch the same scrollback twice
			if (!found)
			{
				c->force_fetch_messages = false;
				if (!c->host->message_exists("scrollback"))
				{
					span scspan[1] = { { "Loading scrollback..." } };
					c->host->message("scrollback", chanbase::imp_scrollback, time(NULL), scspan);
				}
				
				snowflake last_seen_msg;
				time_t last_seen_time = 0;
				if (c->scrollback)
				{
					last_seen_msg = c->scrollback[c->scrollback.size()-1].id.csplit<1>("-")[0];
					last_seen_time = c->scrollback[c->scrollback.size()-1].at - 30;
				}
				
				m_fetch_scrollback.append({ jc["id"], last_seen_msg, last_seen_time });
				if (!m_scrollback_coro.is_waiting())
					do_fetch_scrollback().then(&m_scrollback_coro);
			}
		}
		else
		{
			c->last_fetched_msg = c->last_msg;
			span scspan[1] = { { "[scrollback not loaded]" } }; // TODO: make this one clickable, click fetches more
			scspan[0].fgcol = 0xC00000;
			if (c->host->message_exists("scrollback"))
			{
				c->host->message_at("scrollback", false, "scrollbackfail", chanbase::imp_scrollback, time(NULL), scspan);
				c->host->message_delete_true("scrollback");
			}
			else
			{
				c->host->message("scrollbackfail", chanbase::imp_scrollback, time(NULL), scspan);
			}
		}
	}
	else
	{
		if (c->host->message_exists("scrollback"))
			c->host->message_delete_true("scrollback");
	}
}

void load_role(JSON& jr, guild* g)
{
	role* r = role_for(jr["id"], g);
	r->name.upstream = jr["name"];
	r->used = true;
	r->pingable = jr["mentionable"];
}

void load_guild(JSON& jg)
{
	guild* g = guild_for(jg["id"]);
	g->exists = true;
	if (jg["unavailable"]) return;
	
	g->name.upstream = jg["name"];
	g->online = true;
	g->used = true;
	guild_host(g);
	
	for (JSON& jc : jg["channels"].list())
		load_chan(jc, g);
	for (JSON& jc : jg["threads"].list())
		load_chan(jc, g);
	
	for (JSON& ju : jg["members"].list())
		user_for(ju["user"], false);
	for (JSON& jp : jg["presences"].list())
		user_for(jp["user"], false);
	for (JSON& jr : jg["roles"].list())
		load_role(jr, g);
	
	load_guildemojis(g, jg["emojis"]);
}

void load_guildemojis(guild* g, JSON& j)
{
	if (!j) return;
	
	g->emoji.reset();
	for (JSON& e : j.list())
	{
		if (e["managed"]) // these require being a Twitch subscriber or something. No clue where that shows up. Let's just ignore them.
			continue;
		guildemoji& ge = g->emoji.append();
		ge.animated = e["animated"];
		ge.id = e["id"];
		ge.name = e["name"];
	}
	g->emoji.sort([](const guildemoji& a, const guildemoji& b)->bool {
		if (a.animated < b.animated) return true;
		if (a.animated > b.animated) return false;
		return string::iless(a.name, b.name);
	});
}

async<string> mutual_guilds(snowflake uid)
{
	http_t::rsp r = co_await http_api("/users/"+uid.str()+"/profile");
	string mutual;
	if (r.success())
	{
		JSON j(r.text());
		for (JSON& jg : j["mutual_guilds"].list())
		{
			guild* g = guild_for(jg["id"]);
			if (mutual) mutual += ", ";
			mutual += guild_name(g);
		}
		if (!mutual) mutual = "(none)";
	}
	else
	{
		mutual = "(error "+tostring(r.status)+")";
	}
	co_return mutual;
}

void do_relationship(JSON& rel)
{
	snowflake uid;
	if (rel["user"]) // use it if it exists, but it probably doesn't
	{
		user_for(rel["user"], false);
		uid = rel["user"]["id"];
	}
	if (!uid)
		uid = rel["user_id"];
	if (!uid)
		uid = rel["id"];
	if (!uid)
		return status("Unknown user in relationship", chanbase::imp_highlight);
	string source = username_for_id(uid);
	int type = rel["type"];
	
	if (type == 1) return; // friend
	if (type == 2) return; // blocked
	if (type == 4) return; // outgoing friend request
	
	if (type == 3) // incoming friend request
	{
		m_http_waiters.add([](discord* self, snowflake uid)->async<void>{
			string mutual = co_await self->mutual_guilds(uid);
			self->status("Incoming friend request from "+self->username_for_id(uid)+", mutual guilds "+mutual, chanbase::imp_highlight);
		}(this, uid));
		return;
	}
	
	status("Unknown relationship type "+tostring(type)+" with "+username_for_id(uid), chanbase::imp_highlight);
}

void ws_str(cstring msg)
{
	if (m_rawlog) m_rawlog.write(logdate()+" >> "+msg+"\n");
	m_last_activity = time(NULL);
	
	JSON json(msg);
	if (!json)
	{
		fatal("Invalid JSON received!!!1 "+msg);
		return;
	}
	
	if (json["op"] == 0) // Dispatch
	{
		if (json["s"].type() == jsonparser::num) m_sequence = json["s"]; // if /recv, s doesn't exist
		cstring t = json["t"];
		if(0);
		else if (t == "READY")
		{
			status("Connected", chanbase::imp_none);
			
			dm_guild()->exists = true;
			dm_guild()->used = true;
			dm_guild()->online = true;
			m_my_id = json["d"]["user"]["id"];
			guild_host(dm_guild());
			
			for (guild* g : m_guilds)
				g->online_resume = false;
			
			user_for(json["d"]["user"], false);
			
			for (JSON& ujg : json["d"]["user_guild_settings"]["entries"].list())
			{
				for (JSON& ujc : ujg["channel_overrides"].list())
				{
					channel* c = channel_for(ujc["channel_id"]);
					c->muted = ujc["muted"] ? m_yes : m_no;
					//don't call channel_host; load_guild and load_chan does that, and channel name isn't known yet
				}
			}
			
			for (JSON& u : json["d"]["users"].list())
				user_for(u, false);
			
			for (JSON& r : json["d"]["relationships"].list())
				user_for(r["user"], false);
			
			for (JSON& r : json["d"]["read_state"].list())
			{
				channel* c = channel_for(r["id"]);
				//c.last_read = r["last_message_id"];
				if (r["mention_count"] && !is_dm_guild(c->parent))
					c->force_fetch_messages = true;
				//again, no channel_host
			}
			
			for (JSON& p : json["d"]["presences"].list())
				user_for(p["user"], false);
			
			for (JSON& pc : json["d"]["private_channels"].list())
				load_chan(pc, dm_guild());
			
			for (JSON& jg : json["d"]["guilds"].list())
				load_guild(jg);
			
			for (JSON& rel : json["d"]["relationships"].list())
				do_relationship(rel);
			
			array<guild*> new_guild_order = json["d"]["user_settings"]["guild_positions"].list()
			                                .select([this](const JSON& j)->guild* { return m_guild_index.get_or((snowflake)j, NULL); })
			                                .where([](guild* g)->bool { return g; });
			new_guild_order.insert(0, dm_guild());
			//this sets m_guild_order to new_guild_order, except items only in m_guild_order end up at the end in an arbitrary order
			//could probably be improved, but good enough for now
			for (guild* g : m_guild_order)
			{
				if (!new_guild_order.contains(g))
					new_guild_order.append(g);
			}
			m_guild_order = std::move(new_guild_order);
			
			m_resume_token = json["d"]["session_id"];
			m_first_run = false;
			
			send_visible_status();
		}
		else if (t == "RESUMED")
		{
			status("Resumed", chanbase::imp_none);
			m_resume_token = m_resume_token_prev;
			
			for (guild* g : m_guilds)
			{
				g->online |= g->online_resume; // |= in case of partial READY + timeout + GUILD_CREATE + RESUMED
				g->online_resume = false;
			}
			rename_all();
			
			send_visible_status();
		}
		else if (t == "GUILD_CREATE")
		{
			load_guild(json["d"]);
		}
		else if (t == "GUILD_DELETE")
		{
			bool fatal = !(bool)json["d"]["unavailable"];
			guild* g = guild_for(json["d"]["id"]);
			for (channel* c : g->channels)
			{
				c->host->set_available(false);
				if (fatal)
				{
					span sp[1];
					sp[0].italics = true;
					sp[0].fgcol = 0xFF0000;
					sp[0].text = "*** You have been removed from the guild";
					c->host->message(chanbase::imp_status, time(nullptr), sp);
				}
			}
		}
		else if (t == "GUILD_EMOJIS_UPDATE")
		{
			load_guildemojis(guild_for(json["d"]["guild_id"]), json["d"]["emojis"]);
		}
		else if (t == "CHANNEL_CREATE" || t == "THREAD_CREATE")
		{
			if (t == "THREAD_CREATE")
			{
				bool in_channel_already = false;
				for (JSON& j : json["d"]["member_ids_preview"].list())
				{
					if ((snowflake)j == m_my_id)
						in_channel_already = true;
				}
				if (!in_channel_already)
				{
					//188322172576464896
					channel* parent_chan = m_channel_index.get_or((snowflake)json["d"]["parent_id"], NULL);
					if (!parent_chan || parent_chan->muted != m_yes)
					{
						m_http_waiters.add([](discord* self, snowflake chan_id)->async<void>{
							http_t::rsp r = co_await self->http_api("PUT", "/channels/"+chan_id.str()+"/thread-members/@me");
							// ignore response
						}(this, json["d"]["id"]));
					}
					return;
				}
			}
			cstring guild_id = json["d"]["guild_id"];
			if (guild_id)
				load_chan(json["d"], guild_for(guild_id));
			else
				load_chan(json["d"], dm_guild());
			channel* c = channel_for(json["d"]["id"]);
			if (!c->host) return; // group or voice - ignore
			span sp[1];
			sp[0].italics = true;
			sp[0].fgcol = 0xFF00FF;
			sp[0].text = "*** Now talking on "+channel_name(c);
			c->host->message(chanbase::imp_highlight, time(nullptr), sp);
		}
		else if (t == "CHANNEL_DELETE" || t == "THREAD_DELETE")
		{
			channel* c = channel_for(json["d"]["id"]);
			if (!c->host) return; // group or voice - ignore
			c->used = false;
			c->host->set_available(false);
			// send the message to the buffer directly, without send_message; send_message would make it visible
			span sp[1];
			sp[0].italics = true;
			sp[0].fgcol = 0xFF0000;
			sp[0].text = "*** Channel has been deleted";
			c->host->message(chanbase::imp_status, time(nullptr), sp);
		}
		else if (t == "MESSAGE_CREATE")
		{
			do_message(json["d"], false);
		}
		else if (t == "MESSAGE_UPDATE")
		{
			do_message(json["d"], true);
		}
		else if (t == "MESSAGE_DELETE")
		{
			channel* c = channel_for(json["d"]["channel_id"]);
			if (!c->host) return;
			c->host->message_delete(json["d"]["id"]);
			c->setmsg(json["d"]["id"], "");
		}
		else if (t == "MESSAGE_DELETE_BULK")
		{
			channel* c = channel_for(json["d"]["channel_id"]);
			if (!c->host) return;
			for (JSON& m : json["d"]["ids"].list())
			{
				c->host->message_delete(m);
				c->setmsg(m, "");
			}
		}
		else if (t == "RELATIONSHIP_ADD")
		{
			do_relationship(json["d"]);
		}
		else if (t == "USER_GUILD_SETTINGS_UPDATE")
		{
			guild* g = m_guild_index.get_or((snowflake)json["d"]["guild_id"], NULL);
			if (g && !is_dm_guild(g))
			{
				for (channel* c : g->channels)
				{
					c->muted = m_no;
				}
			}
			
			for (JSON& ujc : json["d"]["channel_overrides"].list())
			{
				channel* c = channel_for(ujc["channel_id"]);
				c->muted = ujc["muted"] ? m_yes : m_no;
			}
			
			if (g && !is_dm_guild(g))
			{
				for (channel* c : g->channels)
				{
					if (c->muted == m_no && c->visible == v_no)
					{
						c->visible = v_ifactive;
					}
				}
			}
		}
		else if (t == "GUILD_ROLE_CREATE" || t == "GUILD_ROLE_UPDATE")
		{
			load_role(json["d"]["role"], guild_for(json["d"]["guild_id"]));
		}
		//currently unused (some are useless in this architecture)
		else if (t == "BURST_CREDIT_BALANCE_UPDATE") {} // probably related to those animated overreactions
		else if (t == "CALL_CREATE") {}
		else if (t == "CALL_DELETE") {}
		else if (t == "CALL_UPDATE") {}
		else if (t == "CHANNEL_PINS_ACK") {} // does this do anything on the official client?
		else if (t == "CHANNEL_PINS_UPDATE") {}
		else if (t == "CHANNEL_RECIPIENT_ADD") {}
		else if (t == "CHANNEL_TOPIC_UPDATE") {} // almos always paired with VOICE_CHANNEL_STATUS_UPDATE
		else if (t == "CHANNEL_UPDATE") {} // these are usually accidental swap, but can be topic change or channel rename
		else if (t == "CONVERSATION_SUMMARY_UPDATE") {}
		else if (t == "EMBEDDED_ACTIVITY_UPDATE") {}
		else if (t == "GUILD_APPLICATION_COMMAND_COUNTS_UPDATE") {}
		else if (t == "GUILD_APPLICATION_COMMAND_INDEX_UPDATE") {} // probably slash commands. I don't care
		else if (t == "GUILD_AUDIT_LOG_ENTRY_CREATE") {}
		else if (t == "GUILD_BAN_ADD") {}
		else if (t == "GUILD_BAN_REMOVE") {}
		else if (t == "GUILD_INTEGRATIONS_UPDATE") {} // "d":{"guild_id":"123"} and nothing else. what am I supposed to do with that?
		else if (t == "GUILD_MEMBER_ADD") {} // surprisingly rare - probably only shows up in small guilds
		else if (t == "GUILD_MEMBER_REMOVE") {}
		else if (t == "GUILD_MEMBER_UPDATE") {}
		else if (t == "GUILD_ROLE_DELETE") {} // ignore this, the role will be garbage collected when it no longer shows up in READY
		else if (t == "GUILD_SCHEDULED_EVENT_USER_ADD") {}
		else if (t == "GUILD_SCHEDULED_EVENT_USER_REMOVE") {}
		else if (t == "GUILD_SOUNDBOARD_SOUND_CREATE") {}
		else if (t == "GUILD_SOUNDBOARD_SOUND_DELETE") {}
		else if (t == "GUILD_STICKERS_UPDATE") {}
		else if (t == "GUILD_UPDATE") {}
		else if (t == "INTEGRATION_UPDATE") {}
		else if (t == "INVITE_CREATE") {}
		else if (t == "INVITE_DELETE") {}
		else if (t == "MESSAGE_ACK") {} // message is marked read
		else if (t == "MESSAGE_POLL_VOTE_ADD") {}
		else if (t == "MESSAGE_REACTION_ADD") {}
		else if (t == "MESSAGE_REACTION_REMOVE") {}
		else if (t == "MESSAGE_REACTION_REMOVE_ALL") {}
		else if (t == "MESSAGE_REACTION_REMOVE_EMOJI") {}
		else if (t == "PRESENCES_REPLACE") {} // this rare event seems to contain an array of PRESENCE_UPDATE bodies
		else if (t == "PRESENCE_UPDATE") {} // fuck this one in particular, it accounts for ~55% of bandwidth (http is ~15%)
		else if (t == "READY_SUPPLEMENTAL") {} // don't know what this is, just looks noisy
		else if (t == "RELATIONSHIP_REMOVE") {}
		else if (t == "SESSIONS_REPLACE") {}
		else if (t == "THREAD_MEMBERS_UPDATE") {}
		else if (t == "THREAD_MEMBER_UPDATE") {}
		else if (t == "THREAD_UPDATE") {}
		else if (t == "TYPING_START") {}
		else if (t == "USER_NOTE_UPDATE") {} // seems to happen whenever I click a profile in official client
		else if (t == "USER_SETTINGS_PROTO_UPDATE") {} // every time I open the official client
		else if (t == "USER_SETTINGS_UPDATE") {}
		else if (t == "VOICE_CHANNEL_STATUS_UPDATE") {}
		else if (t == "VOICE_STATE_UPDATE") {}
		else if (t == "WEBHOOKS_UPDATE") {}
		else status("unknown event "+msg);
	}
	if (json["op"] == 1) // Heartbeat
	{
		JSONw json;
		json["op"] = 11; // Heartbeat ACK
		send_ws(json);
	}
	//if (json["op"] == 2) // Identify (client only)
	//if (json["op"] == 3) // Status Update (client only)
	//if (json["op"] == 4) // Voice State Update (voice unsupported)
	//if (json["op"] == 5) // Voice Server Ping (voice unsupported)
	//if (json["op"] == 6) // Resume (client only)
	if (json["op"] == 7) // Reconnect
	{
		disconnect(true, "Reconnect");
	}
	//if (json["op"] == 8) // Request Guild Members (client only)
	if (json["op"] == 9) // Invalid Session
	{
		if (m_resume_token_prev)
		{
			status("Resumption failed, logging in", chanbase::imp_none);
			m_resume_token_prev = "";
			// docs say wait 1-5 seconds before sending this - easier said than done with this architecture
			// the reason for that rule is probably to not create an infinite ping-pong loop;
			//   the state change fills the same purpose and is a lot easier to implement
			goto send_identify;
		}
		else
		{
			// this reconnects if cs_online, else awaits timeout
			disconnect(json["d"], (cstring)"Invalid session ("+(json["d"] ? "" : "not ")+"resumable)");
		}
	}
	if (json["op"] == 10) // Hello
	{
		guild_host(dm_guild());
		
		m_should_heartbeat = true;
		m_heartbeat_interval = json["d"]["heartbeat_interval"];
		if (m_heartbeat_interval < 2000) m_heartbeat_interval = 2000;
		if (m_heartbeat_interval > 60000) m_heartbeat_interval = 60000;
		
		if (m_resume_token)
		{
			status("Resuming", chanbase::imp_none);
			
			JSONw json;
			json["op"] = 6; // Resume
			json["d"]["token"] = m_token;
			json["d"]["session_id"] = m_resume_token;
			json["d"]["seq"] = m_sequence;
			send_ws(json);
			
			m_resume_token_prev = m_resume_token;
			m_resume_token = "";
		}
		else
		{
			status("Logging in", chanbase::imp_none);
			
		send_identify: ;
			if (!m_token_is_config)
			{
				string new_token = token_from_firefox(m_email);
				if (new_token && new_token != m_token)
				{
					status("Firefox has a new token, updating", chanbase::imp_none);
					m_token = new_token;
				}
			}
			m_resume_token = "";
			m_resume_token_prev = "";
			m_sequence = 0;
			JSONw json;
			json["op"] = 2; // Identify
			json["d"]["token"] = m_token;
			json["d"]["compress"] = true;
			json["d"]["properties"]["os"] = "linux";
			json["d"]["properties"]["browser"] = USER_AGENT;
			json["d"]["properties"]["device"] = USER_AGENT;
			json["d"]["properties"]["referrer"] = "";
			json["d"]["properties"]["referring_domain"] = "";
			json["d"]["large_threshold"] = 50;
			json["d"]["capabilities"] = 125;
			send_ws(json);
		}
	}
	if (json["op"] == 11) // Heartbeat ACK
	{
		m_heartbeat_sent = false;
	}
	//if (json["op"] == 12) // unknown, never seen
	//if (json["op"] == 13) // channel sync (client only, undocumented)
}

void ws_bin(arrayview<uint8_t> msg)
{
	bytearray decomp = inflator::zlibhead::inflate(msg);
	if (decomp)
		ws_str(cstring(decomp));
	else
		fatal("Decompression failed!!!1 "+tostringhex(msg));
}

void parse_format(discord_format::source_t source, array<span>& out, const span& fmt, cstring text, channel* c, cstring msgid)
{
	size_t n_in = out.size();
	
	m_current_msg_chan = c;
	m_current_msg = msgid;
	m_format->parse(source, out, fmt, text);
	
	sanitize_spans(out, n_in);
}

void parse_format(discord_format::source_t source, array<span>& out, const span& fmt, cstring text,
                  channel* c, user* u, cstring msgid)
{
	size_t n_in = out.size();
	parse_format(source, out, fmt, text, c, msgid);
	
	if (u->mute_loose_u)
	{
		for (span& sp : out.skip(n_in))
		{
			if (sp.hyperlink || sp.img || sp.monospace) continue;
			sp.text = REGEX("\\bu\\b").replace(REGEX("\\bU\\b").replace(sp.text, "You"), "you");
		}
	}
	if (u->mute_sponge)
	{
		uint8_t lower = 0;
		for (span& sp : out.skip(n_in))
		{
			if (sp.hyperlink || sp.img) continue;
			for (uint8_t& byte : sp.text.bytes())
			{
				if (isalpha(byte))
				{
					lower ^= 0x20;
					byte = toupper(byte) | lower;
				}
			}
		}
	}
	if (u->mute_guildemoji)
	{
		uint64_t n = msgid.hash();
		for (span& sp : out.skip(n_in))
		{
			if (!sp.img || !sp.text || sp.text[0] != '<') continue;
			sp.img = pick_avatar(n++);
		}
	}
}

// cstring so a 0-prefixed emoji id is representable and gives a 404
textview::image* emoji_get_img(cstring id)
{
	return image_create_url(m_server_img+"/emojis/"+id+".png?size="+tostring(bitround(get_line_height())), get_line_height());
}
void format_external(array<span>& out, const span& fmt, cstring content)
{
	span& sp = out.append(fmt);
	if (content[0] == ':' || content[0] == 'a') // guildemoji; ":thonk:379295935689392148", "a:extrathink:402609982882971654"
	{
		array<cstring> parts = content.csplit<2>(":");
		// ignore content[0], fetch unanimated only; gtktextview can't handle animated images
		// cstring name = parts[1]; // unused
		
		sp.img = emoji_get_img(parts[2]);
		sp.text = "<"+content+">";
	}
	else
	{
		int typelen = isdigit(content[1]) ? 1 : 2;
		cstring type = content.substr(0, typelen);
		cstring id_str = content.substr(typelen, ~0);
		snowflake id;
		if (id_str[0] != '0') id = id_str; // web client doesn't recognize users with leading zero
		
		if (type == "@" || type == "@!") // user (latter is with nick according to docs, but both render identically)
		{
			user* u = m_users.get_or_null(id);
			if (!u || !u->name.upstream) sp.text = "<"+type+id_str+">";
			else sp.text = "@"+username(u);
			
			if (!sp.is_spoiler())
				sp.fgcol = 0xC04000;
		}
		else if (type == "#") // channel
		{
			channel* c = m_channel_index.get_or(id, NULL);
			// TODO: || current user can't read that channel
			if (!c || (!c->used && !c->name.upstream)) // name.upstream is empty for muted but deleted (or left guild) channels
			{
				sp.text = "#deleted-channel";
				return;
			}
			
			sp.text = channel_name(c);
			if (sp.text[0] != '#')
				sp.text = "#"+sp.text;
			
			if (!is_dm_guild(c->parent) && !sp.is_spoiler())
				sp.fgcol = 0xC08000;
		}
		else if (type == "@&") // group aka role
		{
			role* r = m_role_index.get_or(id, NULL);
			if (!r || !r->name.upstream)
			{
				sp.text = "@deleted-role";
				return;
			}
			sp.text = "@"+role_name(r);
			if (!sp.is_spoiler())
				sp.fgcol = 0xC00040;
		}
		else
		{
			abort(); // shouldn't happen
		}
	}
}

void heartbeat_cb()
{
	if (!m_ws_coro.is_waiting())
		connect().then(&m_ws_coro);
	else if (!m_should_heartbeat) {}
	else if (!m_heartbeat_sent)
	{
		m_heartbeat_sent = true;
		JSONw json;
		json["op"] = 1; // Heartbeat
		json["d"] = m_sequence;
		send_ws(json);
	}
	else
	{
		disconnect(true, "Ping timeout");
	}
}

void action(chanbase& at, cstrnul text) override
{
	//TODO: more commands
	// /play, /listento, /watch
	// /back, /away, /dnd, /invis
	
	channel* chan = at.userdata;
	
	auto simple_message = [&at](cstring text) {
		span sp[1] = { { text } };
		at.message(chanbase::imp_scrollback, time(NULL), sp);
	};
	
	if (LIKELY(text[0] != '/'))
	{
		if (!chan) return simple_message("* Can't talk here");
		send_message(chan, text); // extra escaping disabled for now, too buggy
		
		//if (UNLIKELY(text[0] == '!'))
		//	send_message(userdata, text); // extra escaping tends to confuse bots
		//else
		//	send_message(userdata, m_format->unparse_irc(text));
		return;
	}
	if (text[0] == '/' && text[1] == '/')
	{
		if (!chan) return simple_message("* Can't talk here");
		send_message(chan, text.substr(1, ~0));
		//send_message(chan, m_format->unparse_irc(text.substr(1, ~0)));
		return;
	}
	
	array<cstring> parts = text.substr(1, ~0).csplit<1>(REGEX(" |(?=\\n)"));
	cstring command = parts[0];
	cstring param = parts.size()==2 ? parts[1] : "";
	
	if(0);
	else if (command == "join")
	{
		array<channel*> matches;
		
		unsigned idx;
		if (fromstring(param, idx) && idx < m_channels.size() && m_channels[idx]->parent)
			matches.append(m_channels[idx]);
		
		bool in_guild = (chan && !is_dm_guild(chan->parent));
		// if not server tab, and current channel is in a guild (not DM or groupchat), check that guild first
		// /join without argument (aka show all) should also only show that guild, there are often hundreds of channels total
		if (!matches && chan && param==".")
		{
			matches.append(chan);
		}
		for (int type : range(5))
		{
			guild* parent = chan ? chan->parent : nullptr;
			if (matches) break;
			for (channel* c : m_channels)
			{
				if (!c->parent) continue;
				
				if (type == 0)
				{
					// same guild (including the DM group, if starting from there)
					if (c->parent != parent) continue;
					
					if (channel_name(c).matches_globi(param) || channel_name(c).matches_globi("#"+param))
						matches.append(c);
				}
				if (type == 1)
				{
					// search for anything starting with the given name
					if (c->parent != parent) continue;
					
					if (channel_name(c).matches_globi(param+"*") || channel_name(c).matches_globi("#"+param+"*"))
						matches.append(c);
				}
				if (type == 2)
				{
					// #0 but any guild
					if (channel_name(c).matches_globi(param) || channel_name(c).matches_globi("#"+param))
						matches.append(c);
				}
				if (type == 3)
				{
					// #1 but any guild
					if (channel_name(c).matches_globi(param+"*") || channel_name(c).matches_globi("#"+param+"*"))
						matches.append(c);
				}
				if (type == 4)
				{
					// anything containing the given string
					if (channel_name(c).matches_globi("*"+param+"*"))
						matches.append(c);
				}
			}
		}
		
		if (!matches)
			return simple_message("No such channel");
		
		if (matches.size() == 1 && matches[0] != chan)
		{
			channel* c = matches[0];
			c->visible = v_yes;
			channel_host(c);
			c->host->focus();
		}
		else
		{
			for (channel* c : matches)
			{
				string ago;
				if (c->scrollback.size() && c->scrollback[c->scrollback.size()-1].id)
				{
					int sec = (time(NULL) - c->scrollback[c->scrollback.size()-1].at);
					int mul;
					const char * mul_name;
					if(0);
					else if (sec < 3600) { mul = 60; mul_name = "minute"; }
					else if (sec < 86400) { mul = 3600; mul_name = "hour"; }
					else { mul = 86400; mul_name = "day"; }
					int tmp = sec/mul;
					ago = tostring(tmp)+" "+mul_name+(tmp==1 ? "" : "s")+" ago";
				}
				else ago = "at never";
				
				size_t idx;
				for (idx=0; m_channels[idx] != c; idx++) {}
				string text = "("+tostring(idx)+", "+guild_name(c->parent)+") "+
				              channel_name(c)+", last activity "+ago+", <#"+tostring(c->id)+">";
				simple_message(text);
			}
		}
	}
	else if (command == "uid")
	{
		array<user*> matches;
		
		for (int type : range(2))
		{
			for (auto& pair : m_users)
			{
				if (type == 0 && username(&pair.value).matches_globi(param+"*"))
					matches.append(&pair.value);
				if (type == 1 && username(&pair.value).matches_globi("*"+param+"*"))
					matches.append(&pair.value);
			}
			if (matches) break;
		}
		
		if (!matches)
			return simple_message("* No users found");
		
		for (user* u : matches)
		{
			string name = username(u);
			if (name == u->name.upstream)
				simple_message(format("* ",name," <@",u->id.num(),">")); // TODO: allow format(snowflake)
			else
				simple_message(format("* ",name," (",u->name.upstream,") <@",u->id.num(),">"));
		}
	}
	else if (command == "rid")
	{
		bool in_guild = (chan && !is_dm_guild(chan->parent));
		
		array<role*> matches;
		
		int type;
		for (type=0;type<4;type++)
		{
			for (role* r : m_roles)
			{
				if (!(type&2) && in_guild && r->parent != chan->parent) continue;
				
				if (!(type&1) && role_name(r).matches_globi(param+"*"))
					matches.append(r);
				if ((type&1) && role_name(r).matches_globi("*"+param+"*"))
					matches.append(r);
			}
			if (matches) break;
		}
		
		if (!matches)
			return simple_message("* No matching role found");
		
		for (role* r : matches)
			simple_message("* "+role_name(r)+(r->pingable ? " <@&" : " ")+tostring(r->id)+(r->pingable ? ">" : "")+
			               (type&2?" (wrong guild)":""));
	}
	else if (command == "gid")
	{
		for (guild* g : m_guilds)
			simple_message("* "+guild_name(g)+" "+tostring(g->id));
	}
	else if (command == "part")
	{
		if (!chan)
			return simple_message("* Can't leave the server tab");
		if (param)
			return simple_message("* This command doesn't take arguments");
		
		chan->visible = v_closed;
		channel_host(chan);
	}
	else if (command == "ban" || command == "reban")
	{
		array<cstring> words = param.csplit<1>(" ");
		
		if (!chan || is_dm_guild(chan->parent))
			return simple_message("* Can't ban people from DMs");
		if (words.size() == 1)
			return simple_message("* Ban reason is mandatory"); // technically isn't, but anyone who omits it is a Bad Personâ„¢
		snowflake uid = words[0];
		if (!uid)
			return simple_message("* Invalid user snowflake");
		
		string unban_url = "/guilds/"+chan->parent->id.str()+"/bans/"+uid.str();
		string ban_url = unban_url+"?reason="+http_t::urlencode(words[1]);
		
		m_http_waiters.add([](discord* self, bool reban, string unban_url, string ban_url, chanbase* at)->async<void> {
			http_t::rsp r;
			
			if (reban)
			{
				r = co_await self->http_api("DELETE", unban_url);
				if (!r.success())
					goto cancel;
			}
			
			r = co_await self->http_api("PUT", ban_url);
			
		cancel:
			span sp[2] = { { "* " }, { r.text_unsafe() } };
			if (!sp[1].text)
				sp[1].text = tostring(r.status);
			at->message(chanbase::imp_scrollback, time(NULL), sp);
		}(this, (command == "reban"), unban_url, ban_url, &at));
	}
	else if (command == "attach")
	{
		if (!chan)
			return simple_message("* Can't talk in here");
		
		m_http_waiters.add([](discord* self, channel* chan, string param)->async<void>{
			auto simple_message = [chan](cstring text) {
				span sp[1] = { { text } };
				chan->host->message(chanbase::imp_scrollback, time(NULL), sp);
			};
			
			array<cstring> fn_text = param.csplit<1>("\n");
			array<cstring> fn_dispfn = fn_text[0].csplit<1>("#");
			cstring text = (fn_text.size() == 2 ? fn_text[1] : "");
			
			cstring dispfn;
			cstring fn = fn_dispfn[0];
			
			if (fn_dispfn.size() == 2)
				dispfn = fn_dispfn[1];
			else if (fn.contains("/"))
				dispfn = fn.crsplit<1>("/")[1];
			else if (fn)
				dispfn = fn;
			else
				dispfn = "unknown.png";
			
			if (fn)
			{
				array<uint8_t> contents = co_await http_t::get_any(fn.c_str(), &autoproxy::socket_create_sslmaybe);
				if (!contents)
					co_return simple_message("* Couldn't read "+fn);
				
				self->send_message(chan, text, dispfn, contents);
			}
			else
			{
				bytearray png = co_await self->clipboard_get_image_png();
				if (!png)
					co_return simple_message("* No filename given, and no image on clipboard");
				self->send_message(chan, text, dispfn, png);
			}
		}(this, chan, param));
	}
	else if (command == "attachtext")
	{
		if (!chan)
			return simple_message("* Can't talk in here");
		
		array<cstring> fn_text = param.csplit<1>("\n");
		if (fn_text.size() != 2)
			return simple_message("* Missing argument");
		
		cstring fn = fn_text[0];
		cstring text = fn_text[1];
		if (!fn) fn = "message.txt";
		send_message(chan, "", fn, text.bytes());
	}
	else if (command == "raw" || command == "md")
	{
		if (!chan)
			return simple_message("* Can't talk in here");
		send_message(chan, param);
	}
	else if (command == "reply")
	{
		if (!chan)
			return simple_message("* Can't talk in here");
		
		array<cstring> parts = param.csplit<1>(REGEX(" |(?=\\n)"));
		if (!parts[0])
			return simple_message("* Invalid input");
		JSONw json;
		if (parts[0][0] == '@')
		{
			json["message_reference"]["message_id"] = parts[0].substr(1, ~0);
		}
		else
		{
			json["message_reference"]["message_id"] = parts[0];
			json["allowed_mentions"]["parse"][0] = "users";
			json["allowed_mentions"]["parse"][1] = "roles";
			json["allowed_mentions"]["parse"][2] = "everyone";
			json["allowed_mentions"]["replied_user"] = false;
		}
		send_message(chan, (parts.size() > 1) ? parts[1] : "", json);
	}
	else if (command == "edit")
	{
		if (!chan)
			return simple_message("* Can't talk in here");
		m_http_waiters.add([](discord* self, channel* chan, string param)->async<void>{
			array<cstring> parts = param.csplit<1>(REGEX(" |(?=\\n)"));
			JSONw json;
			json["content"] = (parts.size() > 1) ? parts[1] : "";
			http_t::rsp r = co_await self->http_api("PATCH", "/channels/"+chan->id.str()+"/messages/"+parts[0], json);
			self->send_message_cb(std::move(r));
		}(this, chan, param));
	}
	else if (command == "delete")
	{
		if (!chan)
			return simple_message("* Can't do that here");
		m_http_waiters.add([](discord* self, channel* chan, string param)->async<void>{
			http_t::rsp r = co_await self->http_api("DELETE", "/channels/"+chan->id.str()+"/messages/"+param);
			self->send_message_cb(std::move(r));
		}(this, chan, param));
	}
	else if (command == "render")
	{
		array<span> sp = { { "* " } };
		
		m_current_msg_chan = NULL;
		m_current_msg = "";
		m_format->parse(discord_format::normal, sp, span(), param);
		
		at.message(chanbase::imp_scrollback, time(NULL), sp);
	}
	else if (command == "play")
	{
		set_visible_status(st_game, param);
	}
	else if (command == "status")
	{
		set_visible_status(st_custom, param);
	}
	else if (command == "emoji")
	{
		if (param == "?")
		{
			if (!m_emoji_avatars.size())
				return simple_message("* Emoji library not loaded, or text-only emoji library");
			array<span> spans;
			spans.append({ "* " });
			for (int _ : range(10))
			{
				span& sp = spans.append();
				const discord_emoji::emoji* em = m_emoji_avatars[g_rand(m_emoji_avatars.size())];
				sp.text = em->unicode;
				sp.img = m_emoji->get_image(em);
			}
			at.message(chanbase::imp_scrollback, time(NULL), spans);
			return;
		}
		if (param)
		{
			array<cstring> matches;
			array<cstring> matches_without_tone;
			cstring exact_match;
			const discord_emoji::emoji* exact_match_em = m_emoji->find_by_unicode(param);
			
			for (const discord_emoji::emoji* em : m_emoji->list())
			{
				bool found_this = false;
				for (cstring name : em->names)
				{
					if (name == param || name == ":"+param+":" || exact_match_em == em)
					{
						exact_match = name;
						exact_match_em = em;
						goto lesser_match;
					}
					if (name.contains(param))
					{
					lesser_match:
						matches.append(name);
						if (!em->names[0].contains("_tone"))
							matches_without_tone.append(name);
						break;
					}
				}
			}
			if (matches.size() == 0)
				return simple_message("No matching emoji found");
			
			if (exact_match)
			{
				array<span> spans;
				spans.append({ "* " });
				m_emoji->insert_by_name(spans, span(), exact_match);
				spans.append({ " "+exact_match_em->unicode+" "+exact_match_em->names[0] });
				if (exact_match_em->names.size() > 1) spans.append({ " ("+exact_match_em->names.skip(1).join(", ")+")" });
				at.message(chanbase::imp_scrollback, time(NULL), spans);
				
				if (matches.size() == 1) return;
			}
			
			array<span> spans;
			spans.append({ "* " });
			
			arrayview<cstring> matches_use = matches;
			if (matches.size() > 25 && matches_without_tone) matches_use = matches_without_tone;
			
			for (cstring name : matches_use)
			{
				if (matches_use.size() > 50)
					spans.append({ name });
				else
					m_emoji->insert_by_name(spans, span(), name);
			}
			
			if (matches_use.size() != matches.size())
				spans.append({ " plus "+tostring(matches.size()-matches_without_tone.size())+" skin tone variants" });
			
			at.message(chanbase::imp_scrollback, time(NULL), spans);
			return;
		}
		
		array<span> spans;
		for (guild* g : m_guilds)
		{
			if (!g->emoji) continue;
			if (chan && chan->parent != g) continue;
			if (spans) spans.append({ "\n" });
			for (guildemoji& ge : g->emoji)
			{
				span sp[2] = { { (ge.animated?"<a:":"<:")+ge.name+":"+tostring(ge.id)+">" }, { " " } };
				string url = m_server_img+"/emojis/"+tostring(ge.id)+".png?size="+tostring(bitround(get_line_height()));
				sp[0].img = image_create_url(url, get_line_height());
				spans += sp;
			}
			if (!chan)
				spans.append({ "("+guild_name(g)+")" });
		}
		if (spans) spans.pop_tail();
		else spans.append({ "* No emoji in this guild" });
		at.message(chanbase::imp_scrollback, time(NULL), spans);
	}
	else if (command == "mutual")
	{
		if (param.startswith("<@")) param = param.substr(2, ~1);
		snowflake snow;
		if (!snow.init(param))
			return simple_message("* Invalid input");
		
		m_http_waiters.add([](discord* self, chanbase* at, snowflake snow)->async<void>{
			string mutual = co_await self->mutual_guilds(snow);
			span sp[1] = { { "* Mutual guilds: "+mutual } };
			at->message(chanbase::imp_scrollback, time(NULL), sp);
		}(this, &at, snow));
	}
	else if (command == "snow")
	{
		uint64_t snow;
		if (!fromstring(param, snow))
			return simple_message("* Invalid input");
		
		uint64_t timestamp_discoepoch_ms = snow>>22;
		unsigned worker = (snow>>17)&31;
		unsigned process = (snow>>12)&31;
		unsigned increment = snow&0xFFF;
		
		uint64_t unixepoch_to_discoepoch_seconds = 1420070400; // 1970-01-01 00:00:00 to 2015-01-01 00:00:00
		time_t timestamp_snow = timestamp_discoepoch_ms/1000 + unixepoch_to_discoepoch_seconds;
		struct tm tm_snow = *localtime(&timestamp_snow);
		
		time_t timestamp_now = time(nullptr);
		struct tm tm_now = *localtime(&timestamp_now);
		
		char time_human[32];
		char time_fraction[5];
		strftime(time_human, 32, "%Y-%m-%d %H:%M:%S", &tm_snow);
		sprintf(time_fraction, ".%03u", (unsigned)(timestamp_discoepoch_ms%1000));
		string result = (cstring)"* Snowflake generated at "+time_human+time_fraction+" (local time)";
		
		auto pluralize = [](int n, const char * singular, const char * plural = nullptr) -> string {
			if (n == 1) return (cstring)"1 "+singular;
			else if (plural) return tostring(n)+" "+plural;
			else return tostring(n)+" "+singular+"s";
		};
		
		int month_diff = (tm_now.tm_year*12 + tm_now.tm_mon) - (tm_snow.tm_year*12 + tm_snow.tm_mon);
		time_t day_diff = (timestamp_now - timestamp_snow) / 86400; // use time_t to avoid creepy truncation issues
		time_t hour_diff = (timestamp_now - timestamp_snow) / 3600; // also mix second and calendar math;
		time_t minute_diff = (timestamp_now - timestamp_snow) / 60; // yields inconsistent rounding, but it's good enough
		time_t second_diff = (timestamp_now - timestamp_snow);
		if (timestamp_now < timestamp_snow) {} // future timestamp - don't try to analyze
		else if (month_diff >= 18)
			result += "; "+pluralize(month_diff/12, "year")+", "+pluralize(month_diff%12, "month")+" ago";
		else if (month_diff >= 6)
			result += "; "+pluralize(month_diff, "month")+" ago";
		else if (day_diff >= 28)
			result += "; "+pluralize(day_diff/7, "week")+", "+pluralize(day_diff%7, "day")+" ago";
		else if (hour_diff >= 48)
			result += "; "+pluralize(hour_diff/24, "day")+", "+pluralize(hour_diff%24, "hour")+" ago";
		else if (minute_diff >= 120)
			result += "; "+pluralize(minute_diff/60, "hour")+", "+pluralize(minute_diff%60, "minute")+" ago";
		else if (second_diff >= 120)
			result += "; "+pluralize(second_diff/60, "minute")+", "+pluralize(second_diff%60, "second")+" ago";
		else
			result += "; "+pluralize(second_diff, "second")+" ago";
		
		result += "; raw timestamp "+tostring(timestamp_discoepoch_ms)+", Unix timestamp "+tostring(timestamp_snow)+time_fraction+
				"; worker "+tostring(worker)+", process "+tostring(process)+", increment "+tostring(increment);
		
		simple_message(result);
	}
	else if (command == "rawws")
	{
		JSONw json;
		if (!json.parse(param))
			return simple_message("* Invalid JSON");
		send_ws(json);
	}
	else if (command == "http" || command == "unsafehttp")
	{
		if (!param)
			return simple_message("* Example: /http PATCH /users/@me {\"username\":\"Sir Walrus\"}");
		
		string method;
		string url;
		string json;
		
		if (param[0] != '/')
		{
			array<cstring> parts = param.csplit<2>(" ");
			method = parts[0];
			url = parts[1];
			if (parts.size() == 3)
				json = parts[2];
		}
		else
		{
			array<cstring> parts = param.csplit<1>(" ");
			url = parts[0];
			if (parts.size() == 2)
				json = parts[1];
		}
		
		if (command == "http")
		{
			JSONw parsetest;
			if (json && !parsetest.parse(json))
				return simple_message("* Invalid JSON");
			
			if (url == "/users/@me/channels" || REGEX("/guilds/[0-9]+/members$").match(url))
				return simple_message("* Don't use this endpoint from third-party clients, "
				                         "it will detect \"suspicious activity\" and demand phone verification");
		}
		
		http_t::req q;
		q.loc.path = url;
		q.method = method.upper();
		q.body = json.bytes();
		m_http_waiters.add([](discord* self, chanbase* at, http_t::req& q)->async<void>{
			http_t::rsp r = co_await self->http_api(q);
			span sp[2] = { { "* " }, { r.text_unsafe() } };
			if (!sp[1].text)
				sp[1].text = tostring(r.status);
			at->message(chanbase::imp_scrollback, time(NULL), sp);
		}(this, &at, q));
	}
	else if (command == "resume")
	{
		if (param)
			return simple_message("* This command doesn't take arguments");
		
		disconnect(true, "/resume");
	}
	else if (command == "disconnect")
	{
		if (param)
			return simple_message("* This command doesn't take arguments");
		
		disconnect(false, "/disconnect");
		m_http_waiters.reset();
		m_scrollback_coro.cancel();
		m_fetch_scrollback.reset();
	}
	else if (command == "newtoken")
	{
		m_resume_token = "";
		m_resume_token_prev = "";
		string prev_token = std::move(m_token);
		if (param)
		{
			m_token = param;
			m_token_is_config = true;
		}
		else
		{
			m_token = token_from_firefox(m_email);
			m_token_is_config = false;
		}
		if (!m_token)
			return simple_message("* No token found, discarding old one");
		else if (m_token == prev_token)
			return simple_message("* Token reloaded, did nothing");
		else
			return simple_message("* Token updated");
	}
	else if (command == "sync")
	{
		if (param)
			return simple_message("* This command doesn't take arguments");
		
		timer t;
		write_cache();
		simple_message("* State synchronized in "+tostring(t.ms())+"ms");
	}
	else if (command == "recv")
	{
		JSON json(param);
		if (!json)
			return simple_message("* Invalid JSON");
		ws_str(param);
	}
	else
	{
		return simple_message("* Unknown command");
	}
}

void send_message(channel* c, cstring markdown)
{
	JSONw json;
	send_message(c, markdown, json);
}

void send_message(channel* c, cstring markdown, JSONw& json)
{
	if (!json["content"])
		json["content"] = markdown;
	json["nonce"] = tostring(tostring(timestamp::now()));
	http_t::req r;
	r.loc.path = "/channels/"+c->id.str()+"/messages";
	r.method = "POST";
	r.body = json.serialize().bytes();
	send_message(c, markdown, r);
}

void send_message(channel* c, cstring markdown, cstring attach_fname, arrayview<uint8_t> attach_content)
{
	if (attach_content.size() > 25*1024*1024)
	{
		span sp[] = { { "* Attachment size "+tostring(attach_content.size())+" exceeds limit "+tostring(25*1024*1024) } };
		c->host->message(chanbase::imp_scrollback, time(NULL), sp);
		return;
	}
	
	http_t::form f;
	if (markdown) f.value("content", markdown);
	f.value("nonce", tostring(tostring(timestamp::now())));
	f.file("file", attach_fname, attach_content);
	
	http_t::req r;
	r.loc.path = "/channels/"+c->id.str()+"/messages";
	r.method = "POST";
	//r.limit_ms = 2000 + attach_content.size()/250; // two seconds, plus four seconds per megabyte
	f.attach(r);
	send_message(c, markdown+"\n<"+attach_fname+" ("+tostring(attach_content.size())+" bytes)>", r);
}

void send_message_cb(http_t::rsp r)
{
	if (m_rawlog)
		m_rawlog.write(logdate()+" >> "+tostring(r.status)+" "+r.text_unsafe()+"\n");
	if (!r.success())
	{
		cstring bodytext = cstring(r.request.body);
		if (bodytext.startswith("-")) // --ArlibFormBoundary
			bodytext = bodytext.csplit<1>("Content-Disposition: file")[0];
		if (r.text_unsafe())
			status("Couldn't send message: "+cstring(r.text_unsafe())+" "+bodytext);
		else
			status("Couldn't send message: "+tostring(r.status)+" "+bodytext);
	}
}

void send_message(channel* c, cstring markdown, http_t::req& q)
{
	user* u = m_users.get_or_null(m_my_id);
	if (u)
	{
		del_tmp();
		span fmt;
		fmt.fgcol = 0x404040;
		array<span> spans;
		
		m_emoji->insert_by_name(spans, fmt, ":hourglass:"); // always succeeds if given a valid emoji package, and if not, no big deal
		spans.append().text = " <"+username_for_id(m_my_id)+"> ";
		
		parse_format(discord_format::normal, spans, fmt, markdown, c, "");
		c->host->message("tmp", chanbase::imp_scrollback, time(NULL), spans); // not really scrollback, but shouldn't be logged
		m_tmp_msg_in = c->host;
	}
	
	m_http_waiters.add([](discord* self, http_t::req& q)->async<void>{
		http_t::rsp r = co_await self->http_api(q);
		self->send_message_cb(r);
	}(this, q));
}

void contextmenu(chanbase& at, cstrnul msgid_, array<textview::ctxaction>& actions) override
{
	if (!msgid_) return; // global command inserted something unexpected? can't do anything with that
	if (msgid_ == "temp") return; // ignore this one too
	
	channel* chan = at.userdata;
	if (!chan) return;
	
	string msgid = msgid_;
	message* msg = chan->get_msg_by_id(msgid);
	bool ping_user = m_ping_reply;
	if (msg)
	{
		user* u = user_for_id(msg->author);
		if (u && u->ping_reply != -1)
			ping_user = u->ping_reply;
		if (u)
			actions.insert(0, { time_to_str(msg->at, "%H:%M:%S")+" "+u->name.get(), nullptr });
	}
	
	actions.append({ "Copy Message Link",
		[this, chan, msgid](){
			//https://discord.com/channels/485971752992636929/533701677660897280/744938433985642546
			string guild_id = (is_dm_guild(chan->parent) ? (cstring)"@me" : chan->parent->id.str());
			this->clipboard_set_text("https://discord.com/channels/"+guild_id+"/"+chan->id.str()+"/"+msgid);
		} });
	actions.append({ "Reply", [chan, msgid, ping_user](){
		chan->host->input_prefix("/reply " + cstring(ping_user ? "@" : "") + msgid + "\n");
	} });
	
	if (msg)
	{
		if (msg->author == m_my_id)
		{
			actions.append({ "Edit", [chan, msgid](){
					message* msg = chan->get_msg_by_id(msgid);
					if (!msg) return; // can happen if the message is purged from the scrollback
					chan->host->input_replace("/edit "+msgid+" "+msg->text);
				} });
		}
		else
		{
			actions.append({ "View Source", [chan, msgid](){
					message* msg = chan->get_msg_by_id(msgid);
					if (!msg) return; // can happen if the message is purged from the scrollback
					chan->host->input_replace(msg->text);
				} });
		}
	}
}

//void begin_private(chanbase& at, cstrnul name) override {} // leave it empty, there's landmines on the create DM endpoint

void close_chan(chanbase& at) override
{
	channel* chan = at.userdata;
	if (!chan) return;
	
	chan->visible = (chan->muted==m_no ? v_ifactive : v_closed);
	channel_host(chan);
}

// TODO: is it possible to merge this one into the deserializer?
void write_cache()
{
#if FAKE_CONNECT
	return;
#endif
	
	bool any_guilds = false;
	string cache = jsonserialize([this, &any_guilds](jsonserializer& s)
	{
		s.items(
			"self", m_my_id.str(),
			"gateway", ser_include_if(m_gateway_good, m_server_gateway),
			"guilds", [this, &any_guilds](jsonserializer& s) {
				for (guild* g : m_guild_order)
				{
					if (!g->exists) continue;
					any_guilds = true;
					s.item(g->id.str(), [this, g](jsonserializer& s)
					{
						if (g->id)
							s.item("name", g->name.upstream);
						s.item("roles", [g](jsonserializer& s)
						{
							for (role* r : g->roles)
							{
								if (g->used && !r->used) continue;
								s.item(r->id.str(), [r](jsonserializer& s)
								{
									s.item("name", r->name.upstream);
								});
							}
						});
						s.item("channels", [this, g](jsonserializer& s)
						{
							for (channel* c : g->channels)
							{
								if (g->used && !c->used) continue;
								s.item(c->id.str(), [this, c](jsonserializer& s)
								{
									s.item("name", c->name.upstream);
									if (c->parent_id) s.item("parent", c->parent_id);
									if (!is_dm_guild(c->parent))
									{
										if (c->muted != m_dontknow)
											s.item("hidden", c->muted == m_yes);
										else
											s.item("hidden", c->visible <= v_ifactive);
									}
									
									size_t scrollsize = 250;
									if (c->scrollback.size() > scrollsize)
										c->scrollback.remove_range(0, c->scrollback.size()-scrollsize);
									s.item("scrollback", c->scrollback);
									s.item("scrollbackend", c->last_fetched_msg.str());
								});
							}
						});
						s.item("emoji", g->emoji);
					});
				}
			},
			"users", [&](jsonserializer& s){
				for (auto& pair : m_users)
				{
					if (!pair.value.used) continue;
					if (!pair.value.name.upstream && !pair.value.avatar) continue;
					s.item(pair.key.str(), [&pair](jsonserializer& s)
					{
						if (pair.value.name.upstream) s.item("name", pair.value.name.upstream);
						if (pair.value.avatar) s.item("avatar", pair.value.avatar);
						if (pair.value.is_webhook) s.item("webhook", true);
					});
				}
			});
	});
	
	if (m_cachename && any_guilds)
	{
		file::writeall(file::resolve(file::exedir(), m_cachename), cache);
	}
}

~discord()
{
	write_cache();
}
};
}
russian::protocol*
russian::protocol::create_discord(impl* parent, json5deserializer2& s) { return new discord(parent, s); }

test("Discord timestamps", "", "")
{
	// needs to contain at least one 08 or 09 to ensure it's not octal
	assert_eq(discord::iso8601_to_unix("2018-10-25T08:45:09.245000+00:00"), 1540457109);
}

}
