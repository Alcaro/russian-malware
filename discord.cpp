#include "russian.h"

#ifndef NO_SQLITE3
#include <sqlite3.h>
#endif

namespace russian {
class discord : public protocol {
public:

static string token_from_firefox(cstring email)
{
	string ret = "\"\""; // some suitable default value where trimming the quotes
	
#ifndef NO_SQLITE3
	// discord likes to drop strings through the json encoder for some reason
	// (they probably have some to_localstorage function that always jsons the argument)
	// let's just assume the email contains no special characters the json encoder would've quoted
	string email_esc = "\""+email+"\"";
	for (cstring name : file::listdir((string)getenv("HOME")+"/.mozilla/firefox/"))
	{
		if (!name.endswith("/")) continue;
		
		sqlite3* db;
		if (sqlite3_open_v2(name+"webappsstore.sqlite", &db, SQLITE_OPEN_READONLY, NULL) != 0)
		{
			sqlite3_close(db);
			continue;
		}
		
		sqlite3_stmt* stmt;
		sqlite3_prepare_v2(db,
			"SELECT t.value FROM webappsstore2 t "
			"WHERE t.key='token' "
			// firefox stores the domain name backwards for some unclear reason; source code does not explain why
			//  https://dxr.mozilla.org/mozilla-central/source/dom/storage/StorageDBUpdater.cpp
			// also obfuscate the string a little, googling the real one yields lots of creepy stuff I'd rather not be associated with
			"AND t.originKey='moc.\x70pad\x72oc\x73i\x64.:https:443' "
			// not completely sure what these originAttributes are, they're always blank for me
			// judging by source code, they're related to (some subset of)
			//  app id (which seems unused), addons, private browsing, third-party cookies
			// let's filter on it, so I'll notice if it starts getting used
			// (may improve performance too, there's an index on originAttributes+originKey+key)
			"AND t.originAttributes='' "
			"AND EXISTS (" // have to filter out incorrect emails somehow, doing it in sql gives cleaner code than c++
				"SELECT 1 FROM webappsstore2 e WHERE e.originKey = t.originKey "
				"AND e.key='email_cache' AND e.value=? "
				"AND e.originAttributes=''"
			")", -1, &stmt, NULL);
		
		sqlite3_bind_text(stmt, 1, email_esc, -1, SQLITE_STATIC);
		
		if (sqlite3_step(stmt) == SQLITE_ROW)
		{
			ret = (char*)sqlite3_column_text(stmt, 0); // 
		}
		sqlite3_finalize(stmt);
		sqlite3_close(db);
	}
#endif
	
	return ret.substr(1, ~1); // assume no special chars in the token either
}
};
}

string x(cstring y);
string x(cstring y)
{
return russian::discord::token_from_firefox(y);
}
