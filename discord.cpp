#include "russian.h"

// TODO: enable nocopy

//#define FAKE_CONNECT 1

#if FAKE_CONNECT
#define DEBUG_ONLY
#else
#define FAKE_CONNECT 0
#endif

#include "discord.h"

#ifndef NO_SQLITE3
#include <sqlite3.h>
#endif

#define MINIZ_HEADER_FILE_ONLY
#include "arlib/deps/miniz.c"

namespace russian {
namespace {
class snowflake {
	uint64_t n;
public:
	snowflake() { n=0; }
	snowflake(cstring str) { fromstring(str, n); }
	snowflake(const JSON& json) { fromstring(json.str(), n); }
	
	string str() const { return tostring(n); }
	explicit operator string() const { return tostring(n); }
	
	uint64_t num() const { return n; }
	uint64_t hash() const { return n; }
	
	explicit operator bool() const { return n != 0; }
	bool operator!() const { return n == 0; }
	
	bool operator==(const snowflake& other) const { return n == other.n; }
	bool operator!=(const snowflake& other) const { return n != other.n; }
};
static bool operator==(cstring a, const snowflake& b) { uint64_t an; return fromstring(a, an) && b.num()==an; }

class discord : public protocol {
public:

#define USER_AGENT "ðŸ‡·ðŸ‡º" // russian flag

//Everything in this file, including this static function, must be called on the main thread.
static string token_from_firefox(cstring email)
{
	string ret = "\"\""; // some suitable default value such that trimming the edge chars yields a blank string
	
#ifndef NO_SQLITE3
	// discord likes to drop strings through the json encoder for some reason
	// (they probably have some to_localstorage function that always jsons the argument)
	// let's just assume the email contains no special characters the json encoder would've quoted
	string email_esc = "\""+email+"\"";
	
	for (cstring dirname : file::listdir((string)getenv("HOME")+"/.mozilla/firefox/"))
	{
		if (!dirname.endswith("/")) continue;
		
		sqlite3* db;
		//Firefox holds some kind of lock on this file while running. I must unlock, disable, or
		//  bypass this lock somehow, or I can't open the db.
		//The chosen mechanism is claiming immutability; it's a lie, but the alternatives are
		//- demanding Firefox to be not running
		//    this program has no right to dictate the user's workflow
		//- demanding Firefox <= 62 (it only started holding permanent locks in 63)
		//    insecure
		//- copying the database file somewhere
		//    waste of megabytes, and likely to leak or fail if the program crashes or runs concurrently
		//- a custom VFS that ignores locking
		//    yields nasty spaghetticode with many special cases, where bad or incomplete implementations would likely write to the file
		//    (even with SQLITE_OPEN_READONLY, it still writes a bit)
		//so this is the least bad method
		if (sqlite3_open_v2("file:"+dirname+"webappsstore.sqlite?immutable=1", &db,
		                    SQLITE_OPEN_URI|SQLITE_OPEN_READONLY, NULL) != SQLITE_OK)
		{
			sqlite3_close(db);
			continue;
		}
		
		sqlite3_stmt* stmt;
		sqlite3_prepare_v2(db,
			"SELECT t.value FROM webappsstore2 t "
			"WHERE t.key='token' "
			// firefox stores the domain name backwards, for quota management purposes
			//  https://hg.mozilla.org/mozilla-central/rev/e0251c29291c#l10.27 (can't find any equivalent comment in recent versions)
			// also obfuscate the string a little, googling the real one yields lots of creepy stuff I'd rather not be associated with
			"AND t.originKey='moc.\x70pad\x72oc\x73i\x64.:https:443' "
			// not completely sure what these originAttributes are
			// judging by source code, they're related to (some subset of)
			//  app id (which seems unused), addons, private browsing, third-party cookies
			// I've seen "^firstPartyDomain=github.com" on a localstorage on gist.github.com,
			//  and similar for stackoverflow, but only where firstPartyDomain is a subset of the real one,
			//  which is false for discord
			// let's filter on it, to notice if it starts getting used
			// (may improve performance too, there's an index on originAttributes+originKey+key)
			"AND t.originAttributes='' "
			"AND EXISTS (" // have to filter out incorrect emails somehow, doing it in sql gives cleaner code than c++
				"SELECT 1 FROM webappsstore2 e WHERE e.originKey = t.originKey "
				"AND e.key='email_cache' AND e.value=? "
				"AND e.originAttributes=''"
			")", -1, &stmt, NULL);
		// SQLITE_STATIC says "it means that the content pointer is constant and will never change", which is technically false
		// but there's no way sqlite's gonna want it after sqlite3_finalize, so let's use STATIC anyways
		sqlite3_bind_text(stmt, 1, email_esc, -1, SQLITE_STATIC);
		
		if (sqlite3_step(stmt) == SQLITE_ROW)
		{
			ret = (char*)sqlite3_column_text(stmt, 0);
		}
		sqlite3_finalize(stmt);
		sqlite3_close(db);
	}
#endif
	
	return ret.substr(1, ~1); // assume no special chars in the token either
}

string m_server_base; // https://discordapp.com/api
string m_server_gateway; // wss://gateway.discord.gg/
string m_server_img; // https://cdn.discordapp.com/
bool m_gateway_good = false;

string m_token;
snowflake m_my_id; // snowflake

socks5 m_proxy;
WebSocket m_ws;
HTTP m_http_api; // different http objects per domain, they're whiny
HTTP m_http_img;

bool m_enable_avatars = true;

//valid transitions:
//0->1 - heartbeat timer
//0->2 - heartbeat timer
//1->2 - http request done
//2->0 - connection failure
//2->3 - resumption rejected
//2->4 - READY or RESUMED
//3->4 - READY (RESUMED impossible)
//3->0 - connection failure
//4->2 - connection failure
//0 can only be left by the heartbeat timer
enum { cs_offline, cs_get_gateway, cs_connecting, cs_connecting_retry, cs_online };
uint8_t m_connect_state = cs_offline;

bool m_heartbeat_sent;
int m_heartbeat_timer;
int m_heartbeat_interval = 30000;

string m_resume_token;
int m_sequence = 0; // sequence number, for heartbeats and resumption

russian::channel* m_tmp_msg_in = NULL;

struct message /*: nocopy*/ {
	string id; // snowflake, plus suffix for attachments/etc (TODO: use plain snowflake, attachments should be a single message)
	snowflake author; // snowflake
	string text;
	bool is_highlight = false;
	time_t at;
	
	template<typename T>
	void serialize(T& s)
	{
		s.item("id", id);
		s.item("user", author);
		s.item("text", text);
		if (!s.serializing || is_highlight) s.item("highlight", is_highlight);
		s.item("time", at);
	}
};
enum vis_t : uint8_t {
	v_closed,   // hidden via config or manual close; appears via highlight or query activity
	v_no,       // hidden, but appears if unmuted server-side
	v_ifactive, // hidden, but appears if active, like queries (ignores server-side mute state)
	v_yes,      // visible
};
enum mute_t : uint8_t {
	m_no,
	m_dontknow,
	m_yes,
};
//expected guild channel visibility behavior: show if one or more of
//- guild channel unhidden in config
//- guild channel unmuted on server, and not hidden in config
//- guild channel unmuted in cache, and not hidden in config
//- guild channel highlight while online
//- guild channel highlight while offline
//- query unhidden in config (query hidden in config makes no difference)
//- query activity while online
//- query activity while offline
//cache: hidden if muted; if guild not connected, hidden if channel is currently hidden
struct channel /*: nocopy*/ {
	int parent = -1; // index to guild it's in, or -1 if unknown; set if and only if guild::channels contains this
	
	vis_t visible = v_no;
	mute_t muted = m_dontknow; // server-side only; ignored for queries (if a query is consistently active, list it in the config)
	bool used = false; // set to true upon server confirmation of its existence; if false, but guild is used, removed from cache
	
	snowflake id;
	string name;
	
	string override_name;
	
	autoptr<russian::channel> host;
	
	// can contain a message with only id, blank author/text/time
	// that one tells how much of the scrollback is read, and is useful only if no other messages exist
	array<message> scrollback;
	snowflake last_msg; // according to GUILD_CREATE::channel
	snowflake last_fetched_msg; // set to above on fetch success
	
	void nextmsg(cstring id, snowflake author, cstring text, bool is_highlight, time_t at)
	{
		message& m = scrollback.append();
		m.id = id;
		m.author = author;
		m.text = text;
		m.is_highlight = is_highlight;
		m.at = at;
		
		//keep 150 messages, to ensure it won't go below 100 even if some messages are deleted
		if (scrollback.size() > 300)
			scrollback = scrollback.slice(scrollback.size()-150, 150);
	}
	
	void setmsg(cstring id, cstring text)
	{
		for (size_t i=0;i<scrollback.size();i++)
		{
			message& m = scrollback[i];
			if (m.id == id)
			{
				if (text) m.text = text;
				else scrollback.remove(i);
				break;
			}
		}
	}
};
struct guild /*: nocopy*/ {
	snowflake id;
	string name;
	string override_name;
	bool online = false; // currently connected
	bool online_resume = false; // whether we'd be connected if we got a Resumed right now (false if fully connected)
	bool exists = false; // exists according to Ready
	bool used = false; // contents has been sent in Ready or Guild Create
	array<int> channels;
	autoptr<russian::group> host;
};

array<channel> m_channels;
array<guild> m_guilds; // the first one is always for private messages or groupchats, with id "0" and name taken from config
map<snowflake,int> m_guild_index; // key: guild snowflake; value: index to m_guilds
map<snowflake,int> m_channel_index; // like above

struct user /*: nocopy*/ {
	snowflake id;
	string name;
	string override_name;
	
	bool used = false;
	
	string avatar_addr; // hex blob, or blank
	
	array<byte> avatar_bytes;
	// if never used, this is NULL (avatar_bytes can be non-NULL if the cache contains it, but no message does)
	// if used and avatar_bytes is NULL, this is a transparent image
	textview::image* avatar_img;
};
map<snowflake,user> m_users;

struct guildemoji /*: nocopy*/ {
	// server doesn't verify what name you use for a guildemoji, so only image data is relevant
	array<byte> bytes;
	textview::image* img;
};
map<snowflake,guildemoji> m_guildemoji;

struct msgref /*: nocopy*/ {
	int chan;
	string msg;
};
// usually empty; if not, key is user or guildemoji snowflake, value is list of messages using the placeholder image
map<snowflake,array<msgref>> m_avatar_unloaded;
map<snowflake,array<msgref>> m_guildemoji_unloaded;

textview::image* m_img_error = NULL;

autoptr<discord_emoji> m_emoji;
autoptr<discord_format> m_format;

int m_current_msg_chan; // only used, and only valid, in the format_external callback
cstring m_current_msg; // most of the time, it's a dangling pointer
                       // used to set m_guildemoji_unloaded

string m_cachename;

file m_rawlog;

array<snowflake> m_fetch_scrollback;


guild& guild_for(snowflake id)
{
	int idx = m_guild_index.get_or(id, -1);
	if (LIKELY(idx >= 0)) return m_guilds[idx];
	m_guild_index.insert(id, m_guilds.size());
	guild& ret = m_guilds.append();
	ret.id = id;
	return ret;
}
int idx_for(guild& g) { return &g - &m_guilds[0]; }

channel& channel_for(snowflake id)
{
	int idx = m_channel_index.get_or(id, -1);
	if (LIKELY(idx >= 0)) return m_channels[idx];
	m_channel_index.insert(id, m_channels.size());
	channel& ret = m_channels.append();
	ret.id = id;
	return ret;
}
channel& channel_for(snowflake id, guild& g)
{
	channel& c = channel_for(id);
	if (UNLIKELY(c.parent == -1))
	{
		c.parent = idx_for(g);
		g.channels.append(idx_for(c));
	}
	return c;
}
int idx_for(channel& c) { return &c - &m_channels[0]; }

cstring guild_name(guild& g)
{
	if (g.override_name) return g.override_name;
	if (g.name) return g.name;
	return "<unknown>";
}
void guild_host(guild& g)
{
	cstring name = g.override_name;
	if (!name) name = g.name;
	if (!name) return;
	if (!g.host) g.host = mkgroup(name, chanbase::f_no_focus, -1);
	g.host->set_available(g.online);
	g.host->rename(name);
}
cstring channel_name(channel& c)
{
	if (c.override_name) return c.override_name;
	if (c.name) return c.name;
	return "<unknown>";
}
void channel_host(channel& c)
{
	cstring name = c.override_name;
	if (!name) name = c.name;
	if (!name)
	{
		status("ERROR: anonymous channel "+c.id.str());
		c.name = "<unknown>";
	}
	if (c.parent == -1)
	{
		status("ERROR: guildless channel "+c.id.str());
		c.parent = 0;
	}
	guild& g = m_guilds[c.parent];
	if (!c.host) c.host = g.host->child(name, chanbase::f_no_scrollback, idx_for(c));
	c.host->set_hidden(c.visible <= v_ifactive);
	c.host->set_available(g.online);
	c.host->rename(name);
}

void rename_all()
{
	for (guild& g : m_guilds)
	{
		if (g.host)
			guild_host(g);
	}
	for (channel& c : m_channels)
	{
		if (c.host)
			channel_host(c);
	}
}

//Takes a User object, returns the username. Handles overridden names, and caches the name, in case the next call contains only ID.
//Does not support guild-specific nicks.
string username(const JSON& json)
{
	user& u = m_users.get_create(json["id"]);
	u.id = json["id"];
	u.used = true;
	if (json["username"]) u.name = json["username"];
	
	string avatar = json["avatar"];
	if (avatar && u.avatar_addr != avatar)
	{
		u.avatar_addr = avatar;
		u.avatar_bytes.reset();
		delete u.avatar_img; // may be in some messages already, but the textbuffer claims references so deleting doesn't actually delete
		u.avatar_img = NULL;
	}
	
	if (u.override_name) return u.override_name;
	if (u.name) return u.name;
	return u.id.str();
}

string username(snowflake id)
{
	user* u = m_users.get_or_null(id);
	if (u) u->used = true;
	if (u && u->override_name) return u->override_name;
	if (u && u->name) return u->name;
	return id.str();
}


//Sanitizes NUL and bad utf8, hex encoding the offending bytes and painting them red.
static void sanitize_spans(array<span>& out, size_t start = 0)
{
	for (size_t i = start; i < out.size(); i++)
	{
		if (UNLIKELY(out[i].text.contains(string::nul()) || !out[i].text.isutf8()))
		{
			string danger = std::move(out[i].text); // clear out[i].text, format spans shouldn't have text
			span fmt = out.pop(i);
			
			//one span per character, it's easier and this code is super cold
			uint32_t out_idx = i;
			uint32_t idx = 0;
			while (idx < danger.length())
			{
				uint32_t cp = danger.codepoint_at(idx);
				if (cp == 0 || (cp >= 0xDC80 && cp <= 0xDCFF))
				{
					span& newsp = out.insert(out_idx++, fmt);
					newsp.fgcol = 0xFF0000;
					newsp.text = tostringhex<2>(cp&0xFF);
				}
				else
				{
					span& newsp = out.insert(out_idx++, fmt);
					newsp.text = string::codepoint(cp);
				}
			}
		}
	}
}


void status(cstring text)
{
	span sp[1] = { { text } };
	puts(sp[0].text);
	m_guilds[0].host->message(chanbase::imp_status, time(NULL), sp);
}
void fatal(cstring text)
{
	span sp[1] = { { text } };
	sp[0].fgcol = 0xFF0000;
	m_guilds[0].host->message(chanbase::imp_highlight, time(NULL), sp);
	m_guilds[0].host->rename("ERROR - "+m_guilds[0].name);
	
	runloop::global()->remove(m_heartbeat_timer);
	m_heartbeat_timer = 0;
	m_ws.reset();
	m_http_api.reset();
}
discord(impl* parent, bmldeserializer& s) : protocol(parent, fmt_b|fmt_o|fmt_m|fmt_i|fmt_s|fmt_u),
                                                m_ws(runloop::global()),
                                                m_http_api(runloop::global()), m_http_img(runloop::global())
{
	m_heartbeat_timer = 0;
	
	guild& g_root = guild_for(cstring("0"));
	g_root.name = s.nextval();
	g_root.host = mkgroup(g_root.name, chanbase::f_no_logs|chanbase::f_no_users, -1);
	
	string my_email;
	string proxy_addr;
	string emoji_fname;
	string rawlog_fname;
	ser_enter(s)
	{
		s.item("server", m_server_base);
		s.item("imgserver", m_server_img);
		s.item("email", my_email);
		s.item("token", m_token);
		s.item("socks5", proxy_addr);
		s.item("emoji", emoji_fname);
		s.item("rawlog", rawlog_fname);
		s.item("cache", m_cachename);
		s.item("avatars", m_enable_avatars);
		
		while (s.next() == "guild")
		{
			guild& g = guild_for(s.nextval());
			ser_enter(s)
			{
				s.item("name", g.override_name);
			}
		}
		while (s.next() == "channel")
		{
			channel& c = channel_for(s.nextval());
			string hidden_s;
			ser_enter(s)
			{
				s.item("hidden", hidden_s);
				s.item("name", c.override_name);
			}
			bool hidden_b;
			if (hidden_s == "activity")
				c.visible = v_ifactive;
			else if (fromstring(hidden_s, hidden_b))
				c.visible = hidden_b ? v_closed : v_yes;
		}
		while (s.next() == "user")
		{
			user& u = m_users.get_create(s.nextval());
			ser_enter(s)
			{
				s.item("name", u.override_name);
			}
		}
	}
	
	if (!m_server_base) { fatal("No server configured"); return; }
	if (!m_server_img) { fatal("No image server configured"); return; }
	
	if (!my_email) { fatal("No email address configured"); return; }
	if (!m_token) m_token = token_from_firefox(my_email);
	if (!m_token) { fatal("No token found"); return; }
	
	if (proxy_addr)
	{
		m_proxy.configure(proxy_addr, runloop::global());
		m_http_api.wrap_socks(bind_ptr(&socks5::connect, &m_proxy));
		m_http_img.wrap_socks(bind_ptr(&socks5::connect, &m_proxy));
		m_ws.wrap_socks(bind_ptr(&socks5::connect, &m_proxy));
	}
	
	if (emoji_fname)
	{
		m_emoji = discord_emoji::create(file::readall(file::resolve(file::exepath(), emoji_fname)), get_line_height());
		if (m_emoji->names().size() == 0)
			status("ERROR: Improper emoji library configured");
		else if (m_emoji->names().size() != 1832+3) // 1832 images + r/c/tm
			status("WARNING: Improper emoji library loaded, some messages may be misparsed");
	}
	else
	{
		m_emoji = discord_emoji::create(NULL, 0); // formatter needs an emoji handler, even if empty
		status("WARNING: No emoji library configured");
	}
	m_format = discord_format::create(m_emoji, bind_this(&discord::format_external), 0xCCCCCC);
	
	if (m_cachename)
	{
		array<byte> comp = file::readall(file::resolve(file::exepath(), m_cachename));
		
		size_t decomplen;
		void* decomp = tinfl_decompress_mem_to_heap(comp.ptr(), comp.size(), &decomplen, 0);
//puts(string(arrayview<byte>((uint8_t*)decomp, decomplen))); DEBUG_ONLY
		
		unsigned imgsize = 0;
		//jsondeerialize safely ignores its output if input is blank
		jsondeserialize(cstring(arrayview<byte>((uint8_t*)decomp, decomplen)), [this, &imgsize](jsondeserializer& s)
		//jsondeserialize(file::readall("/home/alcaro/Desktop/russian/e.log"), [this, &imgsize](jsondeserializer& s) DEBUG_ONLY
		{
			s.item("self", m_my_id);
			s.item("img-size", imgsize);
			// discord strongly recommends caching the gateway
			// it's unclear whether that's motivated by performance concerns on their end, or client performance;
			// considering some other things I've seen, I suspect former, but it does help both
			s.item("gateway", m_server_gateway);
			ser_enter(s, "users")
			{
				user& u = m_users.get_create(s.next());
				u.id = s.next();
				string avatar_b64;
				ser_enter(s)
				{
					s.item("name", u.name);
					s.item("avatar-addr", u.avatar_addr);
					s.item("avatar", avatar_b64);
				}
				if (avatar_b64) u.avatar_bytes = base64_dec(avatar_b64);
			}
			ser_enter(s, "guilds")
			{
				guild& g = guild_for(s.next());
				ser_enter(s)
				{
					s.item("name", g.name);
					ser_enter(s, "channels")
					{
						channel& c = channel_for(s.next(), g);
						bool hidden_b = true;
						ser_enter(s)
						{
							s.item("name", c.name);
							s.item("hidden", hidden_b);
							s.item("scrollback", c.scrollback);
							// in case the channel's last_message_id isn't the last message, i.e. reordered or deleted
							s.item("scrollbackend", c.last_fetched_msg);
						}
						if (!hidden_b && c.visible == v_no)
						{
							if (c.scrollback && c.scrollback[c.scrollback.size()-1].at < time(NULL)-3*86400)
								c.visible = v_ifactive;
							else
								c.visible = v_yes;
						}
					}
				}
			}
			ser_enter(s, "guildemoji")
			{
				guildemoji& ge = m_guildemoji.get_create(s.next());
				//status("Loaded guildemoji "+s.next());
				string b64;
				s.item_next(b64);
				ge.bytes = base64_dec(b64);
			}
		});
		free(decomp);
		
		m_gateway_good = (m_server_gateway != "");
		
		if (imgsize != bitround(get_line_height()))
		{
			for (user& u : m_users.values())
				u.avatar_bytes.reset();
			m_guildemoji.reset();
		}
		
		for (guild& g : m_guilds)
			guild_host(g);
		for (channel& c : m_channels)
		{
			if (c.parent == -1) continue; // happens if a channel is mentioned in config, but not in cache
			
			channel_host(c);
			
			span scspan[1] = { { "Loading scrollback..." } };
			c.host->message("scrollback", chanbase::imp_scrollback, time(NULL), scspan);
			for (message& m : c.scrollback)
			{
				if (!m.id) continue; // skip the 'last message seen' marker
				
				span fmt;
				if (m.is_highlight)
				{
					fmt.fgcol = 0xFF0000;
					fmt.bold = true;
				}
				array<span> spans;
				add_author(spans, fmt, m.author, c, m.id);
				fmt.bold = false;
				parse_format(spans, fmt, m.text, c, m.id);
				
				c.host->message_at("scrollback", false, m.id, chanbase::imp_scrollback, m.at, spans);
			}
		}
	}
	
#if FAKE_CONNECT
//ws_str(file::readall(file::exepath()+"dump.log"));
//ws_str(R"x({"t":"MESSAGE_CREATE","s":296,"op":0,"d":{"type":0,"tts":false,"timestamp":"2018-10-27T12:46:02.933000+00:00","pinned":false,"nonce":null,"mentions":[],"mention_roles":[],"mention_everyone":false,"member":{"roles":[],"nick":null,"mute":false,"joined_at":"2018-08-19T12:25:54.377773+00:00","deaf":false},"id":"505723855025733643","embeds":[],"edited_timestamp":null,"content":"my personal choice would be R\"\"C:\\temp\\derp.log\"\" and R\"delim\"C:\\temp\\derp.log\"delim\"","channel_id":"480711423681495047","author":{"username":"Alcaro","id":"188322172576464896","discriminator":"3261","avatar":"e3466274aa00038c9b27e3cb0b95dae5"},"attachments":[],"guild_id":"480711423681495041"}})x");
//ws_str(R"x({"t":"MESSAGE_CREATE","s":297,"op":0,"d":{"type":0,"tts":false,"timestamp":"2018-10-27T12:46:02.933000+00:00","pinned":false,"nonce":null,"mentions":[],"mention_roles":[],"mention_everyone":false,"member":{"roles":[],"nick":null,"mute":false,"joined_at":"2018-08-19T12:25:54.377773+00:00","deaf":false},"id":"505723855025733644","embeds":[],"edited_timestamp":null,"content":"my personal choice would be R\"\"C:\\temp\\derp.log\"\" and R\"delim\"C:\\temp\\derp.log\"delim\"","channel_id":"480711423681495047","author":{"username":"Alcaro","id":"188322172576464896","discriminator":"3261","avatar":"e3466274aa00038c9b27e3cb0b95dae5"},"attachments":[],"guild_id":"480711423681495041"}})x");
//ws_str(R"x({"t":"MESSAGE_CREATE","s":298,"op":0,"d":{"type":0,"tts":false,"timestamp":"2018-10-27T12:46:02.933000+00:00","pinned":false,"nonce":null,"mentions":[],"mention_roles":[],"mention_everyone":false,"member":{"roles":[],"nick":null,"mute":false,"joined_at":"2018-08-19T12:25:54.377773+00:00","deaf":false},"id":"505723855025733645","embeds":[],"edited_timestamp":null,"content":"my personal choice would be R\"\"C:\\temp\\derp.log\"\" and R\"delim\"C:\\temp\\derp.log\"delim\"","channel_id":"480711423681495047","author":{"username":"Alcaro","id":"188322172576464896","discriminator":"3261","avatar":"e3466274aa00038c9b27e3cb0b95dae5"},"attachments":[],"guild_id":"480711423681495041"}})x");
//ws_str(R"x({"t":"MESSAGE_CREATE","s":299,"op":0,"d":{"type":0,"tts":false,"timestamp":"2018-10-27T12:46:02.933000+00:00","pinned":false,"nonce":null,"mentions":[],"mention_roles":[],"mention_everyone":false,"member":{"roles":[],"nick":null,"mute":false,"joined_at":"2018-08-19T12:25:54.377773+00:00","deaf":false},"id":"505723855025733646","embeds":[],"edited_timestamp":null,"content":"my personal choice would be R\"\"C:\\temp\\derp.log\"\" and R\"delim\"C:\\temp\\derp.log\"delim\"","channel_id":"480711423681495047","author":{"id":"236588665420251137"},"attachments":[],"guild_id":"480711423681495041"}})x");
status("ERROR: Offline mode enabled");
return;
#endif
	
	if (rawlog_fname) m_rawlog.open(file::resolve(file::exepath(), rawlog_fname), file::m_replace);
	m_heartbeat_timer = runloop::global()->set_timer_loop(m_heartbeat_timer, m_heartbeat_interval, bind_this(&discord::heartbeat_cb));
	m_connect_state = cs_offline;
	connect();
}

void del_tmp()
{
	if (m_tmp_msg_in)
		m_tmp_msg_in->message_delete_true("tmp");
	m_tmp_msg_in = NULL;
}

void add_author(array<span>& spans, const span& fmt, snowflake id, channel& c, cstring msgid)
{
	if (m_enable_avatars)
	{
		user* u = m_users.get_or_null(id);
		if (!u) {} // nonexistent user? no avatar either
		else if (!u->avatar_addr) // no avatar? pick a random emoji (discord's default logos suck, ugly and too high collision ratio)
		{
			textview::image* img = m_emoji->pick_avatar(id.num());
			if (img)
			{
				spans.append(fmt).img = img;
				spans.append(fmt).text = " ";
			}
		}
		else if (!u->avatar_bytes && !msgid)
		{
			// this catches the temp message, if the current user's avatar isn't loaded
			// it gets deleted at random intervals and is dangerous to edit; better drop the avatar completely unless loaded
			// it'll get replaced in a second, and only happens once; the second time, the avatar is fetched
			// (and temp uses the hourglass emoji instead, so this check is pointless, but better keep it in case I put back avatar)
		}
		else // most common case, avatars enabled and user has one
		{
			if (!u->avatar_bytes)
			{
				if (!u->avatar_img)
					u->avatar_img = textview::image::blank(get_line_height());
				
				bool start = (m_avatar_unloaded.size() == 0);
				msgref& mr = m_avatar_unloaded.get_create(id).append();
				mr.chan = idx_for(c);
				mr.msg = msgid;
				
				if (start) do_fetch_avatar();
			}
			if (!u->avatar_img)
				u->avatar_img = textview::image::create(u->avatar_bytes, get_line_height());
			
			spans.append(fmt).img = u->avatar_img;
			spans.append(fmt).text = " ";
		}
	}
	
	// make sure to edit type!=0 handler in do_message if editing this, or making it non-last
	spans.append(fmt).text = "<"+username(id)+"> ";
}
void add_author(array<span>& spans, const span& fmt, const JSON& ju, channel& c, cstring msgid)
{
	username(ju); // record user's avatar
	add_author(spans, fmt, ju["id"].str(), c, msgid);
}

static time_t iso8601_to_unix(const char * stamp)
{
	struct tm tm;
	tm.tm_isdst = false;
	sscanf(stamp, "%d-%d-%dT%d:%d:%d", &tm.tm_year,&tm.tm_mon,&tm.tm_mday, &tm.tm_hour,&tm.tm_min,&tm.tm_sec);
	tm.tm_year -= 1900;
	tm.tm_mon -= 1;
	return timegm(&tm);
}

void http_api(HTTP::req r, function<void(HTTP::rsp)> callback = NULL)
{
	r.url = m_server_base + "/v6" + r.url;
	r.headers.append("Authorization: "+m_token);
	r.headers.append("User-Agent: " USER_AGENT);
	if (m_rawlog)
	{
		cstring method = (r.method ? r.method : r.body ? (cstring)"POST" : (cstring)"GET");
		m_rawlog.write(logdate()+" << "+method+" "+r.url+" "+cstring(r.body)+"\n");
	}
	m_http_api.send(r, callback);
}

//Call with URL fragments with leading slash but without /api/v6, like "/gateway".
void http_api(cstring url, function<void(HTTP::rsp)> callback = NULL)
{
	HTTP::req r(url);
	http_api(r, callback);
}
void http_api(cstring url, JSON& post, function<void(HTTP::rsp)> callback = NULL)
{
	HTTP::req r(url);
	r.body = post.serialize().bytes();
	http_api(r, callback);
}
void http_api(cstring method, cstring url, function<void(HTTP::rsp)> callback = NULL)
{
	HTTP::req r(url);
	r.method = method;
	http_api(r, callback);
}
void http_api(cstring method, cstring url, JSON& post, function<void(HTTP::rsp)> callback = NULL)
{
	HTTP::req r(url);
	r.method = method;
	r.body = post.serialize().bytes();
	http_api(r, callback);
}

void send_ws(const JSON& json)
{
	string msg = json.serialize();
	if (m_rawlog) m_rawlog.write(logdate()+" << "+msg+"\n");
	m_ws.send(msg);
}

void disconnect(bool resumable)
{
	status("Disconnected");
	if (m_rawlog) m_rawlog.write(logdate()+" ** Closing WebSocket\n");
	m_ws.reset();
	for (guild& g : m_guilds)
	{
		if (resumable) g.online_resume |= g.online;
		else g.online_resume = false;
		g.online = false;
	}
	if (!resumable) m_resume_token = "";
	rename_all();
	del_tmp();
	
	if (m_connect_state == cs_online)
	{
		m_connect_state = cs_offline;
		connect();
	}
	else
	{
		m_connect_state = cs_offline;
	}
}
void connect()
{
	if (m_connect_state != cs_offline) abort();
	
	if (!m_gateway_good)
	{
		http_api("/gateway", bind_lambda([this](HTTP::rsp r){
			JSON json(r.body);
			m_server_gateway = json["url"];
			if (m_connect_state == cs_get_gateway)
			{
				m_connect_state = cs_offline;
				if (m_server_gateway)
				{
					m_gateway_good = true;
					connect();
				}
				else
				{
					status("Couldn't find gateway address"); // and await timeout
				}
			}
		}));
		
		if (!m_server_gateway)
		{
			status("Locating gateway...");
			m_connect_state = cs_get_gateway;
			return;
		}
	}
	m_gateway_good = false;
	
	if (m_rawlog) m_rawlog.write(logdate()+" ** Connecting\n");
	status("Connecting to "+m_server_gateway+"...");
	
	m_heartbeat_sent = false;
	m_ws.callback(bind_this(&discord::ws_str), NULL); // compressed payloads are correctly labeled as binary, while json is text
	m_ws.callback(bind_this(&discord::ws_bin), NULL); // no other detection mechanism needed
	m_connect_state = cs_connecting;
	m_ws.connect(m_server_gateway+"?v=6&encoding=json"); // (perhaps sniffing isn't even possible, I didn't check how zlib header looks)
}

string logdate()
{
	time_t rawtime = time(NULL);
	struct tm * timeinfo = localtime(&rawtime);
	char out[64];
	strftime(out, 64, "[%H:%M:%S]", timeinfo);
	return out;
}

void do_fetch_scrollback()
{
#if FAKE_CONNECT
	return;
#endif
	//status("Fetching scrollback of "+channel_for(m_fetch_scrollback[0]).name+" ("+m_fetch_scrollback[0]+")");
	
	http_api("/channels/"+m_fetch_scrollback[0].str()+"/messages?limit=100", bind_lambda([this](HTTP::rsp r)
	{
		//with 'before' parameter: (untested)
		//with 'after' parameter:  (untested)
		//with 'around' parameter: (untested)
		//with none of the above:  messages show up NEWEST first
		channel& c = channel_for(m_fetch_scrollback.pop(0));
		
		if (m_rawlog) m_rawlog.write(logdate()+" >> HTTP "+cstring(r.body)+"\n");
		
		//rate limit is per channel, so doing this at full speed is safe
		//(could even do all in parallel, but no real point)
		if (m_fetch_scrollback) do_fetch_scrollback();
		
		c.last_fetched_msg = c.last_msg; // do this even if it fails, to avoid confusion later
		
		JSON json(r.body);
		if (json.type() != jsonparser::enter_list)
		{
			string whynot;
			if (r.status < 0) whynot = "network failure";
			else if (json.type() == jsonparser::enter_map) whynot = tostring(json["code"].num())+" "+json["message"].str();
			else whynot = cstring(r.body);
			// TODO: make this one clickable, click tries again
			span scspan[] = { { "[failed to load scrollback: " + whynot + "]" } };
			scspan[0].fgcol = 0xFF0000;
			c.host->message_at("scrollback", false, "scrollbackfail", chanbase::imp_scrollback, time(NULL), scspan);
			c.host->message_delete_true("scrollback");
			
			status("ERROR: Failed to fetch "+channel_name(c)+" scrollback: "+whynot);
			return;
		}
		
		snowflake endid;
		time_t endtime = 0;
		if (c.scrollback.size())
		{
			endid = c.scrollback[c.scrollback.size()-1].id.csplit<1>("-")[0];
			endtime = c.scrollback[c.scrollback.size()-1].at - 30;
		}
		
		bool found = false;
		for (int i=json.list().size()-1;i>=0;i--) // do this backwards, so log file and the new scrollback struct are ordered
		{
			if (found)
				do_message(json[i], false, true, false); // TODO: make the last one true if the message is older than lastread
			if (json[i]["id"].str() == endid)
				found = true;
		}
		
		if (!found && json) // either more than 100 messages, latest message was deleted, or empty list
		{
			set<string> seenids;
			for (message& m : c.scrollback)
				seenids.add(m.id);
			
			//do not keep everything in 'scrollback', scrollback is below the messages while we want this above
			//can't do it backwards, that'd make the textual log mess up
			span scspan[1] = { { "[incomplete scrollback]" } }; // TODO: make this one clickable, click fetches more
			scspan[0].fgcol = 0xC00000;
			time_t at = iso8601_to_unix(json[json.list().size()-1]["timestamp"].str());
			c.host->message_at("scrollback", false, "scrollbackfail", chanbase::imp_scrollback, at, scspan);
			
			bool found_old = false;
			bool do_print = false;
			for (int i=json.list().size()-1;i>=0;i--)
			{
				if (seenids.contains(json[i]["id"].str()))
					found_old = true;
				if (iso8601_to_unix(json[i]["timestamp"].str()) >= endtime)
					do_print = true;
				if (do_print)
					do_message(json[i], false, true, false);
			}
			if (found_old)
				c.host->message_delete_true("scrollbackfail");
		}
		
		c.host->message_delete_true("scrollback");
	}));
}

textview::image* img_error()
{
	if (!m_img_error)
	{
		arrayview<byte> svg = cstring(
			R"(<svg xmlns="http://www.w3.org/2000/svg" height="17" width="17">)"
				R"(<g fill="none" stroke-width="1" shape-rendering="crispEdges">)"
					R"(<path stroke="#888" d="M1.5,1.5h14v14h-14z"/>)"
					// don't merge these two paths, rsvg antialiasing is dumb
					// (or do merge once rsvg is less dumb - last tested on ubuntu 18.04, where it is dumb)
					//R"(<path stroke="#F00" d="M4,4l9,9M4,13l9,-9"/>)"
					R"(<g stroke="#F00">)"
						R"(<path d="M4,4l9,9"/>)"
						R"(<path d="M4,13l9,-9"/>)"
					R"(</g>)"
				R"(</g>)"
			R"(</svg>)"
		).bytes();
		m_img_error = textview::image::create(svg, get_line_height());
	}
	return m_img_error;
}

string avatar_url_for(user& u)
{
	// discord will only return power-of-two sizes, fetch smallest PoT greater than our line size
	return m_server_img+"/avatars/"+u.id.str()+"/"+u.avatar_addr+".png?size="+tostring(bitround(get_line_height()));
}
void do_fetch_avatar()
{
#if FAKE_CONNECT
	return;
#endif
	snowflake id = (*m_avatar_unloaded.begin()).key;
	user& u = m_users.get(id);
	
	HTTP::req r = avatar_url_for(u);
	if (m_rawlog) m_rawlog.write(logdate()+" << GET "+r.url+"\n");
	
	m_http_img.send(r, bind_lambda([this, id](HTTP::rsp r)
	{
		if (m_rawlog) m_rawlog.write(logdate()+" >> HTTP "+tostringhex(r.body.slice(0, min(r.body.size(), 16)))+
		                             "+"+tostring(r.body.size()-16)+"\n");
		
		user& u = m_users.get(id);
		
		//u.previmg can be NULL here if
		//- cache: user is known, but avatar_addr="1" isn't cached
		//- cache: user has talked, need to fetch avatar_addr="1"
		//- READY: user has avatar_addr="2", so current one should be NULLed
		//- fetch_avatar: fetched avatar_addr="1" - but user's avatar is no longer wanted
		
		//url can be wrong if
		//- cache: user is known, but avatar_addr="1" isn't cached
		//- cache: user has talked, need to fetch avatar_addr="1"
		//- READY: user has avatar_addr="2", so current one should be NULLed
		//- fetch_scrollback: user has talked, fetch avatar_addr="2"
		//- fetch_avatar: fetched avatar_addr="1"
		
		//both of these situations currently leave user with the 'loading...' avatar forever,
		// but the situation is rare, and will be fixed next time user talks, so good enough
		if (r.q.url == avatar_url_for(u))
		{
			u.avatar_bytes = std::move(r.body);
			
			if (u.avatar_img)
			{
				textview::image* previmg = u.avatar_img;
				textview::image* nextimg = textview::image::create(u.avatar_bytes, get_line_height());
				u.avatar_img = nextimg;
				
				if (!r.success() || !u.avatar_bytes || !nextimg)
				{
					if (nextimg) delete nextimg;
					u.avatar_bytes.reset();
					u.avatar_img = NULL;
					nextimg = img_error();
				}
				
				for (const msgref& mr : m_avatar_unloaded.get(id))
				{
					m_channels[mr.chan].host->message_replace_image(mr.msg, previmg, nextimg);
				}
				delete previmg;
			}
		}
		
		m_avatar_unloaded.remove(id);
		if (m_avatar_unloaded.size()) do_fetch_avatar();
	}));
}

void do_fetch_guildemoji()
{
#if FAKE_CONNECT
	return;
#endif
	snowflake id = (*m_guildemoji_unloaded.begin()).key;
	
	// discord will only return power-of-two sizes, fetch smallest PoT greater than our line size
	HTTP::req r = m_server_img+"/emojis/"+id.str()+".png?size="+tostring(bitround(get_line_height()));
	if (m_rawlog) m_rawlog.write(logdate()+" << GET "+r.url+"\n");
	
	m_http_img.send(r, bind_lambda([this, id](HTTP::rsp r)
	{
		guildemoji& ge = m_guildemoji.get(id);
		ge.bytes = std::move(r.body);
		textview::image* previmg = ge.img;
		textview::image* nextimg = textview::image::create(ge.bytes, get_line_height());
		ge.img = nextimg;
		if (!r.success() || !ge.bytes || !nextimg)
		{
			if (nextimg) delete nextimg;
			m_guildemoji.remove(id);
			nextimg = img_error();
		}
		
		for (const msgref& mr : m_guildemoji_unloaded.get(id))
		{
			if (!mr.msg) continue; // if the temp message contains an unknown emoji, just leave it blank, temp will get deleted soon enough
			m_channels[mr.chan].host->message_replace_image(mr.msg, previmg, nextimg);
		}
		delete previmg;
		
		m_guildemoji_unloaded.remove(id);
		if (m_guildemoji_unloaded.size()) do_fetch_guildemoji();
	}));
}

void do_message(JSON& jm, bool is_edit, bool is_scrollback = false, bool is_read = false)
{
	channel& c = channel_for(jm["channel_id"]);
	if (!c.host)
	{
		status("ERROR: Message to unknown channel "+jm.serialize());
		channel_host(c); // otherwise it probably crashes
	}
	
	// can happen if user links an image, and discord fetches and embeds it
	if (is_edit && !jm["content"]) return;
	
	bool highlight = false;
	for (const JSON& j : jm["mentions"].list())
	{
		username(j);
		if (j["id"].str() == m_my_id) highlight = true;
	}
	
	bool by_me = (jm["author"]["id"].str() == m_my_id);
	if (by_me) del_tmp();
	
	if (c.parent == 0 || highlight || c.visible == v_ifactive)
	{
		c.visible = v_yes;
		channel_host(c);
	}
	
	//there's a little too much code duplication in here, but add_author demands
	// to be called exactly once per displayed message, so it's hard to avoid
	
	chanbase::importance_t imp = (is_read   ? chanbase::imp_scrollback :
	                              by_me     ? chanbase::imp_none :
	                              highlight ? chanbase::imp_highlight :
	                                          chanbase::imp_msg);
	if (!is_edit)
	{
		if (c.last_fetched_msg == c.last_msg)
			c.last_fetched_msg = jm["id"];
		c.last_msg = jm["id"];
	}
	
	time_t at = iso8601_to_unix(jm["timestamp"].str());
	
	if (jm["content"] != "" || jm["attachments"].list().size() != 0)
	{
		array<span> spans;
		span fmt;
		if (highlight)
		{
			fmt.fgcol = 0xFF0000;
			fmt.bold = true;
		}
		add_author(spans, fmt, jm["author"], c, jm["id"]);
		size_t edit_span = spans.size();
		fmt.bold = false;
		parse_format(spans, fmt, jm["content"], c, jm["id"]);
		
		string plaintext = jm["content"];
		bool add_lf = (jm["content"] != "");
		for (const JSON& j : jm["attachments"].list())
		{
			if (add_lf) spans.append().text = "\n";
			if (add_lf) plaintext += "\n";
			add_lf = true;
			
			span& sp = spans.append();
			sp.text = j["url"];
			sp.hyperlink = true;
			
			//TODO: embed them
			//but only if filename does not start with SPOILER_
			
			plaintext += (cstring)j["url"];
		}
		
		if (is_edit)
		{
			c.setmsg(jm["id"], plaintext);
			c.host->message_edit(jm["id"], iso8601_to_unix(jm[/*"edited_"*/"timestamp"].str()), spans, edit_span);
		}
		else
		{
			c.nextmsg(jm["id"], jm["author"]["id"], plaintext, highlight, at);
			if (!is_scrollback)
				c.host->message(jm["id"], imp, at, spans);
			else
				c.host->message_at("scrollback", false, jm["id"], imp, at, spans);
		}
	}
	else if (jm["type"] != 0)
	{
		const char * msg_types[] = {
			NULL,
			"has joined the chat",
			"has left the chat",
			"started a call",
			NULL, // 4 CHANNEL_NAME_CHANGE
			NULL, // 5 CHANNEL_ICON_CHANGE - do channels even have icons?
			"", // "pinned a message to the channel", // ignored
			"has joined the guild",
		};
		size_t msg_type = jm["type"];
		const char * msg_text;
		if (msg_type < ARRAY_SIZE(msg_types) && msg_types[msg_type] != NULL)
		{
			if (!*msg_types[msg_type])
				return;
			msg_text = msg_types[msg_type];
		}
		else
		{
			msg_text = "UNKNOWN";
			status("WARNING: unknown message type: "+jm.serialize());
		}
		
		span fmt;
		fmt.italics = true;
		array<span> spans;
		add_author(spans, fmt, jm["author"], c, jm["id"]);
		spans[spans.size()-1].text = "* "+spans[spans.size()-1].text.substr(1, ~2)+" ";
		spans.append(fmt).text = msg_text;
		
		//can't edit a type!=0
		c.nextmsg(jm["id"], jm["author"]["id"], cstring("\\*\\*\\* _")+msg_text+"_", false, at);
		if (!is_scrollback)
			c.host->message(jm["id"], imp, at, spans);
		else
			c.host->message_at("scrollback", false, jm["id"], imp, at, spans);
	}
	else if (jm["embeds"])
	{
		// 99% of embeds are useless, and I wish I didn't need the last percent either, but some bots insist on that
		array<span> spans;
		add_author(spans, span(), jm["author"], c, jm["id"]);
		size_t edit_span = spans.size();
		
		string text = "";
		for (const JSON& j : jm["embeds"].list())
		{
			//if (j["type"] == "link" || j["type"] == "image" || j["type"] == "video") continue; // just ignore those
			//if (j["type"] == "gifv" || j["type"] == "article") continue;
			//if (j["url"].str().startswith("https://twitter.com/")) continue;
			
			if (j["author"]["id"])
			{
				status("WARNING: embed with author snowflake: "+j.serialize());
				//add_author(spans, fmt, j["author"], c, id);
			}
			if (j["title"])
			{
				if (j["url"])
				{
					spans.append().text = j["title"].str() + " | ";
					span& sp = spans.append();
					sp.text = j["url"];
					sp.hyperlink = true;
					spans.append().text = "\n";
					text += j["title"].str()+" | "+j["url"].str()+"\n";
				}
				else
				{
					span& sp = spans.append();
					sp.text = j["title"];
					spans.append().text = "\n";
					text += j["title"].str()+"\n";
				}
			}
			
			if (j["description"])
			{
				parse_format(spans, span(), j["description"], c, jm["id"]);
				spans.append().text = "\n";
				text += j["description"].str()+"\n";
			}
			for (const JSON& ji : j["fields"].list())
			{
				if (ji["name"])
				{
					text += ji["name"].str()+": ";
					parse_format(spans, span(), ji["name"], c, jm["id"]);
					spans.append().text = ": ";
				}
				parse_format(spans, span(), ji["value"], c, jm["id"]);
				spans.append().text = "\n";
				text += ji["value"].str()+"\n";
			}
			for (const JSON& ji : j["footer"].list())
			{
				parse_format(spans, span(), ji["text"], c, jm["id"]);
				spans.append().text = "\n";
				text += ji["text"].str()+"\n";
			}
			if (j["author"]["name"])
			{
				span& sp = spans.append();
				sp.text = "by "+j["author"]["name"].str();
				spans.append().text = "\n"; // don't merge with the above, the spans.remove() below won't like that
				text += sp.text+"\n";
			}
		}
		
		if (text)
		{
			spans.remove(spans.size()-1);
			text = text.substr(0, ~1);
		}
		else
		{
			status("WARNING: unknown embed: "+jm.serialize());
		}
		
		if (is_edit)
		{
			c.setmsg(jm["id"], jm["content"]);
			c.host->message_edit(jm["id"], iso8601_to_unix(jm[/*"edited_"*/"timestamp"].str()), spans, edit_span);
		}
		else
		{
			c.nextmsg(jm["id"], jm["author"]["id"], text, false, at);
			if (!is_scrollback)
				c.host->message(jm["id"], imp, at, spans);
			else
				c.host->message_at("scrollback", false, jm["id"], imp, at, spans);
		}
	}
	else
	{
		status("WARNING: empty message: "+jm.serialize());
	}
}

void load_chan(JSON& jc, guild& g)
{
	if (jc["type"] == 2 || jc["type"] == 4) return; // 0=channel, 1=private, 2=voice, 3=group-private 4=category
	
	channel& c = channel_for(jc["id"], g);
	c.used = true;
	c.name = (jc["type"] == 0 ? "#" : "") + jc["name"].str();
	
	if (idx_for(g) == 0)
	{
		//type 1=private, 3=group; nothing to filter out
		channel& c = channel_for(jc["id"], g);
		for (JSON& r : jc["recipients"].list())
			c.name = username(r);
		if (jc["type"] == 3)
		{
			if (jc["name"])
			{
				c.name = jc["name"];
			}
			else
			{
				array<cstring> names = jc["recipients"].list().select([this](const JSON& j)->cstring { return username(j); });
				if (names.size() == 0)
					c.name = "<empty groupchat>";
				//if size==1, c.name = username(r); above is good enough
				if (names.size() >= 2)
					c.name = names.slice(0, names.size()-1).join(", ") + ", and " + names[names.size()-1];
			}
		}
	}
	
	if (c.muted == m_dontknow && idx_for(g) != 0)
		c.muted = m_no;
	if (c.visible == v_no && c.muted == m_no)
		c.visible = v_yes;
	c.last_msg = jc["last_message_id"];
	channel_host(c);
	
	if (!c.scrollback)
	{
		// fetch messages in freshly created channels (or fresh application configs),
		// but mark scrollback as loaded so it won't retry if the channel is dead
		message& m = c.scrollback.append();
		m.id = "0"; // nonexistent id, so everything is shown
		m.at = 1420070400;        // discord epoch (jan 1, 2015), so it doesn't instantly hit the
		goto do_fetch_scrollback; //  'seeing messages older than latest, latest was probably deleted' check
	}
	if (c.last_msg != c.last_fetched_msg)
	{
	do_fetch_scrollback: ;
		if (c.visible >= v_ifactive || c.parent == 0)
		{
			if (!c.host->message_exists("scrollback"))
			{
				span scspan[1] = { { "Loading scrollback..." } };
				c.host->message("scrollback", chanbase::imp_scrollback, time(NULL), scspan);
			}
			m_fetch_scrollback.append(jc["id"]);
			if (m_fetch_scrollback.size() == 1) do_fetch_scrollback();
		}
		else
		{
			c.last_fetched_msg = c.last_msg;
			span scspan[1] = { { "[scrollback not loaded]" } }; // TODO: make this one clickable, click fetches more
			scspan[0].fgcol = 0xC00000;
			if (c.host->message_exists("scrollback"))
			{
				c.host->message_at("scrollback", false, "scrollbackfail", chanbase::imp_scrollback, time(NULL), scspan);
				c.host->message_delete_true("scrollback");
			}
			else
			{
				c.host->message("scrollbackfail", chanbase::imp_scrollback, time(NULL), scspan);
			}
		}
	}
	else
	{
		if (c.host->message_exists("scrollback"))
			c.host->message_delete_true("scrollback");
	}
}

void load_guild(JSON& jg)
{
	guild& g = guild_for(jg["id"]);
	g.exists = true;
	if (jg["unavailable"]) return;
	
	g.name = jg["name"];
	g.online = true;
	g.used = true;
	guild_host(g);
	
	for (JSON& jc : jg["channels"].list())
		load_chan(jc, g);
	
	for (JSON& u : jg["members"].list())
		username(u["user"]);
	for (JSON& p : jg["presences"].list())
		username(p["user"]);
}

void ws_str(cstring msg)
{
	if (m_rawlog) m_rawlog.write(logdate()+" >> "+msg+"\n");
	
	JSON json(msg);
	if (!json)
	{
		status(msg);
		fatal("Invalid JSON received!!!1");
		return;
	}
	
	if (json["op"]==0) // Dispatch
	{
		m_sequence = json["s"];
		if (json["t"] == "READY")
		{
			status("Connected");
			m_connect_state = cs_online;
			
			m_guilds[0].exists = true;
			m_guilds[0].online = true;
			m_my_id = json["d"]["user"]["id"];
			guild_host(m_guilds[0]);
			
			for (guild& g : m_guilds)
				g.online_resume = false;
			
			username(json["d"]["user"]);
			
			for (JSON& ujg : json["d"]["user_guild_settings"].list())
				for (JSON& ujc : ujg["channel_overrides"].list())
				{
					channel& c = channel_for(ujc["channel_id"]);
					c.muted = ujc["muted"] ? m_yes : m_no;
					//don't call channel_host; load_guild and load_chan does that, and channel name isn't known yet
				}
			
			for (JSON& r : json["d"]["relationships"].list())
				username(r["user"]);
			
			for (JSON& r : json["d"]["read_state"].list())
			{
				channel& c = channel_for(r["id"]);
				//c.last_read = r["last_message_id"];
				if (r["mention_count"] && c.parent != 0)
					c.visible = v_yes;
				//again, no channel_host
			}
			
			for (JSON& p : json["d"]["presences"].list())
				username(p["user"]);
			
			for (JSON& pc : json["d"]["private_channels"].list())
				load_chan(pc, m_guilds[0]);
			
			for (JSON& jg : json["d"]["guilds"].list())
				load_guild(jg);
			
			m_gateway_good = true;
			m_resume_token = json["d"]["session_id"];
		}
		if (json["t"] == "RESUMED")
		{
			status("Resumed");
			m_connect_state = cs_online;
			for (guild& g : m_guilds)
			{
				g.online = g.online_resume;
				g.online_resume = false;
			}
			rename_all();
			m_gateway_good = true;
		}
		if (json["t"] == "GUILD_CREATE")
		{
			load_guild(json["d"]);
		}
		if (json["t"] == "CHANNEL_CREATE")
		{
			cstring guild_id = json["d"]["guild_id"];
			if (guild_id) 
				load_chan(json["d"], guild_for(guild_id));
			else
				load_chan(json["d"], m_guilds[0]);
		}
		if (json["t"] == "MESSAGE_CREATE")
		{
			do_message(json["d"], false);
		}
		if (json["t"] == "MESSAGE_UPDATE")
		{
			do_message(json["d"], true);
		}
//note to self: possibly useful:
//{"t":"MESSAGE_ACK","s":553,"op":0,"d":{"message_id":"502919202479407104","channel_id":"161245277179609089"}}
		if (json["t"] == "MESSAGE_DELETE")
		{
			channel& c = channel_for(json["d"]["channel_id"]);
			c.host->message_delete(json["d"]["id"], time(NULL));
			c.setmsg(json["d"]["id"], "");
		}
		if (json["t"] == "MESSAGE_DELETE_BULK")
		{
			channel& c = channel_for(json["d"]["channel_id"]);
			for (JSON& m : json["d"]["ids"].list())
			{
				c.host->message_delete(m, time(NULL));
				c.setmsg(m["id"], "");
			}
		}
		//I'd love to disable PRESENCE_UPDATE, they account for ~25% of the websocket messages sent.
		//Or, for my bot, ~85%. Waste of bandwidth, on both sides.
	}
	if (json["op"]==1) // Heartbeat
	{
		JSONw json;
		json["op"] = 11; // Heartbeat ACK
		send_ws(json);
	}
	//if (json["op"]==2) // Identify (client only)
	//if (json["op"]==3) // Status Update (client only)
	//if (json["op"]==4) // Voice State Update (voice unsupported)
	//if (json["op"]==5) // Voice Server Ping (voice unsupported)
	//if (json["op"]==6) // Resume (client only)
	//if (json["op"]==7) // was Reconnect a while ago, but now undocumented; 7 hasn't been reused
	//if (json["op"]==8) // Request Guild Members (client only)
	if (json["op"]==9) // Invalid Session
	{
		if (m_connect_state == cs_connecting && m_resume_token)
		{
			m_connect_state = cs_connecting_retry;
			status("Resumption failed, logging in");
			// docs say wait 1-5 seconds before sending this - easier said than done with this architecture
			// the reason for that rule is probably to not create an infinite ping-pong loop;
			//   the state change fills the same purpose and is a lot easier to implement
			goto send_identify;
		}
		else
		{
			disconnect(json["d"]); // this reconnects if cs_online, else awaits timeout
		}
	}
	if (json["op"]==10) // Hello
	{
		guild_host(m_guilds[0]);
		
		m_heartbeat_interval = json["d"]["heartbeat_interval"];
		if (m_heartbeat_interval < 5000) m_heartbeat_interval = 5000;
		if (m_heartbeat_interval > 60000) m_heartbeat_interval = 60000;
		m_heartbeat_timer = runloop::global()->set_timer_loop(m_heartbeat_timer, m_heartbeat_interval, bind_this(&discord::heartbeat_cb));
		
		if (m_resume_token)
		{
			status("Resuming");
			
			JSONw json;
			json["op"] = 6; // Resume
			json["d"]["token"] = m_token;
			json["d"]["session_id"] = m_resume_token;
			json["d"]["seq"] = m_sequence;
			send_ws(json);
		}
		else
		{
			status("Logging in");
			
		send_identify: ;
			m_resume_token = "";
			m_sequence = 0;
			JSONw json;
			json["op"] = 2; // Identify
			json["d"]["token"] = m_token;
			json["d"]["compress"] = true;
			json["d"]["properties"]["os"] = "linux";
			json["d"]["properties"]["browser"] = USER_AGENT;
			json["d"]["properties"]["device"] = USER_AGENT;
			json["d"]["properties"]["referrer"] = "";
			json["d"]["properties"]["referring_domain"] = "";
			json["d"]["large_threshold"] = 50;
			send_ws(json);
		}
	}
	if (json["op"]==11) // Heartbeat ACK
	{
		m_heartbeat_sent = false;
	}
}

void ws_bin(arrayview<byte> msg)
{
	size_t decomplen;
	void* decomp = tinfl_decompress_mem_to_heap(msg.ptr(), msg.size(), &decomplen, TINFL_FLAG_PARSE_ZLIB_HEADER);
	
	if (decomp)
		ws_str(cstring(arrayview<byte>((uint8_t*)decomp, decomplen)));
	else
		fatal("Decompression failed!!!1");
	
	free(decomp);
}

void parse_format(array<span>& out, const span& fmt, cstring text, channel& c, cstring id)
{
	size_t n_in = out.size();
	
	m_current_msg_chan = idx_for(c);
	m_current_msg = id;
	m_format->parse(out, fmt, text);
	
	sanitize_spans(out, n_in);
}

void format_external(array<span>& out, const span& fmt, cstring content)
{
	span& sp = out.append(fmt);
	if (content[0] == ':' || content[0] == 'a') // guildemoji; ":thonk:379295935689392148", "a:extrathink:402609982882971654"
	{
		array<cstring> parts = content.csplit<2>(":");
		// ignore content[0], fetch unanimated only; gtktextview can't handle animated images
		cstring name = parts[1];
		snowflake id = parts[2];
		
		guildemoji& ge = m_guildemoji.get_create(id);
		if (!ge.bytes)
		{
			if (!ge.img)
				ge.img = textview::image::blank(get_line_height());
			
			bool start = (m_guildemoji_unloaded.size() == 0);
			msgref& mr = m_guildemoji_unloaded.get_create(id).append();
			mr.chan = m_current_msg_chan;
			mr.msg = m_current_msg;
			
			if (start) do_fetch_guildemoji();
		}
		if (!ge.img)
			ge.img = textview::image::create(ge.bytes, get_line_height());
		
		sp.img = ge.img;
		sp.text = ":"+name+":";
	}
	else
	{
		int typelen = isdigit(content[1]) ? 1 : 2;
		cstring type = content.substr(0, typelen);
		snowflake id = content.substr(typelen, ~0);
		
		if (type == "@" || type == "@!") // user, user (with nick)
		{
			user* u = m_users.get_or_null(id);
			if (!u) sp.text = "<@"+id.str()+">";
			else if (u->override_name) sp.text = "@"+u->override_name;
			else sp.text = "@"+u->name;
			
			if (!sp.is_spoiler())
				sp.fgcol = 0xC04000;
		}
		else if (type == "#") // channel
		{
			int ci = m_channel_index.get_or(id, -1);
			if (ci < 0)
			{
				sp.text = "#deleted-channel";
				return;
			}
			
			if (m_channels[ci].override_name) sp.text = m_channels[ci].override_name;
			else sp.text = m_channels[ci].name;
			
			if (sp.text[0] != '#')
				sp.text = "#"+sp.text;
			
			if (m_channels[ci].parent != 0 && !sp.is_spoiler())
				sp.fgcol = 0xC04000;
		}
		else if (type == "@&") // group
		{
			// TODO
			sp.text = "<@&"+id.str()+">";
		}
		else
		{
			abort(); // shouldn't happen
		}
	}
}

void heartbeat_cb()
{
	if (m_connect_state == cs_online && !m_heartbeat_sent)
	{
		m_heartbeat_sent = true;
		JSONw json;
		json["op"] = 1; // Heartbeat
		json["d"] = m_sequence;
		send_ws(json);
	}
	else if (m_connect_state == cs_offline || m_connect_state == cs_get_gateway)
	{
		m_connect_state = cs_offline;
		connect();
	}
	else
	{
		disconnect(true);
	}
	return;
}

void action(cstring text, uintptr_t userdata) override
{
	//TODO: more commands
	// /play, /listento, /watch
	// /back, /away, /dnd, /invis
	// (/ar, /1w - though they should be handled in some other way)
	
	russian::chanbase& at = *(userdata == (uintptr_t)-1 ? (russian::chanbase*)m_guilds[0].host
	                                                    : (russian::chanbase*)m_channels[userdata].host);
	
	if (LIKELY(text[0] != '/'))
	{
		send_message(userdata, m_format->unparse_irc(text));
		return;
	}
	if (text[0] == '/' && text[1] == '/')
	{
		send_message(userdata, m_format->unparse_irc(text.substr(1, ~0)));
		return;
	}
	
	array<cstring> parts = text.substr(1, ~0).csplit<1>(" ");
	cstring command = parts[0];
	cstring param = parts.size()==2 ? parts[1] : "";
	
	if(0);
	else if (command == "join")
	{
		array<channel*> matches;
		
		unsigned idx;
		if (fromstring(param, idx) && idx < m_channels.size() && m_channels[idx].parent != -1)
			matches.append(&m_channels[idx]);
		
		if (!matches)
		{
			for (channel& c : m_channels)
			{
				if (c.parent == -1) continue;
				if (channel_name(c).matches_globi(param+"*"))
					matches.append(&c);
			}
		}
		if (!matches)
		{
			for (channel& c : m_channels)
			{
				if (c.parent == -1) continue;
				if (channel_name(c).matches_globi("*"+param+"*"))
					matches.append(&c);
			}
		}
		
		if (matches.size() == 0)
		{
			span sp[1] = { { "No such channel" } };
			at.message(chanbase::imp_scrollback, time(NULL), sp);
		}
		else if (matches.size() == 1)
		{
			channel& c = *matches[0];
			c.visible = v_yes;
			channel_host(c);
			c.host->focus();
		}
		else
		{
			for (channel* cp : matches)
			{
				channel& c = *cp;
				
				string ago;
				if (c.scrollback.size() && c.scrollback[c.scrollback.size()-1].id)
				{
					int sec = (time(NULL) - c.scrollback[c.scrollback.size()-1].at);
					if(0);
					else if (sec < 3600) ago = tostring(sec/60)+" minutes ago";
					else if (sec < 86400) ago = tostring(sec/3600)+" hours ago";
					else ago = tostring(sec/86400)+" days ago";
				}
				else ago = "at never";
				
				string text = (string)"("+tostring(idx_for(c))+", "+guild_name(m_guilds[c.parent])+") "+
				                      channel_name(c)+", last activity "+ago;
				span sp[1] = { { text } };
				at.message(chanbase::imp_scrollback, time(NULL), sp);
			}
		}
	}
	else if (command == "part")
	{
		if (userdata==(uintptr_t)-1)
		{
			span sp[] = { { "* Can't leave the server tab" } };
			at.message(chanbase::imp_scrollback, time(NULL), sp);
			return;
		}
		if (param)
		{
			span sp[] = { { "* This command doesn't take arguments" } };
			at.message(chanbase::imp_scrollback, time(NULL), sp);
			return;
		}
		
		channel& c = m_channels[userdata];
		c.visible = v_closed;
		channel_host(c);
	}
	else if (command == "raw" || command == "md")
	{
		send_message(userdata, param);
	}
	else
	{
		span sp[1] = { { "* Unknown command" } };
		at.message(chanbase::imp_scrollback, time(NULL), sp);
	}
}

void send_message(uintptr_t id, cstring markdown)
{
	if (id == (uintptr_t)-1)
	{
		status("Can't talk in here");
		return;
	}
	send_message(m_channels[id], markdown);
}

void send_message(channel& c, cstring markdown)
{
	JSONw json;
	json["content"] = markdown; // if adding attachment support, make sure to increase timeouts
	json["nonce"] = tostring(time_us());
	HTTP::req r;
	r.method = "POST";
	r.url = "/channels/"+c.id.str()+"/messages";
	r.body = json.serialize().bytes();
	http_api(r, NULL);
	
	user* u = m_users.get_or_null(m_my_id);
	if (u)
	{
		del_tmp();
		span fmt;
		fmt.fgcol = 0x404040;
		array<span> spans;
		
		m_emoji->insert(spans, fmt, ":hourglass:"); // ignore failure, it always succeeds if given a valid emoji package
		spans.append().text = " <"+username(m_my_id)+"> ";
		
		parse_format(spans, fmt, markdown, c, "");
		c.host->message("tmp", chanbase::imp_scrollback, time(NULL), spans); // not really scrollback, but shouldn't be logged
		m_tmp_msg_in = c.host;
	}
}

void begin_private(cstring name) override {} // TODO

void close_chan(uintptr_t userdata) override
{
	if (userdata == (uintptr_t)-1) return;
	
	channel& c = m_channels[userdata];
	c.visible = (c.muted==m_no ? v_ifactive : v_closed);
	channel_host(c);
}

~discord()
{
#if FAKE_CONNECT
	return;
#endif
	
	bool any_guilds = false;
	string cache = jsonserialize([this, &any_guilds](jsonserializer& s)
	{
		s.item("self", m_my_id.str());
		s.item("img-size", bitround(get_line_height()));
		if (m_gateway_good)
			s.item("gateway", m_server_gateway);
		s.item("users", [this](jsonserializer& s)
		{
			for (auto& pair : m_users)
			{
				if (!pair.value.used) continue;
				s.item(pair.key.str(), [this, &pair](jsonserializer& s)
				{
					s.item("name", pair.value.name);
					s.item("avatar-addr", pair.value.avatar_addr);
					if (pair.value.avatar_img)
					{
						s.item("avatar", base64_enc(pair.value.avatar_bytes));
					}
				});
			}
		});
		s.item("guilds", [this, &any_guilds](jsonserializer& s)
		{
			for (guild& g : m_guilds)
			{
				if (!g.exists) continue;
				any_guilds = true;
				s.item(g.id.str(), [this, &g](jsonserializer& s)
				{
					if (g.id)
						s.item("name", g.name);
					s.item("channels", [this, &g](jsonserializer& s)
					{
						for (int id : g.channels)
						{
							channel& c = m_channels[id];
							if (g.used && !c.used) continue;
							s.item(c.id.str(), [this, &c](jsonserializer& s)
							{
								s.item("name", c.name);
								if (c.parent != 0)
								{
									if (c.muted != m_dontknow)
										s.item("hidden", c.muted == m_yes);
									else
										s.item("hidden", c.visible <= v_ifactive);
								}
								
								// could shrink this for muted channels, but having scrollback on freshly-reopened queries helps,
								// and other conditions for when to shrink it are complex
								size_t scrollsize = 100;
								if (c.scrollback.size() > scrollsize)
									c.scrollback = c.scrollback.slice(c.scrollback.size()-scrollsize, scrollsize);
								s.item("scrollback", c.scrollback);
								s.item("scrollbackend", c.last_fetched_msg.str());
							});
						}
					});
				});
			}
		});
		s.item("guildemoji", [this](jsonserializer& s)
		{
			for (auto& pair : m_guildemoji)
			{
				if (!pair.value.img) continue;
				s.item(pair.key.str(), base64_enc(pair.value.bytes));
			}
		});
	});
	
	if (m_cachename && any_guilds)
	{
		size_t complen;
		void* comp = tdefl_compress_mem_to_heap(cache.bytes().ptr(), cache.bytes().size(), &complen, TDEFL_DEFAULT_MAX_PROBES);
		
		file::writeall(file::resolve(file::exepath(), m_cachename), arrayview<byte>((uint8_t*)comp, complen));
		free(comp);
	}
	
	runloop::global()->remove(m_heartbeat_timer);
}
};
}
russian::protocol* russian::protocol::create_discord(impl* parent, bmldeserializer& s) { return new discord(parent, s); }

test("Discord timestamps", "", "")
{
	// needs to contain a 08 or 09 to ensure it's not octal
	assert_eq(discord::iso8601_to_unix("2018-10-25T08:45:09.245000+00:00"), 1540457109);
}
}
