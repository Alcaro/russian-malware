#if defined(__GNUC__) && (__GNUC__*10000 + __GNUC_MINOR__*100 + __GNUC_PATCHLEVEL__) < 40900
#define RE_BOOST
#include <boost/regex.hpp> // TODO: remove, 14.04 compat
#else
#include <regex> // include before arlib.h, <regex> doesn't like #define test()
#endif

#include "discord.h"

#ifdef RE_BOOST
#define std boost // good thing I'm not using any other part of std:: here... not even std::move...
#endif

namespace russian {

namespace {
static cstring make(const char * a, const char * b)
{
	return cstring(arrayview<byte>((uint8_t*)a, b-a));
}

class discord_format_impl : public discord_format {
public:
	//some regexes are from https://github.com/discordapp/simple-markdown, others were guessed, or tweaked to match discord
	//^s were replaced with std::regex_constants::match_continuous,
	// since apparently (unlike JS) ^ matches the start of any line, not just start of the string
	
	//equivalent to [\s\S] on utf8, matches one codepoint exactly
	//often not needed; for example, [\s\S]+ should not be replaced
	//\x00-\x7F\x80-\xBF instead of \x00-\xBF is because libstdc++ rejects that range; boost doesn't, I don't know which is wrong
	//(yes, this does dumb stuff on invalid utf8, but we'll never get invalid utf8 so who cares)
#define RE_U8_ANY R"((?:[\x00-\x7F\x80-\xBF]|[\xC0-\xDF].|[\xE0-\xEF]..|[\xF0-\xFF]...))"
	//equivalent to [\s\S] on utf16, but on a utf8 string
	//matches 1-3 bytes, or the first 3 bytes of a 4byte code unit; also matches continuations, so this one twice will match one U+1F4A9
#define RE_U16_ANY R"((?:[\x00-\x7F\x80-\xBF]|[\xC0-\xDF].|[\xE0-\xFF]..))"
	
#define RE_SPACE_CORE(x) "[" x " \f\n\r\t\v]|\xC2\xA0|\xE1\x9A\x80|\xE2\x80[\\x80-\\x8A]|" \
                         "\xE2\x80\xA8|\xE2\x80\xA9|\xE2\x80\xAF|\xE2\x81\x9F|\xE3\x80\x80|\xEF\xBB\xBF"
	
	//equivalent to \s, i.e. [ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]
#define RE_SPACE RE_SPACE_OR("")
	//equivalent to "[\s" chars "]"
#define RE_SPACE_OR(chars) "(?:" RE_SPACE_CORE(chars) ")"
	//equivalent to "[^\s" chars "]" (aka \S if no chars), as utf16 (RE_ANY_U16)
	//note that this one may not be repeated (+, ? and *); use (?: RE_U16_NOT_SPACE )+
	//RE_SPACE may be repeated
#define RE_U16_NOT_SPACE_OR(chars) RE_EXIST_NOT_SPACE_OR(chars) RE_U16_ANY
#define RE_U8_NOT_SPACE_OR(chars) RE_EXIST_NOT_SPACE_OR(chars) RE_U8_ANY
#define RE_EXIST_NOT_SPACE RE_EXIST_NOT_SPACE_OR("")
#define RE_EXIST_NOT_SPACE_OR(chars) "(?!" RE_SPACE_CORE(chars) ")"
	
	//this is heavily simplified from original's fence, ^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n *)+\n
	//for example, it doesn't need the trailing linebreak, making it more suitable for chatting
	std::regex re_fence{R"(```(?:[0-9a-zA-Z-]+\n)?\n*([\s\S]+?)\n*```)"};
	//without macros: \\([^0-9A-Za-z\s])
	std::regex re_escape{R"(\\()" RE_U8_NOT_SPACE_OR("0-9A-Za-z") ")"};
	std::regex re_autolink{R"(<([^ >]+:/[^ >]+)>)"}; // why is that called auto? and why is it using literal space, not \s?
	//original, ^(https?:\/\/[^\s<]+[^<.,:;"')\]\s]), doesn't have steam, and bans end-paren
	// (the escaped slashes are due to JS)
	//without macros: ((?:https?|steam)://[^\s<]+[^<.,:;"'\]\s])
	//yes, steam is needed, even though I don't render steam links; I want steam://foo**bar** to render as asterisks, not bold
	std::regex re_url{R"(((?:https?|steam)://(?:)" RE_U16_NOT_SPACE_OR("<") R"()+)" RE_U16_NOT_SPACE_OR("<.,:;\"'\\]") R"())"};
	std::regex re_strong{R"(\*\*([\s\S]+?)\*\*(?!\*))"};
	std::regex re_u{R"(__([\s\S]+?)__(?!_))"};
	//em is originally one big regex, split for performance reasons
	//the leading \b is a nop; the trailing is correct and non-nop, JS' definition of 'word character' is simply a-zA-Z0-9_
	std::regex re_em_u{R"(\b_((?:__|\\[\s\S]|[^\\_])+?)_\b)"};
	//this matches a slightly newer version than the above repo
	//https://github.com/Khan/simple-markdown/commit/867e85f5b716d010b20723a0f3751766ea585fd7#diff-9bd36ebd10de7fb38d6e24c64d4d1540L1205
	//they act slightly differently on, for example, e*e**e***e
	//without macros: ^\*(?=\S)((?:\*\*|\s+(?:[^\*\s]|\*\*)|[^\s\*])+?)\*(?!\*)
	std::regex re_em_ast{R"(\*)" RE_EXIST_NOT_SPACE R"(((?:\*\*|)" RE_SPACE R"(+(?:)"
	                  RE_U16_NOT_SPACE_OR("*") R"(|\*\*)|)" RE_U16_NOT_SPACE_OR("*") R"()+?)\*(?!\*))"};
	//original, (^~~(?=\S)([\s\S]*?\S)~~), is completely different
	//this one allows strikethrough of a space, and what's with the underscore?
	std::regex re_del{R"(~~([\s\S]+?)~~(?!_))"};
	//without macros: ((`+)\s*([\s\S]*?[^`])\s*\1(?!`)
	std::regex re_inlineCode{R"((`+))" RE_SPACE R"(*([\s\S]*?[^`]))" RE_SPACE R"(*\1(?!`))"};
	std::regex re_spoiler{R"(\|\|([\s\S]+?)\|\|)"};
	//original, ^[\s\S]+?(?=[^0-9A-Za-z\s\u00c0-\uffff]|\n\n| {2,}\n|\w+:\S|$), uses \u00c0-\uffff rather than \x80-\xBF\xC3-\xFF,
	// but that only works in utf16; we have to match utf8 byte values instead
	//no clue why it starts at c0 rather than 80, either, but we need to follow that so shrug and Â© are parsed properly
	// (original also rejects U+00A0 NO-BREAK SPACE, but nothing we're interested in uses that, so it's okay)
	std::regex re_text{R"([\s\S]+?(?=[^0-9A-Za-z\s\x80-\xBF\xC3-\xFF]|\n\n| {2,}\n|\w+:\S|$))"};
	
	//nonexistent emoji restart the parser after the initial colon
	// [^:]+ instead of [\w+-]+ would be fine, this is more a speedhack than anything else
	//nonexistent skin tones, like :ok_hand::skin-tone-8: and :poop::skin-tone-2:, aren't retried without the skin tone,
	// they just render as ":ok_hand::skin-tone-8:" and ":poop:[pink box]"
	std::regex re_emoji{R"((:[\w+-]+?(?:::skin-tone-\d)?:))"};
	//https://discordapp.com/developers/docs/reference#message-formatting
	//not sure if this is correct for emoji, hard to test when server censors my posts.
	//but on the other hand, it'll censor any situation where I'm inaccurate
	std::regex re_external{R"(<(@[&!]?\d+|#\d+|a?:\w+:\d+)>)"};
	
	discord_format_impl(discord_emoji* emoji,
	                    function<void(array<span>& out, const span& fmt, cstring content)> cb_external,
	                    uint32_t spoiler_col) :
	          emoji(emoji), cb_external(cb_external), spoiler_col(spoiler_col) {}
	
	discord_emoji* emoji;
	function<void(array<span>& out, const span& fmt, cstring content)> cb_external;
	uint32_t spoiler_col;
	
void recurse(array<span>& out, const span& fmt, const char * text, const char * textend)
{
	ssize_t nspan_in = out.size();
	while (true)
	{
	next: ;
		if (text == textend) break;
		
		std::cmatch m;
		switch ((uint8_t)*text)
		{
			case '*':
				if (std::regex_search(text, textend, m, re_em_ast, std::regex_constants::match_continuous))
				{
					span sub = fmt;
					sub.italics = true;
					recurse(out, sub, m[1].first, m[1].second);
					text = m[0].second;
					goto next;
				}
				if (std::regex_search(text, textend, m, re_strong, std::regex_constants::match_continuous))
				{
					span sub = fmt;
					sub.bold = true;
					recurse(out, sub, m[1].first, m[1].second);
					text = m[0].second;
					goto next;
				}
				break;
			
			case ':':
				if (std::regex_search(text, textend, m, re_emoji, std::regex_constants::match_continuous))
				{
					if (emoji->insert(out, fmt, make(m[1].first, m[1].second)))
					{
						text = m[0].second;
						goto next;
					}
				}
				break;
			
			case '<':
				if (std::regex_search(text, textend, m, re_autolink, std::regex_constants::match_continuous))
				{
					span& sp = out.append(fmt);
					sp.text = make(m[1].first, m[1].second);
					sp.hyperlink = (sp.text.istartswith("http://") || sp.text.istartswith("https://")); // yes, this is case insensitive
					text = m[0].second;
					goto next;
				}
				if (std::regex_search(text, textend, m, re_external, std::regex_constants::match_continuous))
				{
					cb_external(out, fmt, make(m[1].first, m[1].second));
					text = m[0].second;
					goto next;
				}
				break;
			
			case '@': // I have @here/@everyone muted, no reason to parse them
				break;  // their absense doesn't cause misparsing of anything else either, neither of them end with a prefix of http or steam
			
			case '\\':
				if (std::regex_search(text, textend, m, re_escape, std::regex_constants::match_continuous))
				{
					out.append(fmt).text = make(m[1].first, m[1].second);
					text = m[0].second;
					goto next;
				}
				break;
			
			case '_':
				if (std::regex_search(text, textend, m, re_em_u, std::regex_constants::match_continuous))
				{
					span sub = fmt;
					sub.italics = true;
					recurse(out, sub, m[1].first, m[1].second);
					text = m[0].second;
					goto next;
				}
				if (std::regex_search(text, textend, m, re_u, std::regex_constants::match_continuous))
				{
					span sub = fmt;
					sub.underline = true;
					recurse(out, sub, m[1].first, m[1].second);
					text = m[0].second;
					goto next;
				}
				break;
			
			case '`':
				if (std::regex_search(text, textend, m, re_fence, std::regex_constants::match_continuous))
				{
					bool has_lf = true;
					for (ssize_t i=out.size()-1;i>=nspan_in;i--)
					{
						cstring it = out[i].text;
						if (it)
						{
							has_lf = (it[it.length()-1] == '\n');
							break;
						}
					}
					if (!has_lf)
						out.append(fmt).text = "\n"; // simulate this one being a block-level element
					
					span& sp = out.append(fmt);
					sp.monospace = true;
					sp.text = make(m[1].first, m[1].second);
					text = m[0].second;
					
					if (text != textend)
						out.append(fmt).text = "\n"; // simulating block-level is simpler on this end
					
					goto next;
				}
				if (std::regex_search(text, textend, m, re_inlineCode, std::regex_constants::match_continuous))
				{
					span& sp = out.append(fmt);
					sp.monospace = true;
					sp.text = make(m[2].first, m[2].second);
					text = m[0].second;
					goto next;
				}
				break;
			
			case 'h': case 's':
				if (std::regex_search(text, textend, m, re_url, std::regex_constants::match_continuous))
				{
					span& sp = out.append(fmt);
					
					int nopen = 0;
					int nclose = 0;
					
					for (const char * iter = m[1].first; iter < m[1].second; iter++)
					{
						if (*iter == '(') nopen++;
						if (*iter == ')') nclose++;
						else nclose = 0; // yes, it's asymmetric
					}
					
					sp.text = make(m[1].first, m[1].second - (nclose>nopen ? 1 : 0));
					sp.hyperlink = (sp.text[0] == 'h');
					text = m[0].second - (nclose>nopen ? 1 : 0);
					goto next;
				}
				break;
			
			case '|':
				if (std::regex_search(text, textend, m, re_spoiler, std::regex_constants::match_continuous))
				{
					span sub = fmt;
					sub.fgcol = spoiler_col;
					sub.bgcol = spoiler_col;
					recurse(out, sub, m[1].first, m[1].second);
					text = m[0].second;
					goto next;
				}
				break;
			
			case '~':
				if (std::regex_search(text, textend, m, re_del, std::regex_constants::match_continuous))
				{
					span sub = fmt;
					sub.strike = true;
					recurse(out, sub, m[1].first, m[1].second);
					text = m[0].second;
					goto next;
				}
				break;
			
			static const char * const shrug = R"(Â¯\_(ã)_/Â¯)"; // no reason to make this a regex
			case 0xC2: // first half of Â¯ in utf8
				if ((size_t)(textend-text) >= strlen(shrug) && !memcmp(text, shrug, strlen(shrug)))
				{
					out.append(fmt).text = shrug;
					text += strlen(shrug);
					goto next;
				}
				break;
		}
		if (text == textend) break;
		
		std::regex_search(text, textend, m, re_text, std::regex_constants::match_continuous); // always matches
		text = m[0].second;
		
//puts("{{"+make(m[0].first, m[0].second)+"}}");
		string newtext_s = emoji->translate(make(m[0].first, m[0].second));
//puts("<<"+newtext_s+">>");
		const char * newtext = newtext_s;
		const char * newtextend = newtext + newtext_s.length();
		
		while (std::regex_search(newtext, newtextend, m, re_emoji)) // not match_continuous
		{
			out.append(fmt).text = make(newtext, m[0].first);
			if (emoji->insert(out, fmt, make(m[1].first, m[1].second)))
				newtext = m[0].second;
			else
			{
				out.append(fmt).text = ":";
				newtext = m[0].first+1;
			}
		}
//puts("[["+make(newtext, newtextend)+"]]");
		out.append(fmt).text = make(newtext, newtextend);
	}
}

void parse(array<span>& out, const span& fmt, cstring text) override
{
	string newtext = text.replace("\r\n","\n")
	                     .replace("\r","\n")
	                     .replace("\f","") // it discards form feed; commit message says it's supposed to become \n, but it's typoed
	                     .replace("\t","    "); // https://github.com/discordapp/simple-markdown/commit/6ee0e9c666
	
	recurse(out, fmt, (char*)newtext.bytes().ptr(), (char*)newtext.bytes().ptr() + newtext.length());
}

string unparse_irc(cstring in) override
{
	return in;
}
};
}


discord_format* discord_format::create(discord_emoji* emoji,
                                       function<void(array<span>& out, const span& fmt, cstring content)> cb_external,
                                       uint32_t spoiler_col)
{
	return new discord_format_impl(emoji, cb_external, spoiler_col);
}

#ifdef ARLIB_TEST
class discord_emoji_test : public discord_emoji {
public:
	bool insert(array<span>& out, const span& fmt, cstring name) const override
	{
		if (name == ":copyright:" || name == ":tm:")
		{
			out.append(fmt).text = (name[1]=='c' ? "Â©" : "â¢");
			return true;
		}
		
		if (name == ":snow2:" || name == ":skin-tone-3:" || name == ":snow2::skin-tone-3:" || name == ":danish:" || name == ":poop:")
		{
			span sp = { name };
			sp.fgcol = 2;
			out.append(sp);
			return true;
		}
		
		return false;
	}
	string translate(cstring in) const override
	{
		return in.replace("Ã¸Ã¸",":danish:").replace("â",":snow2:").replace("ð©",":poop:").replace("Â©",":copyright:").replace("â¢",":tm:");
	}
	// the tests don't need these, but interface does
	// tests act somewhat different from the primary usecase, so it's fine if things are a little inconvenient for the tests
	arrayview<cstring> names() const override { return NULL; }
	textview::image* pick_avatar(uint64_t seed) const override { return NULL; }
};

static void external_cb(array<span>& out, const span& fmt, cstring content)
{
	span sp = { content };
	sp.fgcol = 1;
	out.append(sp);
}
static discord_format* get_formatter()
{
	//cache this object, its constructor is slow under valgrind
	static discord_emoji_test emoji; // kinda silly to have an object with no members (except vtable), but interface needs that
	static discord_format_impl format(&emoji, bind_free(external_cb), 0x123);
	return &format;
}

static bool fmteq(span& a, span& b)
{
	if (a.fgcol != (uint32_t)-1)
		return a.fgcol == b.fgcol;
	
	if ((bool)a.img != (bool)b.img) return false;
	if (a.hidden != b.hidden) return false;
	if (a.bold != b.bold) return false;
	if (a.underline != b.underline) return false;
	if (a.italics != b.italics) return false;
	if (a.strike != b.strike) return false;
	if (a.monospace != b.monospace) return false;
	if (a.hyperlink != b.hyperlink) return false;
	if (a.fgcol != b.fgcol) return false;
	if (a.bgcol != b.bgcol) return false;
	return true;
}
static void flatten(array<span>& spans, bool drop_200b = false)
{
	//eat empty first, in case strikethrough emits identical spans with empty ones between
	for (size_t i=0;i<spans.size();i++)
	{
		if (drop_200b)
			spans[i].text.replace("\xE2\x80\x8B", "");
		if (spans[i].fgcol == 0x123) // wipe fgcol for spoilers, we only need bgcol
			spans[i].fgcol = (uint32_t)-1;
		if (spans[i].text == "") // keep this last, accessing spans[-1] doesn't help too much
			spans.remove(i--);
	}
	for (int i=0;i<(int)spans.size()-1;i++)
	{
		if (fmteq(spans[i],spans[i+1]) && spans[i].fgcol == (uint32_t)-1)
		{
			spans[i].text += spans[i+1].text;
			spans.remove(i+1);
			i--;
		}
	}
	for (size_t i=0;i<spans.size();i++)
	{
		spans[i].text = spans[i].text.replace("        \n","\n")
		                             .replace("    \n","\n")
		                             .replace("  \n","\n")
		                             .replace(" \n","\n");
	}
}
static string span_fmt(int idx, const span& sp)
{
	string ret;
	if (idx >= 0) ret += tostring(idx)+":";
	if (sp.fgcol != (uint32_t)-1) ret += "%"+tostring(sp.fgcol);
	else
	{
		if (sp.bold) ret += "%B";
		if (sp.italics) ret += "%I"; // alphabetical sorting is easy to remember, anything else would yield typoed tests
		if (sp.bgcol == 0x123) ret += "%H"; // even though it yields silly results, like link between bold and underline
		if (sp.hyperlink) ret += "%L";
		if (sp.monospace) ret += "%M";
		if (sp.strike) ret += "%S";
		if (sp.underline) ret += "%U";
	}
	return ret + sp.text;
}
static string spans_fmt(array<span>& spans)
{
	flatten(spans);
	return spans.select([](const span& sp)->string { return span_fmt(-1, sp); }).as_array().join("!");
}

static void test1f(cstring input, cstring expected)
{
	array<span> spans;
	get_formatter()->parse(spans, span(), input);
	for (span& sp : spans)
	{
		assert(sp.text.isutf8());
		assert(!sp.text.contains(string::nul()));
	}
	
	assert_eq(spans_fmt(spans), expected);
}

#define test1(input, expected) testcall(test1f(input, expected))
test("Discord formatting - preprocessor", "", "")
{
	test1("a\ta\r\nb\f\f\fc", "a    a\nbc");
}
test("Discord formatting - nesting", "", "")
{
	test1("b*c**ppp___p_p__pg***e", "b!%Ic!%B%Ippp!%B%I%U_p_p!%B%Ipg!e");
}
test("Discord formatting - underscores", "", "")
{
	test1("e_e__e___e", "e_e!%Ue_!e");
	test1("e__e_e___e", "e!%Ue!%I%Ue!e");
	test1("e_e___e__e", "e_e!%U_e!e");
	test1("e__e___e_e", "e!%Ue_!e_e");
	test1("e___e__e_e", "e!%U_e!e_e");
	test1("e___e_e__e", "e!%U_e_e!e");
	test1("____", "%I__");
	test1("___a__", "%U_a");
	test1("_ a_a", "_ a_a");
}
test("Discord formatting - asterisks", "", "")
{
	test1("e*e**e***e", "e!%Ie!%B%Ie!e");
	test1("e**e*e***e", "e!%Be!%B%Ie!e");
	test1("e*e***e**e", "e!%Ie**!e**e");
	test1("e**e***e*e", "e!%Be*!e*e");
	test1("e***e**e*e", "e!%B%Ie!%Ie!e");
	test1("e***e*e**e", "e!%I**e!e**e");
	test1("****", "%I**");
	test1("***a**", "%B*a");
	test1("a *aa **aaa***", "a !%Iaa !%B%Iaaa");
	test1("* a*", "* a*");
	test1("*a *", "*a *");
	test1("*a**\n****", "*a!%B\n**");
}
test("Discord formatting - tilde", "", "")
{
	test1("~~~~~~~~~~~~~~~~~~~~~", "%S~~~~!~");
	test1("~~ ~~", "%S ");
	test1("~~ ~~_", "~~ ~~_");
	test1("~~~a~~~", "%S~a!~");
}
test("Discord formatting - shrug", "", "")
{
	test1("Â¯\\_(ã)_/Â¯", "Â¯\\_(ã)_/Â¯");
	test1("Â¯\\_(ã)_/", "Â¯_(ã)_/");
	test1("\\Â¯\\_(ã)_/Â¯", "Â¯_(ã)_/Â¯");
	test1("_Â¯\\_(ã)_/Â¯_", "%IÂ¯_(ã)!/Â¯_");
	test1("Â¯\\_(ã)_/Â¯_", "Â¯\\_(ã)_/Â¯_");
	test1("\\Â¯\\_(ã)_/Â¯ _Â¯\\_(ã)_/Â¯_", "Â¯_(ã)!%I/Â¯ !Â¯\\_(ã)_/Â¯_");
	test1("aaaÂ¯\\_(ã)_/Â¯", "aaaÂ¯\\_(ã)_/Â¯");
}
test("Discord formatting - escapes", "", "")
{
	test1("\\a", "\\a");
	test1("\\:danish:", ":danish:");
	test1("\\\\:danish:", "\\!%2:danish:");
	test1("\\ ", "\\ ");
	test1("\\ð©", "ð©");
}
test("Discord formatting - textual emoji", "", "")
{
	test1(":snow2: :skin-tone-3: :snow2::skin-tone-3:", "%2:snow2:! !%2:skin-tone-3:! !%2:snow2::skin-tone-3:");
	test1(":danish: :danish::skin-tone-3:", "%2:danish:! :danish:!%2:skin-tone-3:");
	test1(":danish:danish: :aaaa:danish:", "%2:danish:!danish: :aaaa!%2:danish:");
	test1("**:danish:**:snow2:", "%2:danish:!%2:snow2:");
	test1(":snow2::skin-tone-3: :snow2::skin-tone-5: :snow2::skin-tone-42:",
	      "%2:snow2::skin-tone-3:! :snow2::skin-tone-5: !%2:snow2:!:skin-tone-42:");
	test1(":snow2::skin-tone-3:danish: :snow2::skin-tone-8:danish:",
	      "%2:snow2::skin-tone-3:!danish: :snow2::skin-tone-8!%2:danish:");
}
test("Discord formatting - mentions", "", "")
{
	test1("<@!123> <#123> <@&123> <@123 <@!123 <@&123 <#123 <@> <@!> <@&> <#>",
	      "%1@!123! !%1#123! !%1@&123! <@123 <@!123 <@&123 <#123 <@> <@!> <@&> <#>");
}
test("Discord formatting - custom emoji", "", "")
{
	test1("<:danish:123> <:danish:> <::123> <:danish:123 <a:danish:123> <a:danish:> <a::123> <a:danish:123",
	      "%1:danish:123! <!%2:danish:!> <::123> <!%2:danish:!123 !%1a:danish:123! <a!%2:danish:!> <a::123> <a!%2:danish:!123");
}
test("Discord formatting - Unicode emoji", "", "")
{
	test1("â:skin-tone-3:", "%2:snow2:!%2:skin-tone-3:");
	test1("Ã¸Ã¸ :Ã¸Ã¸: Ã¸Ã¸:/ Ã¸Ã¸Ã¸Ã¸Ã¸Ã¸Ã¸", "%2:danish:! :!%2:danish:!: !%2:danish:!:/ !%2:danish:!%2:danish:!%2:danish:!Ã¸");
	test1(":danishâ :aaaâ", "%2:danish:!snow2: :aaa!%2:snow2:");
	test1(":copyright: :snow2:copyright: :snow2Â© **:copyright: Â©** :copyright:snow2:", "Â© !%2:snow2:!copyright: :snow2Â© !%BÂ© Â©! Â©snow2:");
	test1(":tm: :snow2:tm: :snow2â¢ **:tm: â¢** :tm:snow2:", "â¢ !%2:snow2:!tm: !%2:snow2:!tm: !%Bâ¢ â¢! â¢snow2:");
	test1("Â©", "Â©");
}
test("Discord formatting - links", "", "")
{
	test1("<http://example.com> <https://example.com>", "%Lhttp://example.com! !%Lhttps://example.com");
	test1("<https://ex ample.com> <https:example.com>", "<!%Lhttps://ex! ample.com> <https:example.com>");
	test1("<HTTP://EXAMPLE.COM>", "%LHTTP://EXAMPLE.COM");
	test1("http://aaa(foo) (http://aaa) (http://aaa(foo))", "%Lhttp://aaa(foo)! (!%Lhttp://aaa!) (!%Lhttp://aaa(foo)!)");
	test1("http://aaa. http://aaa? http:// http://a http://ab", "%Lhttp://aaa!. !%Lhttp://aaa?! http:// http://a !%Lhttp://ab");
	test1("(http://a) http://â http://ð© aahttp://ggg", "(!%Lhttp://a!) http://!%2:snow2:! !%Lhttp://ð©! aa!%Lhttp://ggg");
}
test("Discord formatting - backticks", "", "")
{
	test1("````\nh```", "%M`\nh");
	test1("````\nh\n\n\n```", "%M`\nh");
	test1("``````\n`   `\n```", "%M```\n`   `");
	test1("```a\nb\n```", "%Mb");
	test1("```eee\n```", "%Meee");
	test1("```\n````", "%M`");
	test1("```\n```", "%M\n");
	test1("```rrr\n```hhh\n```", "%M```hhh");
	test1("```AsciiDoc\r\n210b aaa```", "%M210b aaa");
	test1("```C++\nint main()```", "%MC++\nint main()");
	test1("```AsciiDoc \n210b aaa```", "%MAsciiDoc\n210b aaa");
	test1("a```ee```", "a\n!%Mee");
	test1("```ee```a", "%Mee!\na");
	test1("```a``````a```", "%Ma!\n!%Ma");
	test1("```a```\n```a```", "%Ma!\n\n!%Ma");
	test1("a ` a ` a", "a !%Ma! a");
	test1("` `", "%M ");
	test1("`a`\n```a```", "%Ma!\n!%Ma");
	test1("```a```\n`a`", "%Ma!\n\n!%Ma"); // yes, this should have double linebreak
	test1("````a````", "%M`a!\n`");
}
test("Discord formatting - spoilers", "", "")
{
	test1("||aaa||", "%Haaa");
	test1("|| aaa ||", "%H aaa ");
	test1("aa || bb || cc", "aa !%H bb ! cc");
	test1("aa ||bb|| cc", "aa !%Hbb! cc");
	test1("aa|| bb ||cc", "aa!%H bb !cc");
	test1("aa||bb||cc", "aa!%Hbb!cc");
	test1("||||", "||||");
	test1("|||||", "%H|");
	test1("||||||||||||||||||||", "%H||||");
	test1("aa **||bb||** cc ||**dd**|| ee", "aa !%B%Hbb! cc !%B%Hdd! ee");
	
}
test("Discord formatting - weird spaces", "", "")
{
	//using U+1680 OGHAM SPACE MARK since it's visible (or unimplemented box in some fonts)
	test1("\\á", "\\á");
	test1("http://derpáderp", "%Lhttp://derp!áderp");
	test1("<http://derpáderp>", "%Lhttp://derpáderp");
	test1("*áa*", "*áa*");
	test1("*aá*", "*aá*");
	test1("`áá`", "%Má");
	test1("` á`", "%Má");
	test1("`  á`", "%Má");
	test1("aa\n\nbb", "aa\n\nbb"); // \n is whitespace too
}
#undef test1

static void irc_parse(array<span>& out, cstring irc)
{
	span next;
	
	size_t n=0;
	while (n<irc.length())
	{
		uint8_t ch = irc[n++];
		if (LIKELY(ch >= 32)) { next.text += ch; continue; }
		
		out.append(next);
		next.text = "";
		
		if(0);
		else if (ch == 0x02) next.bold ^= 1;
		else if (ch == 0x1D) next.italics ^= 1;
		else if (ch == 0x1F) next.underline ^= 1;
		else if (ch == 0x1E) next.strike ^= 1;
		else if (ch == 0x11) next.monospace ^= 1;
		else if (ch == 0x0F) next = span();
		else next.text += ch;
	}
	out.append(next);
}
static void test1u(cstring irc)
{
	array<span> expected;
	array<span> actual;
	irc_parse(expected, irc);
	get_formatter()->parse(actual, span(), get_formatter()->unparse_irc(irc));
	
	assert_eq(spans_fmt(actual), spans_fmt(expected));
}

#define test1(irc) testcall(test1u(irc))
test("Discord unformatting", "", "")
{
	test1("aabb");
	test1("aa\x02zb");
	test1("aa\x02z\x02z");
	test1("aa\x02z**b\x02y");
	test1("xx\x02z\x1Fyy");
	test1("xx\x02z\x1Fyy");
	test1("xx\x02z\x1Fy\x02yw\x1Fww");
	test1("xx\x02z\x1Fy\x02y\x02w\x1Fw\x02w");
	test1("\x11`````````");
	
	const char * tokens[] = { "*", "_", "~~", "`", "**", "__", "http://", "<", ">", "||",
	                          " ", "x", "1", " ", "aaaaa", "123", "\n", "eee", "42",
	                          "\x02", "\x0F", "\x11", "\x1D", "\x1E", "\x1F",
	                        };
	
	for (int i=0;i<1000;i++)
	{
		random_t rand;
		rand.seed(i);
		string test;
		for (int j=0;j<100;j++)
			test += tokens[rand()%ARRAY_SIZE(tokens)];
		test1(test);
	}
	
	assert(!get_formatter()->unparse_irc("@here").contains("@here")); // ->parse ignores this, so must test separately
	assert(!get_formatter()->unparse_irc("@everyone").contains("@everyone"));
}
#endif
}
