// Design goal: Every supported formatting instruction must be parsed the same way as the official web client.
// This applies even in the presense of unsupported formatting instructions, such as @everyone or clickable steam:// links, and
//    for unrealistic inputs, such as steam://foo**bar**. It applies even to inputs that the mobile clients parse differently.
// However, presentation doesn't need to be the same, or even allow differentiating all formatting the official one does.
//    For example, it's not required to make `foo` distinct from ```foo```, or @everyone from \@everyone.
// I believe this goal is achieved. However, while everything is parsed correctly,
//    some things (most notably [text](http://example.com/) from webhooks) aren't rendered usefully.

#include "discord.h"

namespace russian {

namespace {
static cstring make(const char * a, const char * b)
{
	return cstring(arrayview<char>(a, b-a));
}

//Input must start with http:// or https://.
//Output will be same as input, except if the domain name contains non-ascii, in which case it will be percent encoded.
static string sanitize_link(cstring str)
{
	string ret;
	size_t slashes = 0;
	for (uint8_t ch : str.bytes())
	{
		if (ch == '/')
			slashes++;
		if (slashes < 3 && (ch < 0x20 || ch >= 0x80))
			ret += "%"+tostringhex<2>(ch);
		else
			ret += ch;
	}
	return ret;
}

class discord_format_impl : public discord_format {
public:
	discord_format_impl(discord_emoji* emoji,
	                    function<void(array<span>& out, const span& fmt, cstring content)> cb_external,
	                    uint32_t spoiler_col) :
	          emoji(emoji), cb_external(cb_external), spoiler_col(spoiler_col) {}
	
	discord_emoji* emoji;
	function<void(array<span>& out, const span& fmt, cstring content)> cb_external;
	uint32_t spoiler_col;
	
	// These are only valid while parsing something. It's annoying to pass them around everywhere.
	mutable span root_fmt;
	mutable source_t source;
	mutable cstring last_match;
	
	static bool can_precede_quote(cstring last_match)
	{
		const uint8_t * start = last_match.bytes().ptr();
		const uint8_t * at = start + last_match.length();
		while (at > start && at[-1] == ' ') at--;
		return (at > start && at[-1] == '\n');
	}
	
	//Appends to 'out'. If 'in' starts with a block boundary, does not add \n to out, even if out initially ends with non-linebreak.
	//Mangles 'in'.
	static void flatten_blocks(array<span>& out, arrayvieww<span> in)
	{
		size_t outstart = out.size();
		for (size_t n=0;n<in.size();n++)
		{
			if (!in[n].text) continue; // discard blank outputs, so it's easy to find the last character
			if ((in[n].text[0]^0x80) < 0x40) // starts with a utf8 continuation byte -> append to previous
			{
				out[out.size()-1].text += in[n].text;
				continue;
			}
			if (in[n].text == "\r") // every \r is known to be a block boundary; \r in input is preprocessed to \n
			{
				if (out.size() == outstart) // block boundary at start
					continue;
				if (n == in.size()-1) // block boundary at end
					continue;
				if (in[n+1].text == "\r") // next one is a block (if in ends with two block boundaries, shouldn't be \n)
					continue;
				if (out[out.size()-1].text.endswith("\n")) // block boundary after linebreak
					continue;
				in[n].text = "\n"; // don't just append a new \n, we want to preserve formatting
			}
			out.append(std::move(in[n]));
		}
	}
	
void recurse(array<span>& out, bool in_quote, const span& fmt, cstring text) const
{
	recurse(out, in_quote, fmt, (char*)text.bytes().ptr(), (char*)text.bytes().ptr() + text.length());
}
#define NEXT(m) do { last_match = m[0].str(); text = m[0].end; goto next; } while(0)
#define MATCH(re) (m = re.match(text, textend))
#define MATCH2(re) (m2 = re.match(text, textend))
void recurse(array<span>& out, bool in_quote, const span& fmt, const char * text, const char * textend) const
{
	//most of these are from https://github.com/Khan/simple-markdown/blob/master/simple-markdown.js, others were guessed
	//^s were replaced with using REGEX().match, rather than .search
	
	//equivalent to [^] on utf8, matches one codepoint exactly
	//often not needed; for example, [^]+ should not be replaced
	//(yes, this does dumb stuff on invalid utf8, but we'll never get invalid utf8 so who cares)
#define RE_U8_ANY "(?:[\x00-\xBF]|[\xC0-\xDF][^]|[\xE0-\xEF][^][^]|[\xF0-\xFF][^][^][^])"
	//equivalent to [^] on utf16, but on a utf8 string
	//matches 1-3 bytes, or the first 3 bytes of a 4byte code unit; also matches continuations, so this one twice will match one U+1F4A9
#define RE_U16_ANY "(?:[\x00-\xBF]|[\xC0-\xDF][^]|[\xE0-\xFF][^][^])"
	
#define RE_SP_CORE(x) "[" x " \f\n\r\t\v]|\xC2\xA0|\xE1\x9A\x80|\xE2\x80[\x80-\x8A\xA8\xA9\xAF]|\xE2\x81\x9F|\xE3\x80\x80|\xEF\xBB\xBF"
	
	//equivalent to \s, i.e. [ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]
#define RE_SPACE "(?:" RE_SP_CORE("") ")"
	//matches any byte except the argument, as long as a Unicode space doesn't start there; should be preferred over U8/16 in most cases
	//remember to use "\\\\" or R"(\\)" to exclude backslash; "\\" will just escape the next character, with undesirable results
#define RE_B_NOT_SPACE_OR(chars) "(?:(?!" RE_SP_CORE(chars) ")[^])"
	//matches any utf8 codepoint except spaces and the argument
#define RE_U8_NOT_SPACE_OR(chars) "(?:(?!" RE_SP_CORE(chars) ")" RE_U8_ANY ")"
#define RE_U16_NOT_SPACE_OR(chars) "(?:(?!" RE_SP_CORE(chars) ")" RE_U16_ANY ")"
	
	//this is heavily simplified from original's fence, ^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n *)+\n
	//for example, it doesn't need the trailing linebreak, making it more suitable for chatting
	auto re_fence = REGEX(R"(```(?:[-.+\w]+\n)?\n*([^\n][^]*?)\n*```)");
	//without macros: \\([^0-9A-Za-z\s])
	auto re_escape = REGEX(R"(\\()" RE_U16_NOT_SPACE_OR("0-9A-Za-z") ")"); // use u16 here, to ensure fragments parse correctly
	auto re_autolink = REGEX(R"(<([^: >]+:/[^ >]+)>)"); // why is it called auto?
	//original, ^(https?:\/\/[^\s<]+[^<.,:;"')\]\s]), doesn't have steam, and bans end-paren
	// (the escaped slashes are due to JS)
	//without macros: ((?:https?|steam)://[^\s<]+[^<.,:;"'\]\s])
	//yes, steam is needed, even though I don't render steam links; I want steam://foo**bar** to render as asterisks, not bold
	auto re_url = REGEX("(?:https?|steam)://" RE_U16_NOT_SPACE_OR("<") "+" RE_U16_NOT_SPACE_OR("<.,:;\"'\\]"));
	auto re_strong = REGEX(R"(\*\*((?:\\[^]|[^\\])+?)\*\*(?!\*))");
	auto re_u = REGEX(R"(__((?:\\[^]|[^\\])+?)__(?!_))");
	//em is originally one big regex, split for performance reasons
	//the leading \b is a nop and a bug; the trailing is correct and non-nop, JS' definition of 'word character' is simply a-zA-Z0-9_
	auto re_em_u = REGEX(R"(\b_((?:__|\\[^]|[^\\_])+?)_\b)");
	//without macros: \*(?=\S)((?:\*\*|\\[^]|\s+(?:\\[^]|[^\s\*\\]|\*\*)|[^\s\*\\])+?)\*(?!\*)
	//except we're using a simplified but equivalent version: \*(?=\S)((?:\s*(?:\*\*|\\[^]|[^\s\*\\]))+?)\*(?!\*)
	auto re_em_ast = REGEX(R"(\*(?=)" RE_B_NOT_SPACE_OR("") R"()((?:)" RE_SPACE R"(*(?:\*\*|\\[^]|)"
	                       RE_B_NOT_SPACE_OR("*\\\\") R"())+?)\*(?!\*))");
	//original, (^~~(?=\S)([\s\S]*?\S)~~), is completely different
	//this one allows strikethrough of a space, and what's with the underscore?
	auto re_del = REGEX(R"(~~([^]+?)~~(?!_))");
	auto re_inlineCode = REGEX(R"((`+)([^]*?[^`])\1(?!`))");
	auto re_inlineCode_replace = REGEX(R"( (?= *`)|(` *) )");
	//seems like the newer regexes prefer space to \s
	auto re_spoiler = REGEX(R"(\|\|([^]+?)\|\|)");
	auto re_linequote = REGEX(R"(( *> [^\n]*\n?)+)");
	auto re_linequote_replace = REGEX(R"((^|\n) *> )");
	auto re_blockquote = REGEX(R"( *>>> [^]*)");
	
	//nonexistent emoji restart the parser after the initial colon
	// [^:]+ instead of [\w+-]+ would be fine, this is more a speedhack than anything else
	//nonexistent skin tones, like :ok_hand::skin-tone-8: and :poop::skin-tone-2:, aren't retried without the skin tone,
	// they just render as ":ok_hand::skin-tone-8:" and ":poop:[pink box]"
	auto re_emoji = REGEX(R"(:[-+\w]+:(?::skin-tone-\d:)?)");
	//https://discordapp.com/developers/docs/reference#message-formatting
	auto re_highlight = REGEX(R"(<(@[&!]?\d+|#\d+)>)");
	//not sure if this is correct, hard to test when server censors my posts
	//but on the other hand, it'll censor any situation where I'm inaccurate
	auto re_ext_emoji = REGEX(R"(<(a?:\w+:\d+)>)");
	auto re_everyone = REGEX(R"(@here|@everyone)");
	
	//without macros: \[((?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*)\]\(\s*<?((?:[^\s\\]|\\.)*?)>?(?:\s+['\"]([^]*?)['"])?\s*\)
	//TODO: add \([^)]*\)| after <?((?: once discord updates
	auto re_link = REGEX(R"(\[((?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*)\]\()" RE_SPACE R"(*<?((?:)" RE_B_NOT_SPACE_OR("\\\\")
	                     R"(|\\.)*?)>?(?:)" RE_SPACE R"(+['\"]([^]*?)['"])?)" RE_SPACE R"(*\))");
	
	//original, ^[\s\S]+?(?=[^0-9A-Za-z\s\u00c0-\uffff]|\n\n| {2,}\n|\w+:\S|$), uses \u00c0-\uffff rather than \x80-\xBF\xC3-\xFF,
	// but that only works in utf16; we have to match utf8 byte values instead
	//no clue why it starts at c0 rather than 80, either, but we need to follow that so shrug and Â© are parsed properly
	// (original also rejects U+00A0 NO-BREAK SPACE, but nothing we're interested in uses that, so it's okay)
	// (linequotes are close, but they use literal space, not \s)
	auto re_text = REGEX(R"(^[^]+?(?=[^0-9A-Za-z\s\x80-\xBF\xC3-\xFF]|\n\n| {2,}\n|\w+:\S|$))");
	
	// I could put those REGEX objects near their use, but they need fairly frequent updates (upstream keeps moving), so better not.
	// (And re_emoji is used twice.)
	
	// Formatting types:
	// - Webhook: Enable everything
	// - Embed body: Alias of webhook
	// - Normal: Disable re_link
	// - Topic: Disable re_link, re_linequote, re_blockquote, re_inlineCode, and re_fence
	// - Embed title: Disable re_link, re_fence, re_highlight, and re_everyone (this is why re_ext_emoji and re_highlight are separate)
	
	regex::match_t<5> m;
	regex::match_t<5> m2;
	
	while (true)
	{
	next: ;
		if (text == textend) break;
		
		switch ((uint8_t)*text)
		{
			case '*':
				MATCH(re_em_ast);
				MATCH2(re_strong);
				if (m && (!m2 || m[0].end >= m2[0].end)) // if both match, longest one wins
				{
					span sub = fmt;
					sub.italics = true;
					recurse(out, in_quote, sub, m[1].str());
					NEXT(m);
				}
				if (m2)
				{
					span sub = fmt;
					sub.bold = true;
					recurse(out, in_quote, sub, m2[1].str());
					NEXT(m2);
				}
				break;
			
			case ':':
				if (MATCH(re_emoji) && emoji->insert(out, fmt, m[0].str()))
					NEXT(m);
				break;
			
			case '<':
				if (MATCH(re_autolink))
				{
					span& sp = out.append(fmt);
					sp.text = m[1].str();
					sp.hyperlink = (sp.text.istartswith("http://") || sp.text.istartswith("https://")); // yes, this is case insensitive
					if (sp.hyperlink)
						sp.text = sanitize_link(std::move(sp.text));
					NEXT(m);
				}
				if (MATCH(re_ext_emoji) || (source != embed_title && MATCH(re_highlight)))
				{
					cb_external(out, fmt, m[1].str());
					NEXT(m);
				}
				break;
			
			case ' ':
			case '>':
			{
				bool can_quote = (!in_quote && can_precede_quote(last_match) && source != topic);
				
				bool is_line;
				if (can_quote && MATCH(re_linequote))
				{
					is_line = true;
					goto quote_common;
				}
				if (can_quote && MATCH(re_blockquote))
				{
					is_line = false;
				quote_common:
					out.append(fmt).text = "\r";
					
					string content;
					if (is_line)
					{
						content = re_linequote_replace.replace(m[0].str(), "\\1");
					}
					else
					{
						size_t skip = 0;
						while (m[0].start[skip] == ' ') skip++;
						skip += strlen(">>> ");
						content = make(m[0].start + skip, m[0].end);
					}
					
					array<span> qspans;
					recurse(qspans, true, fmt, content);
					
					// last_match points into a local variable, replace it before it's deallocated
					last_match = can_precede_quote(last_match) ? "\n" : "";
					
					size_t outstart = out.size();
					if (qspans.size() && qspans[qspans.size()-1].text.endswith("\n"))
					{
						qspans[qspans.size()-1].text = qspans[qspans.size()-1].text.substr(0, ~1);
					}
					out.append(root_fmt).text = "> "; // TODO: decide on a better formatting
					flatten_blocks(out, qspans);
					for (size_t i=outstart;i<out.size();i++)
					{
						size_t pos = out[i].text.indexof("\n");
						if (pos != (size_t)-1)
						{
							out.insert(i+1, span()).text = "> ";
							span tmp = out[i]; // don't inline into the below, inserting invalidates the reference out[i]
							out.insert(i+2, std::move(tmp));
							out[i].text = out[i].text.substr(0, pos+1);
							out[i+2].text = out[i+2].text.substr(pos+1, ~0);
						}
					}
					
					out.append(fmt).text = "\r";
					NEXT(m);
				}
				break;
			}
			
			case '@': // @here/@everyone should render as plaintext
				// but they must be parsed, so things like @here U+200D U+1F4A9 (zero width joiner, poop) parse correctly
				if (source != embed_title && MATCH(re_everyone))
				{
					out.append(fmt).text = m[0].str();
					NEXT(m);
				}
				break;
			
			case '[':
				if (source == webhook && MATCH(re_link))
				{
					// TODO: this presentation sucks
					
					out.append(fmt).text = "[";
					recurse(out, in_quote, fmt, m[1].str());
					out.append(fmt).text = "](";
					
					span& sp = out.append(fmt);
					sp.text = m[2].str();
					sp.hyperlink = (sp.text.istartswith("http://") || sp.text.istartswith("https://"));
					if (sp.hyperlink)
						sp.text = sanitize_link(std::move(sp.text));
					out.append(fmt).text = ")";
					
					NEXT(m);
				}
				break;
			
			case '\\':
				if (MATCH(re_escape))
				{
					out.append(fmt).text = m[1].str();
					NEXT(m);
				}
				break;
			
			case '_':
				MATCH(re_em_u);
				MATCH2(re_u);
				if (m && (!m2 || m[0].end >= m2[0].end))
				{
					span sub = fmt;
					sub.italics = true;
					recurse(out, in_quote, sub, m[1].str());
					NEXT(m);
				}
				else if (m2)
				{
					span sub = fmt;
					sub.underline = true;
					recurse(out, in_quote, sub, m2[1].str());
					NEXT(m2);
				}
				break;
			
			case '`':
				if (source != topic && source != embed_title && MATCH(re_fence))
				{
					out.append(fmt).text = "\r";
					
					span& sp = out.append(fmt);
					sp.monospace = true;
					cstring body = m[1].str();
					sp.text = body;
					
					out.append(fmt).text = "\r";
					NEXT(m);
				}
				if (source != topic && MATCH(re_inlineCode))
				{
					string newcontent = re_inlineCode_replace.replace(m[2].str(), "\\1");
					
					span& sp = out.append(fmt);
					sp.monospace = true;
					sp.text = newcontent;
					NEXT(m);
				}
				break;
			
			case 'h': case 's':
				if (MATCH(re_url))
				{
					span& sp = out.append(fmt);
					
					int nopen = 0;
					int nclose = 0;
					for (const char * iter = m[0].start; iter < m[0].end; iter++)
					{
						if (*iter == '(') nopen++;
						if (*iter == ')') nclose++;
						else nclose = 0; // yes, it's asymmetric
					}
					if (nclose > nopen) m[0].end--;
					
					sp.text = make(m[0].start, m[0].end);
					sp.hyperlink = (sp.text[0] == 'h');
					if (sp.hyperlink)
						sp.text = sanitize_link(std::move(sp.text));
					NEXT(m);
				}
				break;
			
			case '|':
				if (MATCH(re_spoiler))
				{
					span sub = fmt;
					sub.fgcol = spoiler_col;
					sub.bgcol = spoiler_col;
					recurse(out, in_quote, sub, m[1].str());
					NEXT(m);
				}
				break;
			
			case '~':
				if (MATCH(re_del))
				{
					span sub = fmt;
					sub.strike = true;
					recurse(out, in_quote, sub, m[1].str());
					NEXT(m);
				}
				break;
			
			static const char * const shrug = R"(Â¯\_(ã)_/Â¯)"; // making this a regex would require annoyingly much escaping
			case 0xC2: // first half of Â¯ in utf8
				if ((size_t)(textend-text) >= strlen(shrug) && !memcmp(text, shrug, strlen(shrug)))
				{
					out.append(fmt).text = shrug;
					text += strlen(shrug);
					last_match = shrug;
					goto next;
				}
				break;
		}
		if (text == textend) break;
		
		auto m = re_text.match(text, textend); // always matches, no need to check
		text = m[0].end;
		last_match = m[0].str();
		
		string newtext_s = emoji->translate(m[0].str());
		const char * newtext = newtext_s;
		const char * newtextend = newtext + newtext_s.length();
		
		if (newtext_s.contains(":"))
		{
			while (auto m = re_emoji.search(newtext, newtextend))
			{
				out.append(fmt).text = make(newtext, m[0].start);
				if (emoji->insert(out, fmt, m[0].str()))
					newtext = m[0].end;
				else
				{
					out.append(fmt).text = ":";
					newtext = m[0].start+1;
				}
			}
		}
		//ignore last_match; either it's not set here, or it's set to [newtext .. newtextend)
		//quotes only care about trailing whitespace, so both solutions give the right answer
		out.append(fmt).text = make(newtext, newtextend);
	}
}
#undef MATCH

void parse(source_t source, array<span>& out, const span& fmt, cstring text) const override
{
	this->source = source;
	this->last_match = "\n";
	this->root_fmt = fmt;
	
	string newtext = text.replace("\r\n","\n")
	                     .replace("\r","\n")
	                     .replace("\f","") // it discards form feed; commit message says it's supposed to become \n, but it's typoed
	                     .replace("\t","    "); // https://github.com/discordapp/simple-markdown/commit/6ee0e9c666
	
	array<span> spans;
	recurse(spans, false, fmt, newtext);
	flatten_blocks(out, spans);
}

string unparse_irc(cstring in) const override
{
	//TODO
	return in;
}
};
}


discord_format* discord_format::create(discord_emoji* emoji,
                                       function<void(array<span>& out, const span& fmt, cstring content)> cb_external,
                                       uint32_t spoiler_col)
{
	return new discord_format_impl(emoji, cb_external, spoiler_col);
}

#ifdef ARLIB_TEST
//#define USE_MOCK_EMOJI_PARSER

class discord_emoji_test : public discord_emoji {
public:
	mutable autoptr<textview::image> img;
	bool insert(array<span>& out, const span& fmt, cstring name) const override
	{
		if (name == ":copyright:" || name == ":tm:")
		{
			out.append(fmt).text = (name[1]=='c' ? "Â©" : "â¢");
			return true;
		}
		
		if (name == ":fist:" || name == ":skin-tone-3:" || name == ":fist::skin-tone-3:" ||
		    name == ":poop:" || name == ":three:" || name == ":asterisk:")
		{
			span& sp = out.append(fmt);
			sp.text = name;
			sp.img = img;
			return true;
		}
		
		return false;
	}
	string translate(cstring in) const override
	{
		return in.replace("Â©",":copyright:")
		         .replace("â¢",":tm:")
		         .replace("â",":fist:")
		         .replace("ð½",":skin-tone-3:")
		         .replace("ð©",":poop:")
		         .replace("3â£",":three:")
		         .replace("*â£",":asterisk:");
	}
	// the tests don't need these (never called), but they're pure virtual and must exist
	arrayview<cstring> names() const override { abort(); }
	textview::image* pick_avatar(uint64_t seed) const override { abort(); }
};

static void external_cb(array<span>& out, const span& fmt, cstring content)
{
	span sp = { content };
	sp.fgcol = 1;
	out.append(sp);
}

discord_emoji* discord_emoji_get_test();
static discord_format* get_formatter()
{
#ifdef USE_MOCK_EMOJI_PARSER
	// don't wanna deal with lifetime of these guys, making them all static is easier
	static discord_emoji_test emoji_s;
	emoji_s.img = textview::image::blank(16,16);
	static discord_emoji* emoji = &emoji_s;
#else
	discord_emoji* emoji = discord_emoji_get_test();
#endif
	static discord_format_impl format(emoji, external_cb, 0x123);
	return &format;
}

static bool fmteq(span& a, span& b)
{
	if ((bool)a.img != (bool)b.img) return false;
	if (a.hidden != b.hidden) return false;
	if (a.bold != b.bold) return false;
	if (a.underline != b.underline) return false;
	if (a.italics != b.italics) return false;
	if (a.strike != b.strike) return false;
	if (a.monospace != b.monospace) return false;
	if (a.hyperlink != b.hyperlink) return false;
	if (a.fgcol != b.fgcol) return false;
	if (a.bgcol != b.bgcol) return false;
	return true;
}
static void flatten(array<span>& spans, bool drop_200b = false)
{
	//eat empty first, in case strikethrough emits identical spans with empty ones between
	for (size_t i=0;i<spans.size();i++)
	{
		if (drop_200b)
			spans[i].text.replace("\xE2\x80\x8B", "");
		if (spans[i].fgcol == 0x123) // wipe fgcol for spoilers, we only need bgcol
			spans[i].fgcol = (uint32_t)-1;
		if (spans[i].text == "") // keep this last, accessing spans[-1] doesn't help too much
			spans.remove(i--);
	}
	for (int i=0;i<(int)spans.size()-1;i++)
	{
		if (fmteq(spans[i],spans[i+1]) && spans[i].fgcol == (uint32_t)-1 && !spans[i].img)
		{
			spans[i].text += spans[i+1].text;
			spans.remove(i+1);
			i--;
		}
	}
}
static string span_fmt(int idx, const span& sp)
{
	string ret;
	if (idx >= 0) ret += tostring(idx)+":";
	if (sp.img) ret += "%i";
	else if (sp.fgcol != (uint32_t)-1) ret += "%"+tostring(sp.fgcol);
	else
	{
		if (sp.bold) ret += "%B";
		if (sp.italics) ret += "%I"; // alphabetical sorting is easy to remember, anything else would yield typoed tests
		if (sp.bgcol == 0x123) ret += "%H"; // even though it yields silly results, like link between bold and underline
		if (sp.hyperlink) ret += "%L";
		if (sp.monospace) ret += "%M";
		if (sp.strike) ret += "%S";
		if (sp.underline) ret += "%U";
	}
	return ret + sp.text;
}
static string spans_fmt(array<span>& spans)
{
	flatten(spans);
	return spans.select([](const span& sp)->string { return span_fmt(-1, sp); }).as_array().join("!");
}

static void test1f(discord_format::source_t source, cstring input, cstring expected)
{
	assert(!input.startswith(" ")); // if input starts or end with whitespace, it can't be copypasted to discord
	assert(!input.startswith("\n"));
	assert(!input.endswith(" "));
	assert(!input.endswith("\n"));
	
	testctx(input) {
		array<span> spans;
		get_formatter()->parse(source, spans, span(), input);
		for (span& sp : spans)
		{
			assert(sp.text.isutf8());
			assert(!sp.text.contains_nul());
		}
		
		assert_eq(spans_fmt(spans), expected);
	}
}

#define test1(input, expected) testcall(test1f(discord_format::normal, input, expected))
#define test1t(type, input, expected) testcall(test1f(discord_format::type, input, expected))

test("Discord formatting - preprocessor", "d-emoji", "d-format")
{
	test1("a\ta\r\nb\f\f\fc", "a    a\nbc");
}
test("Discord formatting - asterisks", "d-emoji", "d-format")
{
	test1("e*e**e***e", "e!%Ie!%B%Ie!e");
	test1("e**e*e***e", "e!%Be!%B%Ie!e");
	test1("e*e***e**e", "e!%Ie**!e**e");
	test1("e**e***e*e", "e!%Be*!e*e");
	test1("e***e**e*e", "e!%B%Ie!%Ie!e");
	test1("e***e*e**e", "e!%B%Ie!%Be!e");
	test1("****", "%I**");
	test1("***a**", "%B*a");
	test1("a *aa **aaa***", "a !%Iaa !%B%Iaaa");
	test1("* a*", "* a*");
	test1("*a *", "*a *");
	test1("*a**\n****", "*a!%B\n**");
	test1("**a\\**", "*!%Ia*");
	test1("* *foo*", "* !%Ifoo"); // ensure the regexes are anchored
	test1("* **foo**", "* !%Bfoo");
	test1("*\\*", "**");
	test1("****.**", "%B**.");
	test1("******", "%I**");
}
test("Discord formatting - underscores", "d-emoji", "d-format")
{
	test1("e_e__e___e", "e_e!%Ue_!e");
	test1("e__e_e___e", "e!%Ue!%I%Ue!e");
	test1("e_e___e__e", "e_e!%U_e!e");
	test1("e__e___e_e", "e!%Ue_!e_e");
	test1("e___e__e_e", "e!%U_e!e_e");
	test1("e___e_e__e", "e!%U_e_e!e");
	test1("____", "%I__");
	test1("___a__", "%U_a");
	test1("_ a_a", "_ a_a");
	test1("__a\\__", "_!%Ia_");
	test1("_ _foo_", "_ !%Ifoo");
	test1("_ __foo__", "_ !%Ufoo");
	test1("____.__", "%U__.");
	test1("______", "%I__");
}
test("Discord formatting - nesting", "d-emoji", "d-format")
{
	test1("*_*_*_*_", "%I_*!*_"); // *_* (italic _), _*_ (italic *), repeat
	test1("*_*_*_*_*_*_*_*_", "%I_*_*_!_");
	test1("b*c**ppp___p_p__pg***e", "b!%Ic!%B%Ippp!%B%I%U_p_p!%B%Ipg!e");
}
test("Discord formatting - tilde", "d-emoji", "d-format")
{
	test1("~~a~~", "%Sa");
	test1("~~ ~~", "%S ");
	test1("~~ ~~_", "~~ ~~_");
	test1("~~~a~~~", "%S~a!~");
	test1("~~~~~~~~~~~~~~~~~~~~~", "%S~~~~!~");
	test1("~ ~~a~~", "~ !%Sa");
}
test("Discord formatting - backticks", "d-emoji", "d-format")
{
	test1("````\nh```", "%M`\nh");
	test1("````\nh\n\n\n```", "%M`\nh");
	test1("``````\n`   `\n```", "%M```\n`   `");
	test1("```a\nb\n```", "%Mb");
	test1("``````", "``````");
	test1("```````", "%M`");
	test1("````````", "%M`!\n`");
	test1("`````````````", "%M`!\n``````");
	test1("``````````````", "%M`!\n!%M`");
	test1("```eee\n```", "%Meee");
	test1("```\n````", "%M`");
	test1("```\n```", "%M\n"); // I'm pretty sure this incorrectly fails to match re_fence, but re_inlineCode catches it and renders
	test1("```\n````", "%M`"); //    the same way, and it seems impossible to cascade that issue into misparsing anything else
	test1("```rrr\n```hhh\n```", "%M```hhh");
	test1("```asciidoc\r\n210b aaa```", "%M210b aaa"); // language should be removed and ignored, syntax highlighting not supported
	test1("```C++\nint main()```", "%Mint main()");
	test1("```AsciiDoc\n210b aaa```", "%M210b aaa");
	test1("```asciidoc \n210b aaa```", "%Masciidoc \n210b aaa");
	test1("a```ee```", "a\n!%Mee");
	test1("```ee```a", "%Mee!\na");
	test1("```a``````a```", "%Ma!\n!%Ma");
	test1("```a```a```a```", "%Ma!\na\n!%Ma");
	test1("```a``` ```a```", "%Ma!\n \n!%Ma");
	test1("```a```\n```a```", "%Ma!\n\n!%Ma");
	test1("a ` a ` a", "a !%M a ! a");
	test1("` `", "%M ");
	test1("`` ` ``", "%M`");
	test1("`` a` ``", "%M a`");
	test1("`` `a ``", "%M`a ");
	test1("`a`\n```a```", "%Ma!\n!%Ma");
	test1("```a```\n`a`", "%Ma!\n\n!%Ma"); // yes, this should have double linebreak
	test1("````a````", "%M`a!\n`");
	test1("a**```b```**", "a!%B\n!%B%Mb");
	test1("**```a```**b", "%B%Ma!%B\n!b");
	test1("``a``", "%Ma");
	test1("` ``a``", "` !%Ma");
	test1("` ```a```", "` \n!%Ma");
	
	// the obvious implementation yields O(n^3) runtime
	// current implementation is O(n^2), but with input limited to 2000 chars, the harm is fairly limited
	// repeating *, _, ~~_, \``, or <:/ also gives quadratic behavior; fixing them all exceeds my capabilities
#define LF_50 "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
#define LF_500 LF_50 LF_50 LF_50 LF_50 LF_50 LF_50 LF_50 LF_50 LF_50 LF_50
	test1("```a" LF_50 LF_50 LF_50 LF_50 LF_50 "a",
	      "```a" LF_50 LF_50 LF_50 LF_50 LF_50 "a");
	if (!RUNNING_ON_VALGRIND)
		test1("```a" LF_500 LF_500 LF_500 LF_500 "a",
		      "```a" LF_500 LF_500 LF_500 LF_500 "a");
#undef LF_50
#undef LF_500
}
test("Discord formatting - spoilers", "d-emoji", "d-format")
{
	test1("||aaa||", "%Haaa");
	test1("|| aaa ||", "%H aaa ");
	test1("aa || bb || cc", "aa !%H bb ! cc");
	test1("aa ||bb|| cc", "aa !%Hbb! cc");
	test1("aa|| bb ||cc", "aa!%H bb !cc");
	test1("aa||bb||cc", "aa!%Hbb!cc");
	test1("||||", "||||");
	test1("|||||", "%H|");
	test1("||||||||||||||||||||||", "%H||||!||");
	test1("aa **||bb||** cc ||**dd**|| ee", "aa !%B%Hbb! cc !%B%Hdd! ee");
	test1("| ||foo||", "| !%Hfoo");
}
test("Discord formatting - quotes", "d-emoji", "d-format")
{
	test1("> a", "> a"); // my chosen rendering of quotes is 'prefix each line with >', which is identical to the markdown
	test1(">> a", ">> a"); // testing is done mostly with >>>, partially with bolding the entire thing (the >s are forcibly unformatted)
	test1(">>> a", "> a");
	test1(">>>> a", ">>>> a");
	test1("> a\nb", "> a\nb");
	test1("> a\n   b", "> a\n   b");
	test1(">> a\nb", ">> a\nb");
	test1(">>> a\nb", "> a\n> b");
	test1(">>> a\n> b", "> a\n> > b"); // no nested quotes allowed
	test1(">>> a\n>>> b", "> a\n> >>> b");
	test1(">>>> a\nb", ">>>> a\nb");
	test1("> a\n> b\n> c", "> a\n> b\n> c");
	test1("> a\n > b\n  > c", "> a\n> b\n> c");
	test1("test\n> a", "test\n> a");
	test1("test\n > a", "test\n \n> a");
	test1("test\n > a\n > b", "test\n \n> a\n> b");
	test1("**>>> a**", "> !%Ba");
	test1("a > b\nc", "a > b\nc");
	test1("a >>> b\nc", "a >>> b\nc");
	test1("**a\n>>>**", "%Ba\n>>>");
	test1("**a\n>>> **", "%Ba\n!> ");
	test1("**a\n>>>  **", "%Ba\n!> !%B ");
	test1("```\ntest\n```>>> test", "%Mtest!\n>>> test");
	test1("```\ntest```\n>>> test", "%Mtest!\n\n> test");
	test1("**test**>>> test", "%Btest!>>> test");
	test1("**test**\n>>> test", "%Btest!\n> test");
	test1("**test\n**>>> test", "%Btest\n!>>> test");
	test1("**a\n> b**", "%Ba\n!> !%Bb");
	test1("**> a\n**>>> b", "> !%Ba\n!>>> b");
	test1("**>>> a\n**>>> b", "> !%Ba\n!>>> b");
	test1("**>>> test\ntest\n**test", "> !%Btest\n!> !%Btest\n!test");
	test1("**a\n>>> a**", "%Ba\n!> !%Ba");
	test1("**a\n>>> a\n**", "%Ba\n!> !%Ba");
	test1("**a\n>>> a__\n__**", "%Ba\n!> !%Ba");
	test1("**a\n>>> a\n **", "%Ba\n!> !%Ba\n!> !%B ");
	test1("**a\n>>> a\n**>>> a", "%Ba\n!> !%Ba\n!>>> a");
	test1("**a\n>>> a**>>> a", "%Ba\n!> !%Ba\n!>>> a");
	test1("__> **a\n>\n> b**__", "> !%U**a\n>\n!> !%Ub**");
	test1("__> **a\n> \n> b**__", "> !%B%Ua\n!> !%B%U\n!> !%B%Ub");
	test1("**test\n>>> test\ntest\n**test", "%Btest\n!> !%Btest\n!> !%Btest\n!test");
	test1("**test\n>>> test\ntest**test", "%Btest\n!> !%Btest\n!> !%Btest\n!test");
	test1("> `a\na`", "> `a\na`");
	test1("> `a\n> a`", "> !%Ma\n!> !%Ma");
	test1("> `a\n>  a`", "> !%Ma\n!> !%M a");
	test1("> ```a```", "> !%Ma");
	test1("__**a\n** > test__", "%B%Ua\n!%U > test");
	test1("**a\n** >>> test", "%Ba\n! >>> test");
	test1("__**a\n** >     test__", "%B%Ua\n!%U >     test");
	test1("__**a\n** >>>     test__", "%B%Ua\n!%U >>>     test");
	test1("__aâa\n>>> a__", "%Ua!%i:fist:!%Ua\n!> !%Ua"); // ensure the re_emoji on emoji->translate doesn't set last_match
	test1("Â¯\\_(ã)_/Â¯>>> a", "Â¯\\_(ã)_/Â¯>>> a"); // ensure this one sets last_match, despite not being a regex
	test1(">> > foo", ">> > foo");
	test1(">> >>> foo", ">> >>> foo");
	test1("> aaaaaaaaaaaaaaaa", "> aaaaaaaaaaaaaaaa"); // ensure memory allocation behavior isn't crazy
}
test("Discord formatting - escapes", "d-emoji", "d-format")
{
	test1("\\a", "\\a");
	test1("\\:three:", ":three:");
	test1("\\\\:three:", "\\!%i:three:");
	test1("\\ a", "\\ a");
	test1("\\ð©", "ð©");
	test1("\\a \\%", "\\a %");
}
test("Discord formatting - shrug", "d-emoji", "d-format")
{
	test1("Â¯\\_(ã)_/Â¯", "Â¯\\_(ã)_/Â¯");
	test1("Â¯\\_(ã)_/", "Â¯_(ã)_/");
	test1("\\Â¯\\_(ã)_/Â¯", "Â¯_(ã)_/Â¯");
	test1("_Â¯\\_(ã)_/Â¯_", "%IÂ¯_(ã)!/Â¯_");
	test1("Â¯\\_(ã)_/Â¯_", "Â¯\\_(ã)_/Â¯_");
	test1("\\Â¯\\_(ã)_/Â¯ _Â¯\\_(ã)_/Â¯_", "Â¯_(ã)!%I/Â¯ !Â¯\\_(ã)_/Â¯_");
	test1("aaaÂ¯\\_(ã)_/Â¯", "aaaÂ¯\\_(ã)_/Â¯");
	test1("Â½Â¯\\_(ã)_/Â¯", "Â½Â¯\\_(ã)_/Â¯");
}
test("Discord formatting - links", "d-emoji", "d-format")
{
	test1("<http://example.com> <https://example.com>", "%Lhttp://example.com! !%Lhttps://example.com");
	test1("<https://ex ample.com> <https:example.com>", "<!%Lhttps://ex! ample.com> <https:example.com>");
	test1("<HTTP://EXAMPLE.COM>", "%LHTTP://EXAMPLE.COM");
	test1("<ftp://example.com>", "ftp://example.com");
	test1("http://aaa(foo) (http://aaa) (http://aaa(foo))", "%Lhttp://aaa(foo)! (!%Lhttp://aaa!) (!%Lhttp://aaa(foo)!)");
	test1("http://aaa. http://aaa? http:// http://a http://ab", "%Lhttp://aaa!. !%Lhttp://aaa?! http:// http://a !%Lhttp://ab");
	test1("(http://a) http://â http://ð© aahttp://ggg", "(!%Lhttp://a!) http://!%i:fist:! !%Lhttp://%F0%9F%92%A9! aa!%Lhttp://ggg");
	test1("http://exampl\xD0\xB5.com <http://exampl\xD0\xB5.com>", "%Lhttp://exampl%D0%B5.com! !%Lhttp://exampl%D0%B5.com");
	test1("<> <http://example.com/>", "<> !%Lhttp://example.com/");
	test1("<><http://example.com/>", "<>!%Lhttp://example.com/");
	test1("<<http://example.com/>", "<http://example.com/");
	test1("hello http://example.com/", "hello !%Lhttp://example.com/");
	test1("xhttp://example.com/ steam://foo**bar**", "x!%Lhttp://example.com/! steam://foo**bar**");
	test1("<a:b:/c**d>e**f", "<a!%i:b:!/c!%Bd>e!f");
	
#define X50 "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
#define Y50 ":/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/:/"
	test1(X50 Y50 Y50, X50 Y50 Y50);
	if (!RUNNING_ON_VALGRIND)
		test1(X50 X50 X50 X50 X50 X50 X50 X50 X50 X50 Y50 Y50 Y50 Y50 Y50 Y50 Y50 Y50 Y50 Y50,
		      X50 X50 X50 X50 X50 X50 X50 X50 X50 X50 Y50 Y50 Y50 Y50 Y50 Y50 Y50 Y50 Y50 Y50);
#undef X50
#undef Y50
}
test("Discord formatting - emoji", "d-emoji", "d-format")
{
	test1(":fist: :skin-tone-3: :fist::skin-tone-3:", "%i:fist:! !%i:skin-tone-3:! !%i:fist::skin-tone-3:");
	test1(":three: :three::skin-tone-3:", "%i:three:! :three:!%i:skin-tone-3:");
	test1(":three:three: :aaaa:three:", "%i:three:!three: :aaaa!%i:three:");
	test1("**:three:**:fist:", "%i:three:!%i:fist:");
	test1(":fist::skin-tone-3: :fist::skin-tone-8:", "%i:fist::skin-tone-3:! :fist::skin-tone-8:");
	test1(":fist::skin-tone-42:", "%i:fist:!:skin-tone-42:");
	test1(":fist::skin-tone-3:three:", "%i:fist::skin-tone-3:!three:");
	test1(":fist::skin-tone-8:three:", ":fist::skin-tone-8!%i:three:");
	test1(": :poop:", ": !%i:poop:");
	test1(":not-an-emoji::skin-tone-3::skin-tone-3::skin-tone-3:", ":not-an-emoji::skin-tone-3::skin-tone-3:!%i:skin-tone-3:");
	test1(":fist::skin-tone-3::skin-tone-3::skin-tone-3:", "%i:fist::skin-tone-3:!:skin-tone-3:!%i:skin-tone-3:");
	test1("â:skin-tone-3:", "%i:fist:!%i:skin-tone-3:");
	test1("ð½ð½ð½ð½", ":skin-tone-3::skin-tone-3::skin-tone-3:!%i:skin-tone-3:");
	test1("3â£ :3â£: 3â£:/ 3â£3â£3â£ 33â£", "%i:three:! :!%i:three:!: !%i:three:!:/ !%i:three:!%i:three:!%i:three:! 3!%i:three:");
	test1(":threeâ :aaaâ :fist3â£ :fist*â£", "%i:three:!fist: :aaa!%i:fist:! !%i:fist:!three: :fist!%i:asterisk:");
	test1(":copyright: :fist:copyright: :fistÂ©", "Â© !%i:fist:!copyright: :fistÂ©");
	test1("**:copyright: Â©** :copyright:fist:", "%BÂ© Â©! Â©fist:");
	test1(":tm: :fist:tm: :fistâ¢", "â¢ !%i:fist:!tm: !%i:fist:!tm:");
	test1(":fistâ¢ **:tm: â¢** :tm:fist:", "%i:fist:!tm: !%Bâ¢ â¢! â¢fist:");
	test1("Â©", "Â©");
}
test("Discord formatting - emoji fragments", "d-emoji", "d-format")
{
#ifdef USE_MOCK_EMOJI_PARSER
	test_skip_force("the mock emoji parser doesn't handle emoji fragments");
#endif
	test1(u8"@nobody\u200dâ @everyone\u200dâ", u8"@nobody\u200dâ @everyone\u200d!%i:fist:");
	test1(u8"\\â\u200dâ \\ð©\u200dâ", "â\u200d!%i:fist:! ð©\u200dâ");
}
test("Discord formatting - custom emoji", "d-emoji", "d-format")
{
	test1("<:three:123> <:three:> <::123> <:three:123", "%1:three:123! <!%i:three:!> <::123> <!%i:three:!123");
	test1("<a:three:123> <a:three:> <a::123> <a:three:123", "%1a:three:123! <a!%i:three:!> <a::123> <a!%i:three:!123");
}
test("Discord formatting - mentions", "d-emoji", "d-format")
{
	test1("<@!123> <#123> <@&123> <@123>", "%1@!123! !%1#123! !%1@&123! !%1@123");
	test1("<@123 <@!123 <@&123 <#123 <@> <@!> <@&> <#> <>", "<@123 <@!123 <@&123 <#123 <@> <@!> <@&> <#> <>");
}
test("Discord formatting - weird spaces", "d-emoji", "d-format")
{
	//using U+1680 OGHAM SPACE MARK since it's visually distinct from normal space
	test1("\\áa", "\\áa");
	test1("http://derpáderp", "%Lhttp://derp!áderp");
	test1("<http://derpáderp>", "%Lhttp://derp%E1%9A%80derp");
	test1("*áa*", "*áa*");
	test1("*aá*", "*aá*");
	test1("` á`", "%M á");
	test1("`áá`", "%Máá");
	test1("`  á`", "%M  á");
	test1("`ááaáá`", "%Mááaáá");
	test1("aa\n\nbb", "aa\n\nbb"); // \n is whitespace too
	//all the unicode spaces matched by \s
	cstring spaces = u8"\\\u00a0\\\u1680\\\u2000\\\u2001\\\u2002\\\u2003\\\u2004\\\u2005\\\u2006\\\u2007\\\u2008\\\u2009\\\u200a"
	                 u8"\\\u2028\\\u2029\\\u202f\\\u205f\\\u3000\\\ufeff";
	test1(spaces, spaces);
}
test("Discord formatting - alternative types", "d-emoji", "d-format")
{
	test1t(normal,      "[foo**bar](http://example.com)**", "[foo!%Bbar](!%B%Lhttp://example.com!%B)");
	test1t(webhook,     "[foo**bar](http://example.com)**", "[foo**bar](!%Lhttp://example.com!)**");
	test1t(embed_body,  "[foo**bar](http://example.com)**", "[foo**bar](!%Lhttp://example.com!)**");
	test1t(embed_title, "[foo**bar](http://example.com)**", "[foo!%Bbar](!%B%Lhttp://example.com!%B)");
	test1t(topic,       "[foo**bar](http://example.com)**", "[foo!%Bbar](!%B%Lhttp://example.com!%B)");
	test1t(topic,       "[link](http://derp.com/(foo)and(bar))", "[link](!%Lhttp://derp.com/(foo)and(bar))"); // TODO
	
	test1t(normal,      "**\n> foo\n>>> foo**", "%B\n!> !%Bfoo\n!> !%Bfoo");
	test1t(webhook,     "**\n> foo\n>>> foo**", "%B\n!> !%Bfoo\n!> !%Bfoo");
	test1t(embed_body,  "**\n> foo\n>>> foo**", "%B\n!> !%Bfoo\n!> !%Bfoo");
	test1t(embed_title, "**\n> foo\n>>> foo**", "%B\n!> !%Bfoo\n!> !%Bfoo");
	test1t(topic,       "**\n> foo\n>>> foo**", "%B\n> foo\n>>> foo");
	
	test1t(normal,      "`foo` ```bar```", "%Mfoo! \n!%Mbar");
	test1t(webhook,     "`foo` ```bar```", "%Mfoo! \n!%Mbar");
	test1t(embed_body,  "`foo` ```bar```", "%Mfoo! \n!%Mbar");
	test1t(embed_title, "`foo` ```bar```", "%Mfoo! !%Mbar"); // fence is disabled, but inlineCode picks it up
	test1t(topic,       "`foo` ```bar```", "`foo` ```bar```");
	
	test1t(normal,      "<@123> <@&123> <@!123> <#123> <:foo:123>", "%1@123! !%1@&123! !%1@!123! !%1#123! !%1:foo:123");
	test1t(webhook,     "<@123> <@&123> <@!123> <#123> <:foo:123>", "%1@123! !%1@&123! !%1@!123! !%1#123! !%1:foo:123");
	test1t(embed_body,  "<@123> <@&123> <@!123> <#123> <:foo:123>", "%1@123! !%1@&123! !%1@!123! !%1#123! !%1:foo:123");
	test1t(embed_title, "<@123> <@&123> <@!123> <#123> <:foo:123>", "<@123> <@&123> <@!123> <#123> !%1:foo:123"); // ignore @everyone
	test1t(topic,       "<@123> <@&123> <@!123> <#123> <:foo:123>", "%1@123! !%1@&123! !%1@!123! !%1#123! !%1:foo:123");
}
#undef test1
#undef test1t

#define MINIZ_HEADER_FILE_ONLY
#include "arlib/deps/miniz.c"
test("Discord formatting - performance", "d-emoji", "d-format")
{
	test_skip("too slow");
	// takes 30 seconds under Valgrind, but occasionally worth doing
	array<string> texts;
	
	array<uint8_t> comp = file::readall(file::resolve(file::exepath(), "../discord-cache.bin"));
	
	size_t decomplen;
	void* decomp = tinfl_decompress_mem_to_heap(comp.ptr(), comp.size(), &decomplen, 0);
	
	jsonparser json = string(arrayview<uint8_t>((uint8_t*)decomp, decomplen));
	while (true)
	{
		jsonparser::event ev = json.next();
		if (ev.action == jsonparser::map_key && ev.str == "text")
			texts.append(json.next().str);
		if (ev.action == jsonparser::finish)
			break;
	}
	
	timer t;
	for (cstring text : texts)
	{
		array<span> spans;
		get_formatter()->parse(discord_format::normal, spans, span(), text);
	}
	printf("took %zuus\n", t.us());
}

static void irc_parse(array<span>& out, cstring irc)
{
	span next;
	
	size_t n=0;
	while (n<irc.length())
	{
		uint8_t ch = irc[n++];
		if (LIKELY(ch >= 32)) { next.text += ch; continue; }
		
		out.append(next);
		next.text = "";
		
		if(0);
		else if (ch == 0x02) next.bold ^= 1;
		else if (ch == 0x1D) next.italics ^= 1;
		else if (ch == 0x1F) next.underline ^= 1;
		else if (ch == 0x1E) next.strike ^= 1;
		else if (ch == 0x11) next.monospace ^= 1;
		else if (ch == 0x0F) next = span();
		else next.text += ch;
	}
	out.append(next);
}
static void test1u(cstring irc)
{
	array<span> expected;
	array<span> actual;
	irc_parse(expected, irc);
	get_formatter()->parse(discord_format::normal, actual, span(), get_formatter()->unparse_irc(irc));
	for (span& sp : actual)
	{
		sp.hyperlink = false;
	}
	
	assert_eq(spans_fmt(actual), spans_fmt(expected));
}

#define test1(irc) testcall(test1u(irc))
test("Discord unformatting", "d-format", "")
{
	test_skip("unimplemented");
	test1("aabb");
	test1("aa\x02zb");
	test1("aa\x02z\x02z");
	test1("aa\x02z**b\x02y");
	test1("aa\x1Dz**b\x1Dy");
	test1("xx\x02z\x1Fyy");
	test1("xx\x02z\x1Fyy");
	test1("xx\x02z\x1Fy\x02yw\x1Fww");
	test1("xx\x02z\x1Fy\x02y\x02w\x1Fw\x02w");
	test1("\x11`````````"); // ` should become `` ` ``, though `` must become `` `<200B>` ``
	
	const char * tokens[] = { "*", "_", "~~", "`", "**", "__", "http://", "<", ">", "||", ">>>",
	                          " ", "x", "1", " ", "aaaaa", "123", "\\", "\n", "eee", "42",
	                          "\x02", "\x0F", "\x11", "\x1D", "\x1E", "\x1F",
	                        };
	
	for (int i=0;i<100000;i++)
	{
		random_t rand;
		rand.seed(i);
		string test;
		for (int j=0;j<100;j++)
			test += tokens[rand()%ARRAY_SIZE(tokens)];
		test1(test);
	}
	
	assert(!get_formatter()->unparse_irc("@here").contains("@here")); // ->parse ignores this, so must test separately
	assert(!get_formatter()->unparse_irc("@everyone").contains("@everyone")); // output should contain @<200B>everyone
}
#undef test1
#endif
}
