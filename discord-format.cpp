#include <regex> // include before arlib.h, <regex> doesn't like #define test()
#include "discord.h"

namespace russian {

namespace {
static cstring make(const char * a, const char * b)
{
	return cstring(arrayview<byte>((uint8_t*)a, b-a));
}

//Input must start with http:// or https://.
//Output will be same as input, except if the domain name contains non-ascii, in which case it will be percent encoded.
static string sanitize_link(cstring str)
{
	string ret;
	size_t slashes = 0;
	for (uint8_t ch : str.bytes())
	{
		if (ch == '/')
			slashes++;
		if (slashes < 3 && (ch < 0x20 || ch >= 0x80))
			ret += "%"+tostringhex<2>(ch);
		else
			ret += ch;
	}
	return ret;
}

class discord_format_impl : public discord_format {
public:
	//some regexes are from https://github.com/discordapp/simple-markdown, others were guessed, or tweaked to match discord
	//^s were replaced with std::regex_constants::match_continuous,
	// since apparently (unlike JS) ^ matches the start of any line, not just start of the string
	
	//equivalent to [\s\S] on utf8, matches one codepoint exactly
	//often not needed; for example, [\s\S]+ should not be replaced
	//\x00-\x7F\x80-\xBF instead of \x00-\xBF is because libstdc++ rejects that range; boost doesn't, I don't know which is wrong
	//(yes, this does dumb stuff on invalid utf8, but we'll never get invalid utf8 so who cares)
#define RE_U8_ANY R"((?:[\x00-\x7F\x80-\xBF]|[\xC0-\xDF].|[\xE0-\xEF]..|[\xF0-\xFF]...))"
	//equivalent to [\s\S] on utf16, but on a utf8 string
	//matches 1-3 bytes, or the first 3 bytes of a 4byte code unit; also matches continuations, so this one twice will match one U+1F4A9
#define RE_U16_ANY R"((?:[\x00-\x7F\x80-\xBF]|[\xC0-\xDF].|[\xE0-\xFF]..))"
	
#define RE_SPACE_CORE(x) "[" x " \f\n\r\t\v]|\xC2\xA0|\xE1\x9A\x80|\xE2\x80[\\x80-\\x8A]|" \
                         "\xE2\x80\xA8|\xE2\x80\xA9|\xE2\x80\xAF|\xE2\x81\x9F|\xE3\x80\x80|\xEF\xBB\xBF"
	
	//equivalent to \s, i.e. [ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]
#define RE_SPACE RE_SPACE_OR("")
	//equivalent to "[\s" chars "]"
#define RE_SPACE_OR(chars) "(?:" RE_SPACE_CORE(chars) ")"
	//equivalent to "[^\s" chars "]" (aka \S if no chars), as utf16 (RE_ANY_U16)
	//note that this one may not be repeated (+, ? and *); use (?: RE_U16_NOT_SPACE )+
	//RE_SPACE may be repeated
#define RE_U16_NOT_SPACE_OR(chars) RE_EXIST_NOT_SPACE_OR(chars) RE_U16_ANY
#define RE_U8_NOT_SPACE_OR(chars) RE_EXIST_NOT_SPACE_OR(chars) RE_U8_ANY
#define RE_EXIST_NOT_SPACE RE_EXIST_NOT_SPACE_OR("")
#define RE_EXIST_NOT_SPACE_OR(chars) "(?!" RE_SPACE_CORE(chars) ")"
	
	//this is heavily simplified from original's fence, ^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n *)+\n
	//for example, it doesn't need the trailing linebreak, making it more suitable for chatting
	std::regex re_fence{R"(```(?:[0-9a-zA-Z-]+\n)?\n*([\s\S]+?)\n*```)"};
	//without macros: \\([^0-9A-Za-z\s])
	std::regex re_escape{R"(\\()" RE_U8_NOT_SPACE_OR("0-9A-Za-z") ")"};
	std::regex re_autolink{R"(<([^ >]+:/[^ >]+)>)"}; // why is that called auto? and why is it using literal space, not \s?
	//original, ^(https?:\/\/[^\s<]+[^<.,:;"')\]\s]), doesn't have steam, and bans end-paren
	// (the escaped slashes are due to JS)
	//without macros: ((?:https?|steam)://[^\s<]+[^<.,:;"'\]\s])
	//yes, steam is needed, even though I don't render steam links; I want steam://foo**bar** to render as asterisks, not bold
	std::regex re_url{R"(((?:https?|steam)://(?:)" RE_U16_NOT_SPACE_OR("<") R"()+)" RE_U16_NOT_SPACE_OR("<.,:;\"'\\]") R"())"};
	std::regex re_strong{R"(\*\*([\s\S]+?)\*\*(?!\*))"};
	std::regex re_u{R"(__([\s\S]+?)__(?!_))"};
	//em is originally one big regex, split for performance reasons
	//the leading \b is a nop; the trailing is correct and non-nop, JS' definition of 'word character' is simply a-zA-Z0-9_
	std::regex re_em_u{R"(\b_((?:__|\\[\s\S]|[^\\_])+?)_\b)"};
	//this matches a slightly newer version than the above repo
	//https://github.com/Khan/simple-markdown/commit/867e85f5b716d010b20723a0f3751766ea585fd7#diff-9bd36ebd10de7fb38d6e24c64d4d1540L1205
	//they act slightly differently on, for example, e*e**e***e
	//without macros: ^\*(?=\S)((?:\*\*|\s+(?:[^\*\s]|\*\*)|[^\s\*])+?)\*(?!\*)
	std::regex re_em_ast{R"(\*)" RE_EXIST_NOT_SPACE R"(((?:\*\*|)" RE_SPACE R"(+(?:)"
	                  RE_U16_NOT_SPACE_OR("*") R"(|\*\*)|)" RE_U16_NOT_SPACE_OR("*") R"()+?)\*(?!\*))"};
	//original, (^~~(?=\S)([\s\S]*?\S)~~), is completely different
	//this one allows strikethrough of a space, and what's with the underscore?
	std::regex re_del{R"(~~([\s\S]+?)~~(?!_))"};
	//without macros: ((`+)\s*([\s\S]*?[^`])\s*\1(?!`)
	std::regex re_inlineCode{R"((`+))" RE_SPACE R"(*([\s\S]*?[^`]))" RE_SPACE R"(*\1(?!`))"};
	//seems like the newer ones prefer space to \s
	//the special spaces shouldn't exist in the first place, anyways
	std::regex re_spoiler{R"(\|\|([\s\S]+?)\|\|)"};
	std::regex re_linequote{R"(( *> [^\n]*\n?)+)"};
	std::regex re_linequote_replace{R"((^|\n) *> )"};
	std::regex re_blockquote{R"( *>>> [\s\S]*)"};
	
	//original, ^[\s\S]+?(?=[^0-9A-Za-z\s\u00c0-\uffff]|\n\n| {2,}\n|\w+:\S|$), uses \u00c0-\uffff rather than \x80-\xBF\xC3-\xFF,
	// but that only works in utf16; we have to match utf8 byte values instead
	//no clue why it starts at c0 rather than 80, either, but we need to follow that so shrug and Â© are parsed properly
	// (original also rejects U+00A0 NO-BREAK SPACE, but nothing we're interested in uses that, so it's okay)
	std::regex re_text{R"([\s\S]+?(?=[^0-9A-Za-z\s\x80-\xBF\xC3-\xFF]|\n\n| {2,}\n|\w+:\S|$))"};
	
	//nonexistent emoji restart the parser after the initial colon
	// [^:]+ instead of [\w+-]+ would be fine, this is more a speedhack than anything else
	//nonexistent skin tones, like :ok_hand::skin-tone-8: and :poop::skin-tone-2:, aren't retried without the skin tone,
	// they just render as ":ok_hand::skin-tone-8:" and ":poop:[pink box]"
	std::regex re_emoji{R"((:[\w+-]+?(?:::skin-tone-\d)?:))"};
	//https://discordapp.com/developers/docs/reference#message-formatting
	//not sure if this is correct for emoji, hard to test when server censors my posts.
	//but on the other hand, it'll censor any situation where I'm inaccurate
	std::regex re_external{R"(<(@[&!]?\d+|#\d+|a?:\w+:\d+)>)"};
	
	discord_format_impl(discord_emoji* emoji,
	                    function<void(array<span>& out, const span& fmt, cstring content)> cb_external,
	                    uint32_t spoiler_col) :
	          emoji(emoji), cb_external(cb_external), spoiler_col(spoiler_col) {}
	
	discord_emoji* emoji;
	function<void(array<span>& out, const span& fmt, cstring content)> cb_external;
	uint32_t spoiler_col;
	
	static bool match(const std::regex& re, std::cmatch& m, cstring& last_match, const char * text, const char * textend)
	{
		if (std::regex_search(text, textend, m, re, std::regex_constants::match_continuous))
		{
			last_match = make(m[0].first, m[0].second);
			if (!last_match)
			{
				debug_or_print();
				last_match = "\n";
			}
			return true;
		}
		return false;
	}
	
	static void start_blocklevel(array<span>& out, const span& fmt)
	{
		bool has_lf = true;
		for (ssize_t i=out.size()-1;i>=0;i--)
		{
			cstring it = out[i].text;
			if (it)
			{
				has_lf = (it[it.length()-1] == '\n');
				break;
			}
		}
		if (!has_lf)
			out.append(fmt).text = "\n"; // simulate this one being a block-level element
	}
	
	static bool can_precede_quote(cstring last_match)
	{
		const uint8_t * start = last_match.bytes().ptr();
		const uint8_t * at = start + last_match.length();
		while (at > start && at[-1] == ' ') at--;
		return (at > start && at[-1] == '\n');
	}
	
	//Appends to 'out'. If 'in' starts with a block boundary, does not add \n to out, even if out initially ends with non-linebreak.
	//Mangles 'in'.
	static void flatten_blocks(array<span>& out, arrayvieww<span> in)
	{
		size_t outstart = out.size();
		for (size_t n=0;n<in.size();n++)
		{
			if (!in[n].text) continue; // discard blank outputs, so it's easy to find the last character
			if (in[n].text == "\r")
			{
				if (out.size() == outstart) // block boundary at start
					continue;
				if (n == in.size()-1) // block boundary at end
					continue;
				if (in[n+1].text == "\r") // next one is a block (if in ends with two block boundaries, shouldn't be \n)
					continue;
				if (out[out.size()-1].text.endswith("\n")) // block boundary after linebreak
					continue;
				in[n].text = "\n";
			}
			out.append(std::move(in[n]));
		}
	}
	
#define MATCH(re) match(re, m, last_match, text, textend)
void recurse(array<span>& out, cstring& last_match, bool in_quote, const span& fmt, const char * text, const char * textend) const
{
	while (true)
	{
	next: ;
		if (text == textend) break;
		
		std::cmatch m;
		switch ((uint8_t)*text)
		{
			case '*':
				if (MATCH(re_em_ast))
				{
					span sub = fmt;
					sub.italics = true;
					recurse(out, last_match, in_quote, sub, m[1].first, m[1].second);
					text = m[0].second;
					goto next;
				}
				if (MATCH(re_strong))
				{
					span sub = fmt;
					sub.bold = true;
					recurse(out, last_match, in_quote, sub, m[1].first, m[1].second);
					text = m[0].second;
					goto next;
				}
				break;
			
			case ':':
				if (MATCH(re_emoji))
				{
					if (emoji->insert(out, fmt, make(m[1].first, m[1].second)))
					{
						text = m[0].second;
						goto next;
					}
				}
				break;
			
			case '<':
				if (MATCH(re_autolink))
				{
					span& sp = out.append(fmt);
					sp.text = make(m[1].first, m[1].second);
					sp.hyperlink = (sp.text.istartswith("http://") || sp.text.istartswith("https://")); // yes, this is case insensitive
					if (sp.hyperlink)
						sp.text = sanitize_link(std::move(sp.text));
					text = m[0].second;
					goto next;
				}
				if (MATCH(re_external))
				{
					cb_external(out, fmt, make(m[1].first, m[1].second));
					text = m[0].second;
					goto next;
				}
				break;
			
			case ' ':
			case '>':
			{
				bool can_quote = (!in_quote && can_precede_quote(last_match));
				
				bool is_line;
				if (can_quote && MATCH(re_linequote))
				{
					is_line = true;
					goto quote_common;
				}
				if (can_quote && MATCH(re_blockquote))
				{
					is_line = false;
				quote_common:
					out.append(fmt).text = "\r";
					
					array<uint8_t> newcontent;
					cstring content;
					if (is_line)
					{
						newcontent.resize(m[0].second - m[0].first);
						uint8_t* end = std::regex_replace(newcontent.ptr(), m[0].first, m[0].second, re_linequote_replace, "$1");
						content = newcontent.slice(0, end-newcontent.ptr());
					}
					else
					{
						size_t skip = 0;
						while (m[0].first[skip] == ' ') skip++;
						skip += strlen(">>> ");
						content = make(m[0].first + skip, m[0].second);
					}
					
					array<span> qspans;
					const char * contentstart = (char*)content.bytes().ptr();
					recurse(qspans, last_match, true, fmt, contentstart, contentstart + content.length());
					text = m[0].second;
					
					// last_match points into a local variable, replace it before it's deallocated
					last_match = can_precede_quote(last_match) ? "\n" : "";
					
					size_t outstart = out.size();
					if (qspans.size() && qspans[qspans.size()-1].text.endswith("\n"))
					{
						qspans[qspans.size()-1].text = qspans[qspans.size()-1].text.substr(0, ~1);
					}
					out.append().text = "> "; // TODO: decide on a better formatting
					flatten_blocks(out, qspans);
					for (size_t i=outstart;i<out.size();i++)
					{
						size_t pos = out[i].text.indexof("\n");
						if (pos != (size_t)-1)
						{
							out.insert(i+1, span()).text = "> ";
							span tmp = out[i]; // don't inline into the below, inserting invalidates the reference out[i]
							out.insert(i+2, std::move(tmp));
							out[i].text = out[i].text.substr(0, pos+1);
							out[i+2].text = out[i+2].text.substr(pos+1, ~0);
						}
					}
					
					out.append(fmt).text = "\r";
					goto next;
				}
				break;
			}
			
			case '@': // I have @here/@everyone muted, no reason to parse them
				break; // doesn't even cause misparsing of anything else, neither @here nor @everyone end with a prefix of http or steam
			
			case '\\':
				if (MATCH(re_escape))
				{
					out.append(fmt).text = make(m[1].first, m[1].second);
					text = m[0].second;
					goto next;
				}
				break;
			
			case '_':
				if (MATCH(re_em_u))
				{
					span sub = fmt;
					sub.italics = true;
					recurse(out, last_match, in_quote, sub, m[1].first, m[1].second);
					text = m[0].second;
					goto next;
				}
				if (MATCH(re_u))
				{
					span sub = fmt;
					sub.underline = true;
					recurse(out, last_match, in_quote, sub, m[1].first, m[1].second);
					text = m[0].second;
					goto next;
				}
				break;
			
			case '`':
				if (MATCH(re_fence))
				{
					out.append(fmt).text = "\r";
					
					span& sp = out.append(fmt);
					sp.monospace = true;
					sp.text = make(m[1].first, m[1].second);
					text = m[0].second;
					
					out.append(fmt).text = "\r";
					goto next;
				}
				if (MATCH(re_inlineCode))
				{
					span& sp = out.append(fmt);
					sp.monospace = true;
					sp.text = make(m[2].first, m[2].second);
					text = m[0].second;
					goto next;
				}
				break;
			
			case 'h': case 's':
				if (MATCH(re_url))
				{
					span& sp = out.append(fmt);
					
					int nopen = 0;
					int nclose = 0;
					
					for (const char * iter = m[1].first; iter < m[1].second; iter++)
					{
						if (*iter == '(') nopen++;
						if (*iter == ')') nclose++;
						else nclose = 0; // yes, it's asymmetric
					}
					
					sp.text = make(m[1].first, m[1].second - (nclose>nopen ? 1 : 0));
					sp.hyperlink = (sp.text[0] == 'h');
					if (sp.hyperlink)
						sp.text = sanitize_link(std::move(sp.text));
					text = m[0].second - (nclose>nopen ? 1 : 0);
					goto next;
				}
				break;
			
			case '|':
				if (MATCH(re_spoiler))
				{
					span sub = fmt;
					sub.fgcol = spoiler_col;
					sub.bgcol = spoiler_col;
					recurse(out, last_match, in_quote, sub, m[1].first, m[1].second);
					text = m[0].second;
					goto next;
				}
				break;
			
			case '~':
				if (MATCH(re_del))
				{
					span sub = fmt;
					sub.strike = true;
					recurse(out, last_match, in_quote, sub, m[1].first, m[1].second);
					text = m[0].second;
					goto next;
				}
				break;
			
			static const char * const shrug = R"(Â¯\_(ãƒ„)_/Â¯)"; // no reason to make this a regex
			case 0xC2: // first half of Â¯ in utf8
				if ((size_t)(textend-text) >= strlen(shrug) && !memcmp(text, shrug, strlen(shrug)))
				{
					out.append(fmt).text = shrug;
					text += strlen(shrug);
					last_match = shrug;
					goto next;
				}
				break;
		}
		if (text == textend) break;
		
		MATCH(re_text); // always matches
		text = m[0].second;
		
		string newtext_s = emoji->translate(make(m[0].first, m[0].second));
		const char * newtext = newtext_s;
		const char * newtextend = newtext + newtext_s.length();
		
		while (std::regex_search(newtext, newtextend, m, re_emoji)) // not match_continuous
		{
			out.append(fmt).text = make(newtext, m[0].first);
			if (emoji->insert(out, fmt, make(m[1].first, m[1].second)))
				newtext = m[0].second;
			else
			{
				out.append(fmt).text = ":";
				newtext = m[0].first+1;
			}
		}
		out.append(fmt).text = make(newtext, newtextend);
	}
}
#undef MATCH

void parse(array<span>& out, const span& fmt, cstring text) const override
{
	string newtext = text.replace("\r\n","\n")
	                     .replace("\r","\n")
	                     .replace("\f","") // it discards form feed; commit message says it's supposed to become \n, but it's typoed
	                     .replace("\t","    "); // https://github.com/discordapp/simple-markdown/commit/6ee0e9c666
	
	cstring last_match = "\n";
	array<span> spans;
	recurse(spans, last_match, false, fmt, (char*)newtext.bytes().ptr(), (char*)newtext.bytes().ptr() + newtext.length());
	flatten_blocks(out, spans);
}

string unparse_irc(cstring in) const override
{
	//TODO
	return in;
}
};
}


discord_format* discord_format::create(discord_emoji* emoji,
                                       function<void(array<span>& out, const span& fmt, cstring content)> cb_external,
                                       uint32_t spoiler_col)
{
	return new discord_format_impl(emoji, cb_external, spoiler_col);
}

#ifdef ARLIB_TEST
class discord_emoji_test : public discord_emoji {
public:
	bool insert(array<span>& out, const span& fmt, cstring name) const override
	{
		if (name == ":copyright:" || name == ":tm:")
		{
			out.append(fmt).text = (name[1]=='c' ? "Â©" : "â„¢");
			return true;
		}
		
		if (name == ":snow2:" || name == ":skin-tone-3:" || name == ":snow2::skin-tone-3:" || name == ":danish:" || name == ":poop:")
		{
			span sp = { name };
			sp.fgcol = 2;
			out.append(sp);
			return true;
		}
		
		return false;
	}
	string translate(cstring in) const override
	{
		return in.replace("Ã¸Ã¸",":danish:").replace("â˜ƒ",":snow2:").replace("ðŸ’©",":poop:").replace("Â©",":copyright:").replace("â„¢",":tm:");
	}
	// the tests don't need these, but they're pure virtual and must exist
	// they don't need to do anything useful, tests won't use them
	arrayview<cstring> names() const override { abort(); }
	textview::image* pick_avatar(uint64_t seed) const override { abort(); }
};

static void external_cb(array<span>& out, const span& fmt, cstring content)
{
	span sp = { content };
	sp.fgcol = 1;
	out.append(sp);
}
static discord_format* get_formatter()
{
	//cache this object, its constructor is slow under valgrind
	static discord_emoji_test emoji; // kinda silly to have an object with no members (except vtable), but interface needs that
	static discord_format_impl format(&emoji, external_cb, 0x123);
	return &format;
}

static bool fmteq(span& a, span& b)
{
	if (a.fgcol != (uint32_t)-1)
		return a.fgcol == b.fgcol;
	
	if ((bool)a.img != (bool)b.img) return false;
	if (a.hidden != b.hidden) return false;
	if (a.bold != b.bold) return false;
	if (a.underline != b.underline) return false;
	if (a.italics != b.italics) return false;
	if (a.strike != b.strike) return false;
	if (a.monospace != b.monospace) return false;
	if (a.hyperlink != b.hyperlink) return false;
	if (a.fgcol != b.fgcol) return false;
	if (a.bgcol != b.bgcol) return false;
	return true;
}
static void flatten(array<span>& spans, bool drop_200b = false)
{
	//eat empty first, in case strikethrough emits identical spans with empty ones between
	for (size_t i=0;i<spans.size();i++)
	{
		if (drop_200b)
			spans[i].text.replace("\xE2\x80\x8B", "");
		if (spans[i].fgcol == 0x123) // wipe fgcol for spoilers, we only need bgcol
			spans[i].fgcol = (uint32_t)-1;
		if (spans[i].text == "") // keep this last, accessing spans[-1] doesn't help too much
			spans.remove(i--);
	}
	for (int i=0;i<(int)spans.size()-1;i++)
	{
		if (fmteq(spans[i],spans[i+1]) && spans[i].fgcol == (uint32_t)-1)
		{
			spans[i].text += spans[i+1].text;
			spans.remove(i+1);
			i--;
		}
	}
	for (size_t i=0;i<spans.size();i++)
	{
		spans[i].text = spans[i].text.replace("        \n","\n")
		                             .replace("    \n","\n")
		                             .replace("  \n","\n")
		                             .replace(" \n","\n");
	}
}
static string span_fmt(int idx, const span& sp)
{
	string ret;
	if (idx >= 0) ret += tostring(idx)+":";
	if (sp.fgcol != (uint32_t)-1) ret += "%"+tostring(sp.fgcol);
	else
	{
		if (sp.bold) ret += "%B";
		if (sp.italics) ret += "%I"; // alphabetical sorting is easy to remember, anything else would yield typoed tests
		if (sp.bgcol == 0x123) ret += "%H"; // even though it yields silly results, like link between bold and underline
		if (sp.hyperlink) ret += "%L";
		if (sp.monospace) ret += "%M";
		if (sp.strike) ret += "%S";
		if (sp.underline) ret += "%U";
	}
	return ret + sp.text;
}
static string spans_fmt(array<span>& spans)
{
	flatten(spans);
	return spans.select([](const span& sp)->string { return span_fmt(-1, sp); }).as_array().join("!");
}

static void test1f(cstring input, cstring expected)
{
	testctx(input) {
		array<span> spans;
		get_formatter()->parse(spans, span(), input);
		for (span& sp : spans)
		{
			assert(sp.text.isutf8());
			assert(!sp.text.contains(string::nul()));
		}
		
		assert_eq(spans_fmt(spans), expected);
	}
}

#define test1(input, expected) testcall(test1f(input, expected))
test("Discord formatting - preprocessor", "", "")
{
	test1("a\ta\r\nb\f\f\fc", "a    a\nbc");
}
test("Discord formatting - nesting", "", "")
{
	test1("b*c**ppp___p_p__pg***e", "b!%Ic!%B%Ippp!%B%I%U_p_p!%B%Ipg!e");
}
test("Discord formatting - underscores", "", "")
{
	test1("e_e__e___e", "e_e!%Ue_!e");
	test1("e__e_e___e", "e!%Ue!%I%Ue!e");
	test1("e_e___e__e", "e_e!%U_e!e");
	test1("e__e___e_e", "e!%Ue_!e_e");
	test1("e___e__e_e", "e!%U_e!e_e");
	test1("e___e_e__e", "e!%U_e_e!e");
	test1("____", "%I__");
	test1("___a__", "%U_a");
	test1("_ a_a", "_ a_a");
}
test("Discord formatting - asterisks", "", "")
{
	test1("e*e**e***e", "e!%Ie!%B%Ie!e");
	test1("e**e*e***e", "e!%Be!%B%Ie!e");
	test1("e*e***e**e", "e!%Ie**!e**e");
	test1("e**e***e*e", "e!%Be*!e*e");
	test1("e***e**e*e", "e!%B%Ie!%Ie!e");
	test1("e***e*e**e", "e!%I**e!e**e");
	test1("****", "%I**");
	test1("***a**", "%B*a");
	test1("a *aa **aaa***", "a !%Iaa !%B%Iaaa");
	test1("* a*", "* a*");
	test1("*a *", "*a *");
	test1("*a**\n****", "*a!%B\n**");
}
test("Discord formatting - tilde", "", "")
{
	test1("~~~~~~~~~~~~~~~~~~~~~", "%S~~~~!~");
	test1("~~ ~~", "%S ");
	test1("~~ ~~_", "~~ ~~_");
	test1("~~~a~~~", "%S~a!~");
}
test("Discord formatting - quotes", "", "")
{
	test1("> a", "> a"); // my chosen rendering of quotes is 'prefix each line with >', which is identical to the markdown
	test1(">> a", ">> a"); // testing is done mostly with >>>, partially with formatting of the >s
	test1(">>> a", "> a");
	test1(">>>> a", ">>>> a");
	test1("> a\nb", "> a\nb");
	test1("> a\n   b", "> a\n   b");
	test1(">> a\nb", ">> a\nb");
	test1(">>> a\nb", "> a\n> b");
	test1(">>> a\n> b", "> a\n> > b"); // no nested quotes allowed
	test1(">>> a\n>>> b", "> a\n> >>> b");
	test1(">>>> a\nb", ">>>> a\nb");
	test1("> a\n> b\n> c", "> a\n> b\n> c");
	test1("> a\n > b\n  > c", "> a\n> b\n> c");
	test1("test\n> a", "test\n> a");
	test1("test\n > a", "test\n\n> a");
	test1("test\n > a\n > b", "test\n\n> a\n> b");
	test1("**>>> a**", "%B>>> a");
	test1("a > b\nc", "a > b\nc");
	test1("a >>> b\nc", "a >>> b\nc");
	test1(">>>", ">>>");
	test1(">>> ", "> "); // don't paste these into discord; use **a\n>>> ** instead, or it'll eat your trailing whitespace
	test1(">>>  ", ">  ");
	test1("```\ntest\n```>>> test", "%Mtest!\n>>> test");
	test1("```\ntest```\n>>> test", "%Mtest!\n\n> test");
	test1("**test**>>> test", "%Btest!>>> test");
	test1("**test**\n>>> test", "%Btest!\n> test");
	test1("**test\n**>>> test", "%Btest\n!> test");
	test1("**a\n> b**", "%Ba\n!> !%Bb");
	test1("**> a\n**>>> b", "%B> a\n!> b");
	test1("**>>> a\n**>>> b", "%B>>> a\n!> b");
	test1("**>>> test\ntest\n**test", "%B>>> test\ntest\n!test");
	test1("**a\n>>> a**", "%Ba\n!> !%Ba");
	test1("**a\n>>> a\n**", "%Ba\n!> !%Ba");
	test1("**a\n>>> a__\n__**", "%Ba\n!> !%Ba");
	test1("**a\n>>> a\n **", "%Ba\n!> !%Ba\n!> !%B ");
	test1("**a\n>>> a\n**>>> a", "%Ba\n!> !%Ba!\n> a");
	test1("**a\n>>> a**>>> a", "%Ba\n!> !%Ba\n!>>> a");
	test1("> **a\n>\n> b**", "> **a\n>\n> b**");
	test1("> **a\n> \n> b**", "> !%Ba\n!> !%B\n!> !%Bb");
	test1("**test\n>>> test\ntest\n**test", "%Btest\n!> !%Btest\n!> !%Btest\n!test");
	test1("**test\n>>> test\ntest**test", "%Btest\n!> !%Btest\n!> !%Btest\n!test");
	test1("> `a\na`", "> `a\na`");
	test1("> `a\n> a`", "> !%Ma\n!> !%Ma");
	test1("> `a\n>  a`", "> !%Ma\n!> !%M a");
	test1("> ```a```", "> !%Ma");
	test1("**a\n** > test", "%Ba\n!> test");
	test1("**a\n** >>> test", "%Ba\n!> test");
	test1("**a\n** >     test", "%Ba\n!>     test");
	test1("**a\n** >>>     test", "%Ba\n!>     test");
	test1("aâ˜ƒa\n>>> a", "a!%2:snow2:!a\n> a");
	test1("Â¯\\_(ãƒ„)_/Â¯>>> a", "Â¯\\_(ãƒ„)_/Â¯>>> a");
}
test("Discord formatting - shrug", "", "")
{
	test1("Â¯\\_(ãƒ„)_/Â¯", "Â¯\\_(ãƒ„)_/Â¯");
	test1("Â¯\\_(ãƒ„)_/", "Â¯_(ãƒ„)_/");
	test1("\\Â¯\\_(ãƒ„)_/Â¯", "Â¯_(ãƒ„)_/Â¯");
	test1("_Â¯\\_(ãƒ„)_/Â¯_", "%IÂ¯_(ãƒ„)!/Â¯_");
	test1("Â¯\\_(ãƒ„)_/Â¯_", "Â¯\\_(ãƒ„)_/Â¯_");
	test1("\\Â¯\\_(ãƒ„)_/Â¯ _Â¯\\_(ãƒ„)_/Â¯_", "Â¯_(ãƒ„)!%I/Â¯ !Â¯\\_(ãƒ„)_/Â¯_");
	test1("aaaÂ¯\\_(ãƒ„)_/Â¯", "aaaÂ¯\\_(ãƒ„)_/Â¯");
}
test("Discord formatting - escapes", "", "")
{
	test1("\\a", "\\a");
	test1("\\:danish:", ":danish:");
	test1("\\\\:danish:", "\\!%2:danish:");
	test1("\\ ", "\\ ");
	test1("\\ðŸ’©", "ðŸ’©");
}
test("Discord formatting - textual emoji", "", "")
{
	test1(":snow2: :skin-tone-3: :snow2::skin-tone-3:", "%2:snow2:! !%2:skin-tone-3:! !%2:snow2::skin-tone-3:");
	test1(":danish: :danish::skin-tone-3:", "%2:danish:! :danish:!%2:skin-tone-3:");
	test1(":danish:danish: :aaaa:danish:", "%2:danish:!danish: :aaaa!%2:danish:");
	test1("**:danish:**:snow2:", "%2:danish:!%2:snow2:");
	test1(":snow2::skin-tone-3: :snow2::skin-tone-5: :snow2::skin-tone-42:",
	      "%2:snow2::skin-tone-3:! :snow2::skin-tone-5: !%2:snow2:!:skin-tone-42:");
	test1(":snow2::skin-tone-3:danish: :snow2::skin-tone-8:danish:",
	      "%2:snow2::skin-tone-3:!danish: :snow2::skin-tone-8!%2:danish:");
}
test("Discord formatting - mentions", "", "")
{
	test1("<@!123> <#123> <@&123> <@123 <@!123 <@&123 <#123 <@> <@!> <@&> <#>",
	      "%1@!123! !%1#123! !%1@&123! <@123 <@!123 <@&123 <#123 <@> <@!> <@&> <#>");
}
test("Discord formatting - custom emoji", "", "")
{
	test1("<:danish:123> <:danish:> <::123> <:danish:123 <a:danish:123> <a:danish:> <a::123> <a:danish:123",
	      "%1:danish:123! <!%2:danish:!> <::123> <!%2:danish:!123 !%1a:danish:123! <a!%2:danish:!> <a::123> <a!%2:danish:!123");
}
test("Discord formatting - Unicode emoji", "", "")
{
	test1("â˜ƒ:skin-tone-3:", "%2:snow2:!%2:skin-tone-3:");
	test1("Ã¸Ã¸ :Ã¸Ã¸: Ã¸Ã¸:/ Ã¸Ã¸Ã¸Ã¸Ã¸Ã¸Ã¸", "%2:danish:! :!%2:danish:!: !%2:danish:!:/ !%2:danish:!%2:danish:!%2:danish:!Ã¸");
	test1(":danishâ˜ƒ :aaaâ˜ƒ", "%2:danish:!snow2: :aaa!%2:snow2:");
	test1(":copyright: :snow2:copyright: :snow2Â© **:copyright: Â©** :copyright:snow2:", "Â© !%2:snow2:!copyright: :snow2Â© !%BÂ© Â©! Â©snow2:");
	test1(":tm: :snow2:tm: :snow2â„¢ **:tm: â„¢** :tm:snow2:", "â„¢ !%2:snow2:!tm: !%2:snow2:!tm: !%Bâ„¢ â„¢! â„¢snow2:");
	test1("Â©", "Â©");
}
test("Discord formatting - links", "", "")
{
	test1("<http://example.com> <https://example.com>", "%Lhttp://example.com! !%Lhttps://example.com");
	test1("<https://ex ample.com> <https:example.com>", "<!%Lhttps://ex! ample.com> <https:example.com>");
	test1("<HTTP://EXAMPLE.COM>", "%LHTTP://EXAMPLE.COM");
	test1("http://aaa(foo) (http://aaa) (http://aaa(foo))", "%Lhttp://aaa(foo)! (!%Lhttp://aaa!) (!%Lhttp://aaa(foo)!)");
	test1("http://aaa. http://aaa? http:// http://a http://ab", "%Lhttp://aaa!. !%Lhttp://aaa?! http:// http://a !%Lhttp://ab");
	test1("(http://a) http://â˜ƒ http://ðŸ’© aahttp://ggg", "(!%Lhttp://a!) http://!%2:snow2:! !%Lhttp://%F0%9F%92%A9! aa!%Lhttp://ggg");
	test1("http://exampl\xD0\xB5.com <http://exampl\xD0\xB5.com>", "%Lhttp://exampl%D0%B5.com! !%Lhttp://exampl%D0%B5.com");
}
test("Discord formatting - backticks", "", "")
{
	test1("````\nh```", "%M`\nh");
	test1("````\nh\n\n\n```", "%M`\nh");
	test1("``````\n`   `\n```", "%M```\n`   `");
	test1("```a\nb\n```", "%Mb");
	test1("```eee\n```", "%Meee");
	test1("```\n````", "%M`");
	test1("```\n```", "%M\n");
	test1("```rrr\n```hhh\n```", "%M```hhh");
	test1("```AsciiDoc\r\n210b aaa```", "%M210b aaa"); // language should be removed and ignored (syntax highlighting not supported)
	test1("```C++\nint main()```", "%MC++\nint main()");
	test1("```AsciiDoc \n210b aaa```", "%MAsciiDoc\n210b aaa");
	test1("a```ee```", "a\n!%Mee");
	test1("```ee```a", "%Mee!\na");
	test1("```a``````a```", "%Ma!\n!%Ma");
	test1("```a```a```a```", "%Ma!\na\n!%Ma");
	test1("```a``` ```a```", "%Ma!\n\n!%Ma");
	test1("```a```\n```a```", "%Ma!\n\n!%Ma");
	test1("a ` a ` a", "a !%Ma! a");
	test1("` `", "%M ");
	test1("`a`\n```a```", "%Ma!\n!%Ma");
	test1("```a```\n`a`", "%Ma!\n\n!%Ma"); // yes, this should have double linebreak
	test1("````a````", "%M`a!\n`");
	test1("a**```b```**", "a!%B\n!%B%Mb");
	test1("**```a```**b", "%B%Ma!%B\n!b");
}
test("Discord formatting - spoilers", "", "")
{
	test1("||aaa||", "%Haaa");
	test1("|| aaa ||", "%H aaa ");
	test1("aa || bb || cc", "aa !%H bb ! cc");
	test1("aa ||bb|| cc", "aa !%Hbb! cc");
	test1("aa|| bb ||cc", "aa!%H bb !cc");
	test1("aa||bb||cc", "aa!%Hbb!cc");
	test1("||||", "||||");
	test1("|||||", "%H|");
	test1("||||||||||||||||||||", "%H||||");
	test1("aa **||bb||** cc ||**dd**|| ee", "aa !%B%Hbb! cc !%B%Hdd! ee");
}
test("Discord formatting - weird spaces", "", "")
{
	//using U+1680 OGHAM SPACE MARK since it's visually distinguishable from normal space
	test1("\\áš€", "\\áš€");
	test1("http://derpáš€derp", "%Lhttp://derp!áš€derp");
	test1("<http://derpáš€derp>", "%Lhttp://derp%E1%9A%80derp");
	test1("*áš€a*", "*áš€a*");
	test1("*aáš€*", "*aáš€*");
	test1("`áš€áš€`", "%Máš€");
	test1("` áš€`", "%Máš€");
	test1("`  áš€`", "%Máš€");
	test1("aa\n\nbb", "aa\n\nbb"); // \n is whitespace too
}
#undef test1

static void irc_parse(array<span>& out, cstring irc)
{
	span next;
	
	size_t n=0;
	while (n<irc.length())
	{
		uint8_t ch = irc[n++];
		if (LIKELY(ch >= 32)) { next.text += ch; continue; }
		
		out.append(next);
		next.text = "";
		
		if(0);
		else if (ch == 0x02) next.bold ^= 1;
		else if (ch == 0x1D) next.italics ^= 1;
		else if (ch == 0x1F) next.underline ^= 1;
		else if (ch == 0x1E) next.strike ^= 1;
		else if (ch == 0x11) next.monospace ^= 1;
		else if (ch == 0x0F) next = span();
		else next.text += ch;
	}
	out.append(next);
}
static void test1u(cstring irc)
{
	array<span> expected;
	array<span> actual;
	irc_parse(expected, irc);
	get_formatter()->parse(actual, span(), get_formatter()->unparse_irc(irc));
	for (span& sp : actual)
	{
		sp.hyperlink = false;
	}
	
	assert_eq(spans_fmt(actual), spans_fmt(expected));
}

#define test1(irc) testcall(test1u(irc))
test("Discord unformatting", "", "")
{
	test1("aabb");
	test1("aa\x02zb");
	test1("aa\x02z\x02z");
	test1("aa\x02z**b\x02y");
	test1("aa\x1Dz**b\x1Dy");
	test1("xx\x02z\x1Fyy");
	test1("xx\x02z\x1Fyy");
	test1("xx\x02z\x1Fy\x02yw\x1Fww");
	test1("xx\x02z\x1Fy\x02y\x02w\x1Fw\x02w");
	test1("\x11`````````"); // ` should become `` ` ``, though `` must become `` `<200B>` ``
	test1("if foo > bar\n{");
	
	const char * tokens[] = { "*", "_", "~~", "`", "**", "__", "http://", "<", ">", "||", ">>>",
	                          " ", "x", "1", " ", "aaaaa", "123", "\n", "eee", "42",
	                          "\x02", "\x0F", "\x11", "\x1D", "\x1E", "\x1F",
	                        };
	
	for (int i=0;i<100000;i++)
	{
		random_t rand;
		rand.seed(i);
		string test;
		for (int j=0;j<100;j++)
			test += tokens[rand()%ARRAY_SIZE(tokens)];
		test1(test);
	}
	
	assert(!get_formatter()->unparse_irc("@here").contains("@here")); // ->parse ignores this, so must test separately
	assert(!get_formatter()->unparse_irc("@everyone").contains("@everyone")); // output should contain @<200B>everyone
}
#endif
}
