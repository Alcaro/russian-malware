#include "russian.h"

// https://matrix.org/docs/spec/client_server/latest

#define MINIZ_HEADER_FILE_ONLY
#include "arlib/deps/miniz.c"

// TODO: automatically clean up
// - no-longer-present users
// - no-longer-present channels
//    (I think these two can be done with events only, except I'll probably need to keep the objects around until program reboot)

// TODO: test if presense stuff works
// {"next_batch":"s219_44066_0_61_58_2_1_40_1","presence":{"events":[{"type":"m.presence","sender":"@user:matrix.org",
//    "content":{"presence":"online","last_active_ago":3,"currently_active":true}}]},
//   "device_one_time_keys_count":{"signed_curve25519":0},"org.matrix.msc2732.device_unused_fallback_key_types":[]}

// message edits look like
// {"type":"m.room.message","sender":"@user:matrix.org","content":{"msgtype":"m.text","body":"a"},"origin_server_ts":1633012457634,"unsigned":{"age":42},"event_id":"$JRjEGgiBHksO1XEUcfae5Vbk03BtrQi9yE-UUruKEgo"}
// {"type":"m.room.message","sender":"@user:matrix.org","content":{"m.new_content":{"msgtype":"m.text","body":"b"},"m.relates_to":{"rel_type":"m.replace","event_id":"$JRjEGgiBHksO1XEUcfae5Vbk03BtrQi9yE-UUruKEgo"},"msgtype":"m.text","body":" * b"},"origin_server_ts":1633012461455,"unsigned":{"age":45},"event_id":"$1umYZpQIA0yUtZ6N_6oRjTkYrHOzpshAC_tyFVFy3LA"}
// or, if both message and edit are fetched simultaneously,
// {"type":"m.room.message","sender":"@user:matrix.org","content":{"msgtype":"m.text","body":"b"},"origin_server_ts":1633012457634,"unsigned":{"age":527056,"m.relations":{"m.replace":{"event_id":"$1umYZpQIA0yUtZ6N_6oRjTkYrHOzpshAC_tyFVFy3LA","origin_server_ts":1633012461455,"sender":"@user:matrix.org"}}},"event_id":"$JRjEGgiBHksO1XEUcfae5Vbk03BtrQi9yE-UUruKEgo","user_id":"@user:matrix.org","age":527056}
// {"type":"m.room.message","sender":"@user:matrix.org","content":{"m.new_content":{"msgtype":"m.text","body":"b"},"m.relates_to":{"rel_type":"m.replace","event_id":"$JRjEGgiBHksO1XEUcfae5Vbk03BtrQi9yE-UUruKEgo"},"msgtype":"m.text","body":" * b"},"origin_server_ts":1633012461455,"unsigned":{"age":523235},"event_id":"$1umYZpQIA0yUtZ6N_6oRjTkYrHOzpshAC_tyFVFy3LA","user_id":"@user:matrix.org","age":523235}

namespace russian {
namespace {

class matrix : public protocol {
public:

autoptr<russian::group> m_root; // keep this above 'channels', destructor order is important

HTTP m_http;
// Matrix uses long polling for event delivery. Sounds insane at first, but the server supports Keep-Alive, so the data on the wire
//  ends up looking like any other protocol's ping/pong scheme, just with an odd framing scheme (no worse than DNS over HTTP).
// This also means sessions are not a thing in the protocol. There's no such thing as online or offline;
//  no login procedure when opening a websocket, no large chunks of stuff I already know every time I start the program.
// But I should still have two separate HTTP objects, so message sending doesn't get stuck behind a poll.
HTTP m_http_poll;

socks5 m_proxy;

file m_rawlog;

DECL_G_TIMER(m_retry, matrix);

bool m_online = false;

string m_server; // https://matrix-client.matrix.org (can contain port number)
string m_token; // AAA0AA0aaAA0aA0aAAaaa0A0.aAAAAaaaaaAAAAaaAa
string m_sync_next; // s1234567890_123456789_1234567_1234567890_123456789_1234567_123456789_1234567890_123456

string m_cachename;

// Used only during login.
string m_login_homeserver;
string m_login_username;
string m_login_password;

typedef uint64_t uid_t;
uid_t m_max_uid = 0;

struct message {
	uid_t author;
	time_t at;
	string id;
	// The HTML is known to be well behaved:
	// - Every <, > and & is part of a HTML tag
	// - Tags always close in the right order (except <img>, <hr> and <br>, which don't have close tags)
	// - Only a small set of tags exist:
	//    font, del, h1, h2, h3, h4, h5, h6, blockquote, p, a, ul, ol, sup, sub, li, b, i, u,
	//    strong, em, strike, code, hr, br, div, table, thead, tbody, tr, th, td, caption, pre, span, img
	// - Only a small set of attributes exist:
	//    <font data-mx-bg-color="#ff0000" data-mx-color="#ff0000">
	//    <span data-mx-bg-color="#ff0000" data-mx-color="#ff0000">
	//    <a name="" target="" href=""> (href must start with one of http://, https://, mailto:, magnet:, ftp://)
	//    <img width="16" height="16" alt="" title="" src=""> (src must start with mxc://)
	//      mxc://matrix.org/ascERGshawAWawugaAcauga -> /_matrix/media/r0/download/matrix.org/ascERGshawAWawugaAcauga
	//    <ol start="100">
	//    <code class="language-">
	//    Other tags can not have attributes.
	// - Max 100 tags can be nested.
	// If the server sends something unexpected, or doesn't send any HTML, this will instead be htmlentities(plaintext).
	string html;
	
	template<typename T> void serialize(T& s)
	{
		s.items("author", author, "at", at, "id", id, "html", html);
	}
};

struct user {
	string username; // @alice:matrix.org
	string display_name; // Alice Margatroid
	string avatar_url; // includes mxc://
	bytearray avatar_bytes;
	
	bool online = false;
	bool online_watch_warned = false;
	
	template<typename T> void serialize(T& s)
	{
		s.items("username", username, "display_name", display_name,
		        "avatar_url", avatar_url, "avatar_bytes", ser_base64(avatar_bytes),
		        "online", online);
		// ignore online_watch_warned, it should reset on client restart
	}
};

struct channel {
	string id; // !AaaAAaAAaaaAAaAaaa:matrix.org
	string public_alias; // #test:matrix.org
	string name; // Test room
	uid_t dm_to = 0;
	array<message> messages;
	set<uid_t> members;
	
	autoptr<russian::channel> host;
	
	template<typename T> void serialize(T& s)
	{
		s.items(
			"public_alias", public_alias,
			"dm_to", ser_include_if(dm_to!=0, dm_to),
			"messages", messages,
			"members", members);
	}
	
	cstring display_name(matrix* parent, int* sort_key = nullptr)
	{
		int dummy;
		if (!sort_key) sort_key = &dummy;
		*sort_key = (dm_to!=0 ? 0 : 1);
		if (public_alias) return public_alias;
		if (dm_to) return parent->m_users[dm_to].display_name;
		if (name) return name;
		return id;
	}
};

map<uid_t, user> m_users;
map<string, uid_t> m_user_by_name; // key is full username
map<string, channel> m_channels; // key is internal channel ID
array<cstring> m_channel_keys;
array<uid_t> m_online_watches;

string logdate(time_t rawtime)
{
	struct tm * timeinfo = localtime(&rawtime);
	char out[64];
	strftime(out, 64, "[%H:%M:%S]", timeinfo);
	return out;
}
string logdate()
{
	return logdate(time(NULL));
}

void status(time_t at, cstring text, chanbase::importance_t imp = chanbase::imp_status)
{
	span sp[1] = { { text } };
	if (imp == chanbase::imp_highlight) sp[0].fgcol = 0xFF0000;
	m_root->message(imp, at, sp);
}
void status(cstring text, chanbase::importance_t imp = chanbase::imp_status)
{
	status(time(NULL), text, imp);
}

void fatal(cstring text)
{
	span sp[1] = { { text } };
	sp[0].fgcol = 0xFF0000;
	m_root->message(chanbase::imp_highlight, time(NULL), sp);
	m_root->rename("ERROR - Matrix");
	
	m_retry.reset();
	m_http.reset();
	m_http_poll.reset();
}

// Path should be only the part after https://domain/_matrix/client/r0/. For example, "login" would be a fine value.
// Alternatively, if it starts with a slash, it can be the part after https://domain/_matrix, for example "/media/r0/config".
void http_api(cstring method, cstring path, const JSON& json, function<void(HTTP::rsp)> cb)
{
	HTTP::req r;
	if (path[0] == '/') r.url = m_server+"/_matrix"+path; // /_matrix/media/ is usable by clients, but isn't under /client/
	else r.url = m_server+"/_matrix/client/r0/"+path;
	if (method) r.method = method;
	if (m_token) r.headers.append("Authorization: Bearer "+m_token);
	if (json) r.body = json.serialize().bytes();
	if (m_rawlog)
	{
		cstring method = (r.method ? r.method : r.body ? (cstring)"POST" : (cstring)"GET");
		if (r.body.contains('\0') || r.body.size() > 10000)
			m_rawlog.write(logdate()+" << "+method+" "+r.url+" <snip>\n");
		else
			m_rawlog.write(logdate()+" << "+method+" "+r.url+" "+cstring(r.body)+"\n");
	}
	r.flags |= HTTP::req::f_retry; // everything is idempotent in Matrix
	m_http.send(r, cb);
}
void http_api(cstring path, const JSON& json, function<void(HTTP::rsp)> cb)
{
	http_api("", path, json, cb);
}
void http_api(cstring path, function<void(HTTP::rsp)> cb)
{
	JSON json;
	http_api(path, json, cb);
}
void http_log_response(const HTTP::rsp& r)
{
	if (m_rawlog)
		m_rawlog.write(logdate()+" >> "+tostring(r.status)+" "+cstring(r.body)+"\n");
}

void render_message(channel& ch, message& m, bool is_scrollback = false)
{
	user& u = m_users.get(m.author);
	span sp[1] = { "<"+u.display_name+"> "+m.html };
	ch.host->message(is_scrollback ? chanbase::imp_scrollback : chanbase::imp_msg, m.at, sp);
}

void channel_host(channel& ch)
{
	int sort_key;
	cstring name = ch.display_name(this, &sort_key);
	if (!ch.host)
	{
		ch.host = m_root->child(name, chanbase::f_no_scrollback, (void*)(uintptr_t)m_channel_keys.size());
		m_channel_keys.append(ch.id);
		for (message& m : ch.messages.skip(max(0, ch.messages.size()-250)))
			render_message(ch, m, true);
	}
	ch.host->rename(name);
	ch.host->sort_as(sort_key, name);
	ch.host->set_available(m_online);
}

user& user_for(cstring username, uid_t* uidp = NULL)
{
	uid_t uid = m_user_by_name.get_create(username, [this](){ return ++m_max_uid; });
	user& u = m_users.get_create(uid);
	u.username = username;
	if (uidp) *uidp = uid;
	return u;
}

matrix(impl* parent, bmldeserializer& s, cstring name) : protocol(parent, 0),
                                                         m_http(runloop::global()),
                                                         m_http_poll(runloop::global())
{
	m_root = mkgroup(name, chanbase::f_no_logs|chanbase::f_no_users, (void*)(uintptr_t)m_channel_keys.size());
	m_channel_keys.append("");
	
	m_root->set_available(false);
	
	struct tmp_user {
		bool online_watch = false;
		
		void serialize(bmldeserializer& s)
		{
			s.items("watch", online_watch);
		}
	};
	map<string,tmp_user> tmp_users;
	
	string username_full;
	string password;
	string token;
	string rawlog_fname;
	string proxy_addr;
	s.items(
		"username", username_full,
		"cache", m_cachename,
		"password", m_login_password,
		"token", token,
		"rawlog", rawlog_fname,
		"socks5", proxy_addr,
		// can't insert it directly into users, need to load cache first so user IDs remain unique
		"user", [&](bmldeserializer& s, cstring name) { tmp_users.get_create(name).serialize(s); });
	
	if (proxy_addr)
	{
		m_proxy.configure(proxy_addr, runloop::global());
		m_http.wrap_socks(bind_ptr(&socks5::connect, &m_proxy));
		m_http_poll.wrap_socks(bind_ptr(&socks5::connect, &m_proxy));
	}
	
	if (rawlog_fname)
		m_rawlog.open(file::resolve(file::exepath(), rawlog_fname), file::m_replace);
	
	auto parts = REGEX("@([a-z0-9\\-_=./]+):([a-z0-9\\-.\\[:\\]]+)").match(username_full);
	if (!parts) { fatal("Malformed username"); return; }
	m_login_username = parts[1];
	m_login_homeserver = "https://"+parts[2];
	
	jsondeserialize(cstring(inflator::inflate(file::readall(file::resolve(file::exepath(), m_cachename)))),
		[this](jsondeserializer& s)
	{
		process_cache(s);
	});
	
	if (token) m_token = token; // force override, if one was cached
	
	for (auto& pair : m_channels)
	{
		pair.value.id = pair.key;
	}
	for (auto& pair : m_users)
	{
		m_user_by_name.get_create(pair.value.username) = pair.key;
	}
	
	// do this after m_user_by_name is populated, it's easier
	for (auto& pair : tmp_users)
	{
		uid_t uid;
		user& u = user_for(pair.key, &uid);
		if (pair.value.online_watch)
			m_online_watches.append(uid);
	}
status("watch="+tostring_dbg(m_online_watches));
	
	for (auto& pair : m_channels)
		channel_host(pair.value);
	
	process();
}

template<typename T> void process_cache(T& s)
{
	s.items(
		"server", m_server,
		"token", m_token,
		"sync_next", m_sync_next,
		"max_uid", m_max_uid,
		"users", m_users,
		"channels", m_channels
		);
}

void process()
{
	if (!m_server)
	{
		status("* Locating home server");
		m_http.send(m_login_homeserver+"/.well-known/matrix/client", [this](HTTP::rsp r) {
			http_log_response(r);
			if (r.status == 404)
			{
				m_server = std::move(m_login_homeserver);
			}
			else if (r.status == 200)
			{
				JSON json((string)std::move(r.body));
				m_server = json["m.homeserver"]["base_url"];
			}
			else
			{
				status("* Failed (status "+tostring(r.status)+", retrying in 30 seconds");
				m_retry.set_once(30000, bind_this(&matrix::process));
				return;
			}
			m_http.reset(); // homeserver is often another domain than discovery
			
			if (!m_server) fatal("Homeserver discovery failed");
			process();
		});
		return;
	}
	if (!m_token)
	{
		status("* Logging in");
		if (!m_login_password) return fatal("No token nor password configured");
		
		JSONw json;
		json["type"] = "m.login.password";
		json["user"] = m_login_username;
		json["password"] = m_login_password;
		http_api("login", json, [this](HTTP::rsp r) {
			http_log_response(r);
			if (!r.success())
			{
				status("* Failed (status "+tostring(r.status)+", retrying in 30 seconds");
				m_retry.set_once(30000, bind_this(&matrix::process));
				return;
			}
			JSON json((string)std::move(r.body));
			m_token = json["access_token"];
			
			if (!m_token) return fatal("Login failed");
			
			process();
		});
		return;
	}
	
	HTTP::req r;
	r.url = m_server+"/_matrix/client/r0/sync?timeout="+(!m_online?"0":"30000");
	if (m_sync_next) r.url += "&since="+m_sync_next;
	r.headers.append("Authorization: Bearer "+m_token);
	r.limit_ms = 45000;
	
	if (m_rawlog)
		m_rawlog.write(logdate()+" << GET "+r.url+"\n");
	
	m_http_poll.send(r, [this](HTTP::rsp r) {
		http_log_response(r);
		if (!r.success())
		{
			m_http_poll.reset();
			if (m_online)
			{
				status("* Disconnected", chanbase::imp_none);
				protocol::disconnected();
				m_online = false;
				m_root->set_available(m_online);
				for (auto& pair : m_channels)
					pair.value.host->set_available(m_online);
				process();
			}
			else
			{
				m_http_poll.reset();
				m_retry.set_once(30000, bind_this(&matrix::process));
			}
			return;
		}
		if (!m_online)
		{
			status("* Connected", chanbase::imp_none);
			m_online = true;
			m_root->set_available(m_online);
			for (auto& pair : m_channels)
				pair.value.host->set_available(m_online);
		}
		JSON json((string)std::move(r.body));
		m_sync_next = json["next_batch"];
		process_events(json, false);
		
		process();
	});
}

void process_events(const JSON& json, bool ignore_messages)
{
	for (const auto& pair : json["rooms"]["join"].assoc())
	{
		channel& ch = m_channels.get_create(pair.key);
		if (!ch.id) ch.id = pair.key; // ignore unless newly created, rewriting would yield dangling references in m_channel_keys
		for (const JSON& ev : pair.value["state"]["events"].list())
			process_room_event(ch, ev, ignore_messages);
		channel_host(ch);
		for (const JSON& ev : pair.value["timeline"]["events"].list())
			process_room_event(ch, ev, ignore_messages);
		if (pair.value["timeline"]["limited"])
			status("* WARNING: channel "+ch.display_name(this, nullptr)+" scrollback is truncated");
	}
	for (const JSON& ev : json["account_data"]["events"].list())
		process_account_event(ev);
	if (json["presence"])
	{
		for (const JSON& ev : json["presence"]["events"].list())
		{
			if (ev["type"] != "m.presence") continue;
			user& u = user_for(ev["sender"]);
			// hopefully this won't give any false positives between the bot's event sync timing out and sending the next one...
bool prev = u.online;
			u.online = (ev["presence"] != "offline");
if (prev != u.online) status("user "+u.display_name+" online="+tostring(u.online));
		}
		// do this after the above loop, so it complains if a watched user is offline and not mentioned by the server
		// will break if you don't see presence updates for anyone, but my homeserver regularly informs me about myself, so good enough
		for (uid_t uid : m_online_watches)
		{
			user& u = m_users.get(uid);
			if (!u.online && !u.online_watch_warned)
			{
				status("* WARNING: User "+u.display_name+" is offline");
				u.online_watch_warned = true;
			}
			if (u.online && u.online_watch_warned)
			{
				status("* User "+u.display_name+" is online");
				u.online_watch_warned = false;
			}
		}
	}
}

void process_room_event(channel& ch, const JSON& ev, bool ignore_messages)
{
	if (ev["type"] == "m.room.member")
	{
		uid_t uid;
		user& u = user_for(ev["state_key"], &uid);
		ch.members.add(uid);
		if (ev["content"]["displayname"]) u.display_name = ev["content"]["displayname"];
		
		cstring new_av_url = ev["content"]["avatar_url"];
		if (new_av_url && new_av_url != u.avatar_url)
		{
			u.avatar_url = new_av_url;
			u.avatar_bytes.reset();
			// TODO: fetch it
			// TODO: find somewhere to store them, 128x128 images are too big to base64 and drop in the cache
		}
	}
	if (ev["type"] == "m.room.message")
	{
		if (ignore_messages)
			return;
		uid_t uid = m_user_by_name.get_or(ev["sender"].str(), 0);
		if (!uid)
			return status("ERROR: Message by unknown user "+ev.serialize());
		user& u = m_users.get(uid);
		message& m = ch.messages.append();
		m.author = uid;
		m.at = ev["origin_server_ts"].num() / 1000;
		m.id = ev["event_id"];
		m.html = ev["content"]["body"];
		
		render_message(ch, m);
		
		if (ch.messages.size() > 500)
			ch.messages.remove_range(0, ch.messages.size()-300);
	}
	if (ev["type"] == "m.room.name")
	{
		ch.name = ev["content"]["name"];
	}
	if (ev["type"] == "m.room.canonical_alias")
	{
		ch.public_alias = ev["content"]["alias"];
	}
}

void process_account_event(const JSON& ev)
{
	if (ev["type"] == "m.direct")
	{
		for (const auto& pair : ev["content"].assoc())
		{
			uid_t uid = m_user_by_name.get_or(pair.key, 0);
			if (!uid) continue; // should be impossible
			for (cstring chan : pair.value.list())
			{
				channel* ch = m_channels.get_or_null(chan);
				if (!ch) continue; // should also be impossible
				
				ch->dm_to = uid;
				channel_host(*ch);
			}
		}
	}
}

void action(chanbase& at, cstring text) override
{
	auto simple_message = [&at](cstring text) {
		span sp[1] = { { text } };
		at.message(chanbase::imp_scrollback, time(NULL), sp);
	};
	
	cstring ch_name = m_channel_keys[(uintptr_t)(void*)at.userdata];
	channel* ch = ch_name ? &m_channels[ch_name] : NULL;
	const char * msgtype = "m.text";
	
	if (LIKELY(text[0] != '/'))
	{
		if (!ch) return simple_message("* Can't talk here");
		
	normal_send:
		JSONw json;
		json["msgtype"] = msgtype;
		json["body"] = text;
		http_api("PUT", "rooms/"+HTTP::urlencode(ch_name)+"/send/m.room.message/"+tostring(time_us()), json, [this](HTTP::rsp r){
				http_log_response(r);
			});
		return;
	}
	if (LIKELY(text[1] == '/'))
	{
		if (!ch) return simple_message("* Can't talk here");
		text = text.substr(1, ~0);
		goto normal_send;
	}
	
	array<cstring> parts = text.substr(1, ~0).csplit<1>(REGEX(" |(?=\\n)"));
	cstring command = parts[0];
	cstring param = parts.size()==2 ? parts[1] : "";
	
	if(0);
	else if (command == "sync")
	{
		if (param)
			return simple_message("* This command doesn't take arguments");
		
		timer t;
		
		string cache = jsonserialize([this](jsonserializer& s) { process_cache(s); });
		size_t complen;
		void* comp = tdefl_compress_mem_to_heap(cache.bytes().ptr(), cache.bytes().size(), &complen, TDEFL_DEFAULT_MAX_PROBES);
		file::writeall(file::resolve(file::exepath(), m_cachename), arrayview<uint8_t>((uint8_t*)comp, complen));
		free(comp);
		
		simple_message("* State synchronized in "+tostring(t.ms())+"ms");
	}
	else if (command == "reload")
	{
		if (param)
			return simple_message("* This command doesn't take arguments");
		
		http_api("sync", [this, simple_message](HTTP::rsp r) {
			if (!r.success())
				return simple_message("* Error "+tostring(r.status));
			
			// TODO: mark every user/etc as unused, then ser_include_if(used)
			JSON json((string)std::move(r.body));
			process_events(json, true);
		});
	}
	else if (command == "http")
	{
		if (!param)
			return simple_message("* Example: /http PUT profile/@alice:example.com/displayname {\"displayname\":\"Alice Margatroid\"}");
		
		string method;
		string path;
		string json;
		
		if (isupper(param[0]))
		{
			array<cstring> parts = param.csplit<2>(" ");
			method = parts[0];
			path = parts[1];
			if (parts.size() == 3)
				json = parts[2];
		}
		else
		{
			array<cstring> parts = param.csplit<1>(" ");
			path = parts[0];
			if (parts.size() == 2)
				json = parts[1];
		}
		
		JSON jsonobj;
		if (json && !jsonobj.parse(json))
			return simple_message("* Invalid JSON");
		
		http_api(method, path, jsonobj, [this, &at](HTTP::rsp r){
				span sp[2] = { { "* " }, { r.body ? r.body : tostring(r.status) } };
				at.message(chanbase::imp_scrollback, time(NULL), sp);
			});
	}
	else
	{
		simple_message("* Unknown command");
	}
}

void begin_private(chanbase& at, cstring name) override
{
}

void close_chan(chanbase& at) override
{
}

~matrix()
{
	string cache = jsonserialize([this](jsonserializer& s) { process_cache(s); });
	size_t complen;
	void* comp = tdefl_compress_mem_to_heap(cache.bytes().ptr(), cache.bytes().size(), &complen, TDEFL_DEFAULT_MAX_PROBES);
	file::writeall(file::resolve(file::exepath(), m_cachename), arrayview<uint8_t>((uint8_t*)comp, complen));
	free(comp);
}

};
}
protocol*
protocol::create_matrix(impl* parent, bmldeserializer& s, cstring name) { return new matrix(parent, s, name); }
}
