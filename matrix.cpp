#include "chatbase.h"

namespace russian {
namespace {

class matrix : public chatbase<matrix> {
public:

template<typename Ts>
struct my_serializer : public Ts {
	matrix* parent;
};
template<typename Ts>
static matrix* this_from_serializer(Ts& serializer)
{
	return ((my_serializer<Ts>*)&serializer)->parent;
}

struct user {
	uid id; // @alice:matrix.org
	string display_name; // Alice Margatroid
	string name_override;
	string avatar; // mxc://matrix.org/aAaAaAaaAAAAaaaAAaaaAAaa
	bool used = false;
	
	bool online_watch = false;
	bool is_online = true;
	
	cstring name()
	{
		if (name_override)
			return name_override;
		if (display_name)
			return display_name;
		return id.substr(1, ~0).csplit<1>(":")[0];
	}
	
	void serialize(auto& s)
	{
		//if (s.serializing && !used)
			//return;
		//matrix* parent = this_from_serializer(s);
		SER_ENTER(s)
		{
			SER_IF(s, display_name) s.item("name", display_name);
			SER_IF(s, avatar) s.item("avatar", avatar);
		}
	}
};
struct message {
	mid id; // $aa1AA1A-1aaaa1AaA1Aaa1AaAAAAa1-aaAa1aAAAaAA
	user* author;
	timestamp time;
	string text;
	
	void serialize(auto& s)
	{
		matrix* parent = this_from_serializer(s);
		SER_ENTER(s)
		{
			s.item("id", id);
			s.item("author", ser_user(parent, author));
			s.item("time", time);
			s.item("text", text);
		}
	}
};
struct channel {
	cid id; // !AaaAAaAAaaaAAaAaaa:matrix.org
	string channel_name; // #test:matrix.org
	string friendly_name; // Test room
	bool used = false;
	autoptr<russian::channel> host = nullptr;
	user* dm_to = nullptr;
	set<user*, pointer_hasher> members;
	array<message> messages;
	
	bool scrollback_partial; // if false, the below two members are empty or invalid
	midref scrollback_pos; // where to insert scrollback
	string scrollback_prev_batch; // for Matrix; absent on other protocols
	
	bool is_dm() const
	{
		return dm_to != nullptr;
	}
	
	cstring name()
	{
		if (friendly_name) return friendly_name;
		if (dm_to) return dm_to->name();
		if (channel_name) return channel_name;
		return id;
	}
	
	void serialize(auto& s)
	{
		//if (s.serializing && !used)
			//return;
		matrix* parent = this_from_serializer(s);
		SER_ENTER(s)
		{
			SER_IF(s, channel_name) s.item("channel_name", channel_name);
			SER_IF(s, friendly_name) s.item("friendly_name", friendly_name);
			SER_IF(s, dm_to) s.item("dm_to", ser_user(parent, dm_to));
			s.item("members", ser_users(parent, members));
			s.item("messages", ser_messages(s, messages));
		}
	}
};

chanbase::importance_t message_importance(channel& ch, message& m)
{
	if (m.author == m_self)
		return chanbase::imp_none;
	return chanbase::imp_msg;
}

array<span> message_render(channel& ch, message& m, size_t* editspan = nullptr)
{
	array<span> ret;
	ret.append({ "<"+m.author->name()+"> " });
	if (editspan)
	{
		*editspan = ret.size();
		ret.append();
	}
	ret.append({ m.text });
	return ret;
}

autoptr<russian::group> m_root;

http_t m_http;
// Matrix uses long polling for event delivery. Sounds insane at first, but the server supports Keep-Alive, so the data on the wire
//  ends up looking mostly like any other protocol's ping/pong scheme, just with an odd framing scheme (no worse than DNS over HTTP).
// This also means sessions are not a thing in the protocol. There's no such thing as online or offline;
//  no login procedure when opening a websocket, no large chunks of stuff I already know every time I start the program.
// But I should still have two separate HTTP objects, so message sending doesn't get stuck behind a poll.
http_t m_http_poll;

file m_rawlog;

bool m_online = false;
string m_server; // https://matrix-client.matrix.org (can contain port number)
string m_token; // AAA0AA0aaAA0aA0aAAaaa0A0.aAAAAaaaaaAAAAaaAa
string m_sync_next; // s1234567890_123456789_1234567_1234567890_123456789_1234567_123456789_1234567890_123456

user* m_self;

string m_cachename;

// Used only during login.
string m_login_homeserver;
string m_login_username;
string m_login_password;

void fatal(cstring text)
{
	span sp[1] = { { text } };
	sp[0].fgcol = 0xFF0000;
	m_root->message(chanbase::imp_highlight, time(NULL), sp);
	m_root->rename("ERROR - Matrix");
	
	terminate();
}

matrix(impl* parent) : chatbase(parent, 0) {}
struct tmp_channel { cstring id; bool visible = false; SERIALIZE(id, visible); };
struct tmp_user { cstring id; bool watch; cstring name; SERIALIZE(id, watch, name); };
void init(json5deserializer2& s)
{
	cstring root_name;
	cstring username_full;
	cstring password;
	cstring token;
	cstring rawlog_fname;
	array<tmp_channel> tmp_chans;
	array<tmp_user> tmp_users;
	
	SER_ENTER(s)
	{
		s.item("name", root_name);
		s.item("username", username_full);
		s.item("cache", m_cachename);
		s.item("password", m_login_password);
		s.item("token", token);
		s.item("rawlog", rawlog_fname);
		s.item("channels", tmp_chans);
		s.item("users", tmp_users);
	}
	
	m_root = mkgroup(root_name, chanbase::f_no_logs|chanbase::f_no_users, nullptr);
	m_root->set_available(false);
	
	if (rawlog_fname)
		m_rawlog.open(file::resolve(file::exedir(), rawlog_fname), file::m_replace);
	m_cachename = file::resolve(file::exedir(), m_cachename);
	
	m_http.wrap_socks(&autoproxy::socket_create_sslmaybe);
	m_http_poll.wrap_socks(&autoproxy::socket_create_sslmaybe);
	
	auto parts = REGEX("@([a-z0-9\\-_=./]+):([a-z0-9\\-.\\[:\\]]+)").match(username_full);
	if (!parts)
		return fatal("Malformed username");
	m_login_username = parts[1];
	m_login_homeserver = "https://"+parts[2];
	m_self = &user_for(username_full);
	
	for (tmp_user& tu : tmp_users)
	{
		user& u = user_for(tu.id);
		u.online_watch = tu.watch;
		u.name_override = tu.name;
	}
	
	my_serializer<jsondeserializer2> sw = { file::readallt(m_cachename), this };
	process_cache(sw);
	
	if (token) // force override, if one was cached
		m_token = token;
	
	for (tmp_channel& tch : tmp_chans)
	{
		channel& ch = channel_for(tch.id);
		if (tch.visible)
			show_channel(ch);
	}
}
void deinit()
{
	my_serializer<jsonserializer2> sw = { {}, this };
	process_cache(sw);
	file::writeall(m_cachename, sw.finish());
}

template<typename T> void process_cache(T& s)
{
	SER_ENTER(s)
	{
		s.item("server", m_server);
		s.item("token", m_token);
		s.item("sync_next", m_sync_next);
		s.item("users", users());
		s.item("channels", channels());
	}
}

string logdate(time_t rawtime)
{
	struct tm * timeinfo = localtime(&rawtime);
	char out[64];
	strftime(out, 64, "[%H:%M:%S]", timeinfo);
	return out;
}
string logdate()
{
	return logdate(time(NULL));
}

void status(time_t at, cstring text, chanbase::importance_t imp = chanbase::imp_status)
{
	span sp[1] = { { text } };
	if (imp == chanbase::imp_highlight) sp[0].fgcol = 0xFF0000;
	m_root->message(imp, at, sp);
}
void status(cstring text, chanbase::importance_t imp = chanbase::imp_status)
{
	status(time(NULL), text, imp);
}

// Path should be only the part after https://domain/_matrix/client/r0/. For example, "login" would be a fine value.
// Alternatively, if it starts with a slash, it can be the part after https://domain/_matrix, for example "/media/r0/config".
async<http_t::rsp> http_api(cstring method, cstring path, const JSON& json)
{
	http_t::req r;
	if (path[0] == '/') r.loc = m_server+path; // /_matrix/media/ is usable by clients, but isn't under /client/
	else r.loc = m_server+"/_matrix/client/r0/"+path;
	if (method) r.method = method;
	if (m_token) r.headers.append("Authorization: Bearer "+m_token);
	if (json) r.body = json.serialize().bytes();
	if (m_rawlog)
	{
		cstring method = (r.method ? r.method : r.body ? (cstring)"POST" : (cstring)"GET");
		if (r.body.contains('\0') || r.body.size() > 10000)
			m_rawlog.write(logdate()+" << "+method+" "+r.loc.stringify()+" <snip>\n");
		else
			m_rawlog.write(logdate()+" << "+method+" "+r.loc.stringify()+" "+cstring(r.body)+"\n");
	}
	return m_http.request(r);
}
async<http_t::rsp> http_api(cstring path, const JSON& json)
{
	return http_api("", path, json);
}
async<http_t::rsp> http_api(cstring path)
{
	JSON json;
	return http_api(path, json);
}
void http_log_response(const http_t::rsp& r)
{
	if (m_rawlog)
		m_rawlog.write(logdate()+" >> "+tostring(r.status)+" "+r.text_unsafe()+"\n");
}

async<void> network()
{
	if (!m_server)
	{
		status("* Locating home server");
		http_t::rsp r = co_await m_http.get(m_login_homeserver+"/.well-known/matrix/client");
		http_log_response(r);
		if (r.status == 404)
		{
			m_server = std::move(m_login_homeserver);
		}
		else if (r.status == 200)
		{
			JSON json(r.text());
			m_server = json["m.homeserver"]["base_url"];
		}
		else
			co_return status("* Failed (status "+tostring(r.status)+")");
		
		if (!m_server)
			co_return fatal("Homeserver discovery failed");
	}
	if (!m_token)
	{
		status("* Logging in");
		if (!m_login_password)
			co_return fatal("No token nor password configured");
		
		JSONw json;
		json["type"] = "m.login.password";
		json["user"] = m_login_username;
		json["password"] = m_login_password;
		http_t::rsp r = co_await http_api("login", json);
		http_log_response(r);
		if (!r.success())
			co_return status("* Failed (status "+tostring(r.status)+")");
		
		JSON json2((string)std::move(r.text()));
		m_token = json2["access_token"];
		
		if (!m_token)
			co_return fatal("Login failed");
	}
	
	while (true)
	{
		reconnect_in(45000);
		
		http_t::req q;
		q.loc = m_server+"/_matrix/client/r0/sync?timeout="+(m_online?"30000":"0");
		if (m_sync_next) q.loc.path += "&since="+m_sync_next;
		q.headers.append("Authorization: Bearer "+m_token);
		
		if (m_rawlog)
			m_rawlog.write(logdate()+" << GET "+q.loc.stringify()+"\n");
		
		http_t::rsp r = co_await m_http_poll.request(q);
		http_log_response(r);
		
		if (r.success() != m_online)
		{
			m_online = r.success();
			if (m_online)
				status("* Connected", chanbase::imp_none);
			else
				status("* Disconnected", chanbase::imp_none);
			if (!m_online)
				protocol::disconnected();
			m_root->set_available(m_online);
			for (channel& ch : channels())
			{
				if (ch.host)
					ch.host->set_available(m_online);
			}
		}
		if (!r.success())
			co_return;
		
		JSON json(r.text());
		m_sync_next = json["next_batch"];
		process_events(json);
	}
}

void process_events(const JSON& json)
{
	for (const JSON& ev : json["account_data"]["events"].list())
	{
		if (ev["type"] == "m.direct")
		{
			for (const auto& pair : ev["content"].assoc())
			{
				user& u = user_for(pair.key);
				for (cstring chan : pair.value.list())
				{
					channel& c = channel_for(chan);
					c.dm_to = &u;
				}
			}
		}
	}
	for (const auto& pair : json["rooms"]["join"].assoc())
	{
		channel& ch = channel_for(pair.key);
		for (const JSON& ev : pair.value["state"]["events"].list())
			process_room_event(ch, ev);
		if (pair.value["timeline"]["limited"])
		{
			ch.scrollback_partial = true;
			ch.scrollback_pos = "";
			ch.scrollback_prev_batch = pair.value["timeline"]["prev_batch"];
		}
		for (const JSON& ev : pair.value["timeline"]["events"].list())
			process_room_event(ch, ev);
	}
	for (const JSON& ev : json["presence"]["events"].list())
	{
		if (ev["type"] != "m.presence") continue;
		user& u = user_for(ev["sender"]);
		if (u.online_watch)
		{
			bool new_online = (ev["content"]["presence"] != "offline");
			if (new_online != u.is_online)
			{
				if (!new_online)
					status("* WARNING: user "+u.name()+" is offline");
				else
					status("* user "+u.name()+" is online");
			}
			u.is_online = new_online;
		}
	}
}

void process_room_event(channel& ch, const JSON& ev)
{
	if (ev["type"] == "m.room.member")
	{
		user& u = user_for(ev["state_key"]);
		if (ev["content"]["membership"] == "join")
			channel_member_join(ch, u);
		else
			channel_member_leave(ch, u);
		
		if (ev["content"]["displayname"])
			u.display_name = ev["content"]["displayname"];
		if (ev["content"]["avatar_url"])
			u.avatar = ev["content"]["avatar_url"];
	}
	else if (ev["type"] == "m.room.message")
	{
		message m;
		parse_message(ev, m);
		if (m.id)
			append_message(ch, m);
	}
	else if (ev["type"] == "m.room.name")
	{
		ch.friendly_name = ev["content"]["name"];
	}
	else if (ev["type"] == "m.room.canonical_alias")
	{
		ch.channel_name = ev["content"]["alias"];
	}
	else
	{
		status("Unknown message type "+ev["type"].str()+" by "+ev["sender"].str()+" in "+ch.name());
	}
}

void parse_message(const JSON& ev, message& m)
{
	user* u = try_user_for(ev["sender"]);
	if (!u)
		return status("ERROR: Message by unknown user "+ev.serialize());
	
	m.id = ev["event_id"];
	m.author = u;
	int64_t time_ms = ev["origin_server_ts"].num();
	m.time = { time_ms/1000, time_ms%1000*1000000 };
	m.text = ev["content"]["body"];
}

async<void> request_scrollback(channel& ch)
{
	http_t::rsp r = co_await http_api("rooms/"+ch.id+"/messages?dir=b&limit=50&from="+ch.scrollback_prev_batch);
	JSON json(r.text());
	if (json["end"])
		ch.scrollback_prev_batch = json["end"];
	
	arrayview<JSON> events = json["chunk"].list();
	array<message> messages;
	for (size_t i=events.size();i>0;i--)
	{
		const JSON& ev = events[i-1];
		// ignore everything except messages, they've been processed in the not-scrollback handler and may be outdated
		if (ev["type"] == "m.room.message")
		{
			message& m = messages.append();
			parse_message(ev, m);
			if (!m.id)
				messages.resize(messages.size()-1);
		}
	}
	if (messages)
		scrollback_segment(ch, messages);
}

async<void> send_message(channel& ch, cstring text)
{
	// todo: temp message
	JSONw json;
	json["msgtype"] = "m.text";
	json["body"] = text;
	string url = "rooms/"+http_t::urlencode(ch.id)+"/send/m.room.message/"+tostring(timestamp::now());
	http_t::rsp r = co_await http_api("PUT", url, json);
	http_log_response(r);
}

async<void> co_command_http(channel* ch, string param)
{
	auto simple_message = [ch](cstring text) {
		span sp[1] = { { text } };
		ch->host->message(chanbase::imp_scrollback, time(NULL), sp);
	};
	
	if (!param)
		co_return simple_message("* Example: /http PUT profile/@alice:example.com/displayname {\"displayname\":\"Alice Margatroid\"}");
	
	string method;
	string path;
	string json;
	
	if (isupper(param[0]))
	{
		array<cstring> parts = param.csplit<2>(" ");
		method = parts[0];
		path = parts[1];
		if (parts.size() == 3)
			json = parts[2];
	}
	else
	{
		array<cstring> parts = param.csplit<1>(" ");
		path = parts[0];
		if (parts.size() == 2)
			json = parts[1];
	}
	
	JSONw jsonobj;
	if (json && !jsonobj.parse(json))
		co_return simple_message("* Invalid JSON");
	
	http_t::rsp r = co_await http_api(method, path, jsonobj);
	simple_message("* " + (r.body_unsafe() ? r.body_unsafe() : tostring(r.status)));
}

bool command(channel* ch, cstring command, cstring param)
{
	russian::chanbase* target = ch ? (russian::chanbase*)ch->host : (russian::chanbase*)m_root;
	auto simple_message = [target](cstring text) {
		span sp[1] = { { text } };
		target->message(chanbase::imp_scrollback, time(NULL), sp);
		return true;
	};
	
	if(0);
	else if (command == "sync")
	{
		if (param)
			return simple_message("* This command doesn't take arguments");
		
		timer t;
		
		my_serializer<jsonserializer2> sw = { {}, this };
		process_cache(sw);
		file::writeall(m_cachename, sw.finish());
		
		simple_message("* State synchronized in "+tostring(t.ms())+"ms");
	}
	else if (command == "http")
	{
		m_misc_waiters.add(co_command_http(ch, param));
	}
	else return false;
	return true;
}

};

}
protocol*
protocol::create_matrix(impl* parent, json5deserializer2& s) { return new chatbase_impl<matrix>(parent, s); }
}
