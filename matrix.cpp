#include "russian.h"

// https://matrix.org/docs/spec/client_server/latest

// TODO: automatically clean up
// - no-longer-present users
// - no-longer-present channels
//    (I think these two can be done with events only, except I'll probably need to keep the objects around until program reboot)

// message edits look like
// {"type":"m.room.message","sender":"@user:matrix.org","content":{"msgtype":"m.text","body":"a"},"origin_server_ts":1633012457634,"unsigned":{"age":42},"event_id":"$JRjEGgiBHksO1XEUcfae5Vbk03BtrQi9yE-UUruKEgo"}
// {"type":"m.room.message","sender":"@user:matrix.org","content":{"m.new_content":{"msgtype":"m.text","body":"b"},"m.relates_to":{"rel_type":"m.replace","event_id":"$JRjEGgiBHksO1XEUcfae5Vbk03BtrQi9yE-UUruKEgo"},"msgtype":"m.text","body":" * b"},"origin_server_ts":1633012461455,"unsigned":{"age":45},"event_id":"$1umYZpQIA0yUtZ6N_6oRjTkYrHOzpshAC_tyFVFy3LA"}
// or, if both message and edit are fetched simultaneously,
// {"type":"m.room.message","sender":"@user:matrix.org","content":{"msgtype":"m.text","body":"b"},"origin_server_ts":1633012457634,"unsigned":{"age":527056,"m.relations":{"m.replace":{"event_id":"$1umYZpQIA0yUtZ6N_6oRjTkYrHOzpshAC_tyFVFy3LA","origin_server_ts":1633012461455,"sender":"@user:matrix.org"}}},"event_id":"$JRjEGgiBHksO1XEUcfae5Vbk03BtrQi9yE-UUruKEgo","user_id":"@user:matrix.org","age":527056}
// {"type":"m.room.message","sender":"@user:matrix.org","content":{"m.new_content":{"msgtype":"m.text","body":"b"},"m.relates_to":{"rel_type":"m.replace","event_id":"$JRjEGgiBHksO1XEUcfae5Vbk03BtrQi9yE-UUruKEgo"},"msgtype":"m.text","body":" * b"},"origin_server_ts":1633012461455,"unsigned":{"age":523235},"event_id":"$1umYZpQIA0yUtZ6N_6oRjTkYrHOzpshAC_tyFVFy3LA","user_id":"@user:matrix.org","age":523235}

namespace russian {
namespace {

class matrix : public protocol {
public:

autoptr<russian::group> m_root; // keep this above m_channels, destructor order is important

http_t m_http;
// Matrix uses long polling for event delivery. Sounds insane at first, but the server supports Keep-Alive, so the data on the wire
//  ends up looking mostly like any other protocol's ping/pong scheme, just with an odd framing scheme (no worse than DNS over HTTP).
// This also means sessions are not a thing in the protocol. There's no such thing as online or offline;
//  no login procedure when opening a websocket, no large chunks of stuff I already know every time I start the program.
// But I should still have two separate HTTP objects, so message sending doesn't get stuck behind a poll.
http_t m_http_poll;
waiter<void> m_http_coro;

file m_rawlog;

//waiter_fn<void, void> m_retry;

bool m_online = false;

string m_server; // https://matrix-client.matrix.org (can contain port number)
string m_token; // AAA0AA0aaAA0aA0aAAaaa0A0.aAAAAaaaaaAAAAaaAa
string m_sync_next; // s1234567890_123456789_1234567_1234567890_123456789_1234567_123456789_1234567890_123456

string m_cachename;

socks5 m_proxy;

// Used only during login.
string m_login_homeserver;
string m_login_username;
string m_login_password;

typedef uint64_t uid_t;
uid_t m_max_uid = 0;
static constexpr uid_t m_my_uid = 1; // uid 0 means unknown, 1 means myself

struct message {
	uid_t author;
	time_t at;
	string id;
	// The HTML is known to be well behaved:
	// - Every <, > and & is part of an HTML tag
	// - Tags always close in the right order (except <img>, <hr> and <br>, which don't have close tags)
	// - Only a small set of tags exist:
	//    font, del, h1, h2, h3, h4, h5, h6, blockquote, p, a, ul, ol, sup, sub, li, b, i, u,
	//    strong, em, strike, code, hr, br, div, table, thead, tbody, tr, th, td, caption, pre, span, img
	// - Only a small set of attributes exist:
	//    <font data-mx-bg-color="#ff0000" data-mx-color="#ff0000">
	//    <span data-mx-bg-color="#ff0000" data-mx-color="#ff0000">
	//    <a name="" target="" href=""> (href must start with one of http://, https://, mailto:, magnet:, ftp://)
	//    <img width="16" height="16" alt="" title="" src=""> (src must start with mxc://)
	//      mxc://matrix.org/ascERGshawAWawugaAcauga -> /_matrix/media/r0/download/matrix.org/ascERGshawAWawugaAcauga
	//    <ol start="100">
	//    <code class="language-">
	//    Other tags can not have attributes.
	// - Max 100 tags can be nested.
	// If the message contains something unexpected, or doesn't contain any HTML, this will instead be htmlentities(plaintext).
	// (todo: implement a validator and implement the above rules)
	// (todo: parse html)
	string html;
	
	template<typename T> void serialize(T& s)
	{
		s.items("author", author, "at", at, "id", id, "html", html);
	}
};

struct user {
	string username; // @alice:matrix.org
	string display_name; // Alice Margatroid
	string avatar; // includes mxc://
	bool used = false;
	
	time_t last_online = 0;
	bool online_watch_warned = false;
	bool currently_active = false;
	
	template<typename T> void serialize(T& s)
	{
		// TODO: maybe I should keep users around forever, in case they go not-inactive
		// depends on how much a Matrix message tells me, and how much it expects I cached since last time
		// (or maybe I should send an http request if someone unknown starts talking. I'll need one anyways, for the avatar.)
		if (used || !s.serializing)
			s.items("username", username, "display_name", display_name, "avatar", avatar,
				"currently_active", ser_include_if(currently_active, currently_active));
	}
};

struct channel {
	string id; // !AaaAAaAAaaaAAaAaaa:matrix.org
	string public_alias; // #test:matrix.org
	string name; // Test room
	uid_t dm_to = 0;
	array<message> messages;
	set<uid_t> members;
	
	bool leave = false;
	autoptr<russian::channel> host;
	
	bool exists()
	{
		if (leave)
			return false;
		if (public_alias || name || dm_to)
			return true;
		return false;
	}
	
	template<typename T> void serialize(T& s)
	{
		if (!leave || !s.serializing)
			s.items(
				"name", ser_include_if_true(name),
				"public_alias", ser_include_if_true(public_alias),
				"dm_to", ser_include_if(dm_to!=0, dm_to),
				"messages", messages,
				"members", members);
	}
	
	cstring display_name(matrix* parent, int* sort_key = nullptr)
	{
		if (sort_key)
			*sort_key = (dm_to!=0 ? 0 : 1);
		if (name) return name;
		if (public_alias) return public_alias;
		if (dm_to) return parent->m_users.get(dm_to).display_name;
		return id;
	}
};

map<uid_t, user> m_users;
map<string, uid_t> m_user_by_name; // key is @alice:matrix.org
map<string, channel> m_channels; // key is !AaaAAaAAaaaAAaAaaa:matrix.org
array<cstring> m_channel_keys;
array<uid_t> m_online_watches;

string logdate(time_t rawtime)
{
	struct tm * timeinfo = localtime(&rawtime);
	char out[64];
	strftime(out, 64, "[%H:%M:%S]", timeinfo);
	return out;
}
string logdate()
{
	return logdate(time(NULL));
}

void status(time_t at, cstring text, chanbase::importance_t imp = chanbase::imp_status)
{
	span sp[1] = { { text } };
	if (imp == chanbase::imp_highlight) sp[0].fgcol = 0xFF0000;
	m_root->message(imp, at, sp);
}
void status(cstring text, chanbase::importance_t imp = chanbase::imp_status)
{
	status(time(NULL), text, imp);
}

void fatal(cstring text)
{
	span sp[1] = { { text } };
	sp[0].fgcol = 0xFF0000;
	m_root->message(chanbase::imp_highlight, time(NULL), sp);
	m_root->rename("ERROR - Matrix");
	
	m_http_coro.cancel();
}

// Path should be only the part after https://domain/_matrix/client/r0/. For example, "login" would be a fine value.
// Alternatively, if it starts with a slash, it can be the part after https://domain/_matrix, for example "/media/r0/config".
async<http_t::rsp> http_api(cstring method, cstring path, const JSON& json)
{
	http_t::req r;
	if (path[0] == '/') r.url = m_server+path; // /_matrix/media/ is usable by clients, but isn't under /client/
	else r.url = m_server+"/_matrix/client/r0/"+path;
	if (method) r.method = method;
	if (m_token) r.headers.append("Authorization: Bearer "+m_token);
	if (json) r.body = json.serialize().bytes();
	if (m_rawlog)
	{
		cstring method = (r.method ? r.method : r.body ? (cstring)"POST" : (cstring)"GET");
		if (r.body.contains('\0') || r.body.size() > 10000)
			m_rawlog.write(logdate()+" << "+method+" "+r.url+" <snip>\n");
		else
			m_rawlog.write(logdate()+" << "+method+" "+r.url+" "+cstring(r.body)+"\n");
	}
	return m_http.request(r);
}
async<http_t::rsp> http_api(cstring path, const JSON& json)
{
	return http_api("", path, json);
}
async<http_t::rsp> http_api(cstring path)
{
	JSON json;
	return http_api(path, json);
}
void http_log_response(const http_t::rsp& r)
{
	if (m_rawlog)
		m_rawlog.write(logdate()+" >> "+tostring(r.status)+" "+r.text_unsafe()+"\n");
}

void render_message(channel& ch, message& m, bool is_scrollback = false)
{
	user& u = m_users.get(m.author);
	u.used = true;
	span sp[1] = { "<"+u.display_name+"> "+m.html };
	ch.host->message(is_scrollback ? chanbase::imp_scrollback : m.author == m_my_uid ? chanbase::imp_none : chanbase::imp_msg, m.at, sp);
}

void channel_host(channel& ch)
{
	int sort_key;
	cstring name = ch.display_name(this, &sort_key);
	if (!name)
		return;
	if (!ch.host)
	{
		ch.host = m_root->child(name, chanbase::f_no_scrollback, (void*)(uintptr_t)m_channel_keys.size());
		m_channel_keys.append(ch.id);
		for (message& m : ch.messages.skip(max(0, ch.messages.size()-250)))
			render_message(ch, m, true);
	}
	ch.host->rename(name);
	ch.host->sort_as(sort_key, name);
	ch.host->set_available(m_online && !ch.leave);
}

user& user_for(cstring username, uid_t* uidp = NULL)
{
	uid_t uid = m_user_by_name.get_create(username, [this](){ return ++m_max_uid; });
	user& u = m_users.get_create(uid);
	u.username = username;
	if (uidp) *uidp = uid;
	return u;
}

matrix(impl* parent, bmldeserializer& s, cstring name) : protocol(parent, 0)
{
	m_root = mkgroup(name, chanbase::f_no_logs|chanbase::f_no_users, (void*)(uintptr_t)m_channel_keys.size());
	m_channel_keys.append("");
	
	m_root->set_available(false);
	
	struct tmp_user {
		bool online_watch = false;
		
		void serialize(bmldeserializer& s)
		{
			s.items("watch", online_watch);
		}
	};
	map<string,tmp_user> tmp_users;
	
	string username_full;
	string password;
	string token;
	string rawlog_fname;
	string proxy_addr;
	s.items(
		"username", username_full,
		"cache", m_cachename,
		"password", m_login_password,
		"token", token,
		"rawlog", rawlog_fname,
		"socks5", proxy_addr,
		// can't insert it directly into users, need to load cache first so user IDs don't do anything crazy
		"user", [&](bmldeserializer& s, cstring name) { tmp_users.get_create(name).serialize(s); });
	
	if (rawlog_fname)
		m_rawlog.open(file::resolve(file::exedir(), rawlog_fname), file::m_replace);
	
	if (proxy_addr)
	{
		m_proxy.configure(proxy_addr);
		m_http.wrap_socks(bind_ptr(&socks5::create_sslmaybe, &m_proxy));
		m_http_poll.wrap_socks(bind_ptr(&socks5::create_sslmaybe, &m_proxy));
	}
	
	auto parts = REGEX("@([a-z0-9\\-_=./]+):([a-z0-9\\-.\\[:\\]]+)").match(username_full);
	if (!parts) { fatal("Malformed username"); return; }
	m_login_username = parts[1];
	m_login_homeserver = "https://"+parts[2];
	
	user_for(username_full); // ensure this is the first one created, so it gets user id 1
	
	jsondeserialize(cstring(file::readall(file::resolve(file::exedir(), m_cachename))),
		[this](jsondeserializer& s)
	{
		process_cache(s);
	});
	
	if (token) m_token = token; // force override, if one was cached
	
	for (auto& pair : m_channels)
		pair.value.id = pair.key;
	for (auto& pair : m_users)
	{
		if (pair.value.username)
			m_user_by_name.get_create(pair.value.username) = pair.key;
	}
	
	for (auto& pair : m_channels)
	{
		if (!pair.value.exists())
			m_channels.remove(pair.key); // this half-invalidates the iterator; channels may survive longer than expected
	}
	for (auto& pair : m_channels)
	{
		// delete users from member list if the user was forgotten
		for (uid_t uid : pair.value.members)
		{
			if (!m_users.contains(uid))
				pair.value.members.remove(uid); // this too half-invalidates
		}
	}
	for (auto& pair : m_users)
	{
		if (!pair.value.username)
			m_users.remove(pair.key);
	}
	
	// do this after m_user_by_name is populated, it's easier
	for (auto& pair : tmp_users)
	{
		uid_t uid;
		user& u = user_for(pair.key, &uid);
		u.used = true;
		if (pair.value.online_watch)
			m_online_watches.append(uid);
	}
	
	for (auto& pair : m_channels)
	{
		if (pair.value.dm_to != 0) // todo: this is oversimplified
			channel_host(pair.value);
		for (uid_t uid : pair.value.members)
			m_users.get(uid).used = true;
		for (message& m : pair.value.messages)
			m_users.get(m.author).used = true;
	}
	
	process().then(&m_http_coro);
}

template<typename T> void process_cache(T& s)
{
	s.items(
		"server", m_server,
		"token", m_token,
		"sync_next", m_sync_next,
		"max_uid", m_max_uid,
		"users", m_users,
		"channels", m_channels
		);
}

async<void> process()
{
again:
	if (!m_server)
	{
		status("* Locating home server");
		http_t::rsp r = co_await m_http.get(m_login_homeserver+"/.well-known/matrix/client");
		http_log_response(r);
		if (r.status == 404)
		{
			m_server = std::move(m_login_homeserver);
		}
		else if (r.status == 200)
		{
			JSON json(r.text());
			m_server = json["m.homeserver"]["base_url"];
		}
		else
		{
			status("* Failed (status "+tostring(r.status)+", retrying in 30 seconds");
			co_await runloop2::await_timeout(timestamp::in_ms(30000));
			goto again;
		}
		
		if (!m_server)
			fatal("Homeserver discovery failed");
	}
	if (!m_token)
	{
		status("* Logging in");
		if (!m_login_password)
			fatal("No token nor password configured");
		
		JSONw json;
		json["type"] = "m.login.password";
		json["user"] = m_login_username;
		json["password"] = m_login_password;
		http_t::rsp r = co_await http_api("login", json);
		http_log_response(r);
		if (!r.success())
		{
			status("* Failed (status "+tostring(r.status)+", retrying in 30 seconds");
			co_await runloop2::await_timeout(timestamp::in_ms(30000));
			goto again;
		}
		
		JSON json2((string)std::move(r.text()));
		m_token = json2["access_token"];
		
		if (!m_token)
			fatal("Login failed");
	}
	
	http_t::req q;
	q.url = m_server+"/_matrix/client/r0/sync?timeout="+(!m_online?"0":"30000");
	if (m_sync_next) q.url += "&since="+m_sync_next;
	q.headers.append("Authorization: Bearer "+m_token);
	
	if (m_rawlog)
		m_rawlog.write(logdate()+" << GET "+q.url+"\n");
	
	variant<http_t::rsp, void> vr = co_await multi_waiter(m_http_poll.request(q), runloop2::await_timeout(timestamp::in_ms(45000)));
	http_t::rsp* r = vr.try_get<http_t::rsp>();
	if (r)
		http_log_response(*r);
	else if (m_rawlog)
		m_rawlog.write(logdate()+" >> (timeout)\n");
	if (!r || !r->success())
	{
		if (m_online)
		{
			status("* Disconnected", chanbase::imp_none);
			protocol::disconnected();
			m_online = false;
			m_root->set_available(m_online);
			for (auto& pair : m_channels)
			{
				if (pair.value.host)
					pair.value.host->set_available(m_online);
			}
			goto again;
		}
		else
		{
			co_await runloop2::await_timeout(timestamp::in_ms(30000));
			goto again;
		}
	}
	if (!m_online)
	{
		status("* Connected", chanbase::imp_none);
		m_online = true;
		m_root->set_available(m_online);
		for (auto& pair : m_channels)
		{
			if (pair.value.host)
				pair.value.host->set_available(m_online);
		}
	}
	JSON json(r->text());
	m_sync_next = json["next_batch"];
	process_events(json, false);
	
	goto again;
}

void process_events(const JSON& json, bool ignore_messages)
{
	for (const auto& pair : json["rooms"]["join"].assoc())
	{
		channel& ch = m_channels.get_create(pair.key);
		ch.leave = false;
		if (!ch.id) ch.id = pair.key; // don't reset unless newly created, rewriting would yield dangling references in m_channel_keys
		for (const JSON& ev : pair.value["state"]["events"].list())
			process_room_event(ch, ev, ignore_messages);
		channel_host(ch);
		for (const JSON& ev : pair.value["timeline"]["events"].list())
			process_room_event(ch, ev, ignore_messages);
		if (pair.value["timeline"]["limited"]) // TODO: make it fetch the channel's full logs instead
			status("* WARNING: channel "+ch.display_name(this)+" scrollback is truncated");
	}
	for (const auto& pair : json["rooms"]["leave"].assoc())
	{
		channel* ch = m_channels.get_or_null(pair.key);
		if (!ch || ch->leave) return;
		
		channel_host(*ch);
		ch->leave = true;
		span sp[1] = { { "*** You are no longer in the channel" } };
		ch->host->message(chanbase::imp_highlight, time(NULL), sp);
		channel_host(*ch);
	}
	for (const JSON& ev : json["account_data"]["events"].list())
		process_account_event(ev);
	if (json["presence"])
	{
		for (const JSON& ev : json["presence"]["events"].list())
		{
			if (ev["type"] != "m.presence") continue;
			user& u = user_for(ev["sender"]);
			if (ev["content"]["presence"] != "offline")
				u.last_online = time(NULL);
			u.currently_active = ev["content"]["currently_active"];
		}
		// do this after the above loop, so it complains if a watched user is offline and not mentioned by the server
		// will break if you don't see presence updates for anyone, but my homeserver regularly informs me about myself, so good enough
		for (uid_t uid : m_online_watches)
		{
			user& u = m_users.get(uid);
			bool online = (u.currently_active || u.last_online > time(NULL)-61);
			if (!online && !u.online_watch_warned)
			{
				status("* WARNING: User "+u.display_name+" is offline", chanbase::imp_msg);
				u.online_watch_warned = true;
			}
			if (online && u.online_watch_warned)
			{
				status("* User "+u.display_name+" is online");
				u.online_watch_warned = false;
			}
		}
	}
}

void process_room_event(channel& ch, const JSON& ev, bool ignore_messages)
{
	if (ev["type"] == "m.room.member")
	{
		uid_t uid;
		user& u = user_for(ev["state_key"], &uid);
		u.used = true;
		if (ev["content"]["membership"] == "join")
			ch.members.add(uid);
		else
			ch.members.remove(uid);
		if (ev["content"]["displayname"]) u.display_name = ev["content"]["displayname"];
		
		cstring new_av_url = ev["content"]["avatar_url"];
		if (new_av_url && new_av_url != u.avatar)
			u.avatar = new_av_url;
	}
	else if (ev["type"] == "m.room.message")
	{
		if (ignore_messages)
			return;
		uid_t uid = m_user_by_name.get_or(ev["sender"].str(), 0);
		if (!uid)
			return status("ERROR: Message by unknown user "+ev.serialize());
		user& u = m_users.get(uid);
		message& m = ch.messages.append();
		m.author = uid;
		m.at = ev["origin_server_ts"].num() / 1000;
		m.id = ev["event_id"];
		m.html = ev["content"]["body"];
		
		if (!ch.host)
			channel_host(ch);
		render_message(ch, m);
		
		if (ch.messages.size() > 500)
			ch.messages.remove_range(0, ch.messages.size()-300);
	}
	else if (ev["type"] == "m.room.name")
	{
		ch.name = ev["content"]["name"];
	}
	else if (ev["type"] == "m.room.canonical_alias")
	{
		ch.public_alias = ev["content"]["alias"];
	}
	else
	{
		status("Unknown message type "+ev["type"].str()+" by "+ev["sender"].str()+" in "+ch.display_name(this));
	}
}

void process_account_event(const JSON& ev)
{
	if (ev["type"] == "m.direct")
	{
		for (const auto& pair : ev["content"].assoc())
		{
			uid_t uid = m_user_by_name.get_or(pair.key, 0);
			if (!uid) continue; // should be impossible
			for (cstring chan : pair.value.list())
			{
				channel* ch = m_channels.get_or_null(chan);
				if (!ch) continue; // should also be impossible
				
				ch->dm_to = uid;
				channel_host(*ch);
			}
		}
	}
}

void action(chanbase& at, cstrnul text) override
{
	auto simple_message = [&at](cstring text) {
		span sp[1] = { { text } };
		at.message(chanbase::imp_scrollback, time(NULL), sp);
	};
	
	cstring ch_id = m_channel_keys[(uintptr_t)(void*)at.userdata];
	channel* ch = ch_id ? &m_channels.get(ch_id) : nullptr;
	const char * msgtype = "m.text";
	
	if (LIKELY(text[0] != '/'))
	{
		if (!ch) return simple_message("* Can't talk here");
		
	normal_send:
		JSONw json;
		json["msgtype"] = msgtype;
		json["body"] = text;
		string url = "rooms/"+http_t::urlencode(ch_id)+"/send/m.room.message/"+tostring(time_us());
		runloop2::detach([](matrix* self, cstring url, JSON& json)->async<void> {
			http_t::rsp r = co_await self->http_api("PUT", url, json);
			self->http_log_response(r);
		}(this, url, json));
		return;
	}
	if (text[1] == '/')
	{
		if (!ch) return simple_message("* Can't talk here");
		text = text.substr_nul(1);
		goto normal_send;
	}
	
	array<cstring> parts = text.substr_nul(1).csplit<1>(REGEX(" |(?=\\n)"));
	cstring command = parts[0];
	cstring param = parts.size()==2 ? parts[1] : "";
	
	if(0);
	else if (command == "sync")
	{
		if (param)
			return simple_message("* This command doesn't take arguments");
		
		timer t;
		
		file::writeall(file::resolve(file::exedir(), m_cachename), jsonserialize([this](jsonserializer& s) { process_cache(s); }));
		
		simple_message("* State synchronized in "+tostring(t.ms())+"ms");
	}
	else if (command == "reload")
	{
		if (param)
			return simple_message("* This command doesn't take arguments");
		
		runloop2::detach([](matrix* self, chanbase* at)->async<void> {
			auto simple_message = [at](cstring text) {
				span sp[1] = { { text } };
				at->message(chanbase::imp_scrollback, time(NULL), sp);
			};
			
			http_t::rsp r = co_await self->http_api("sync");
			if (!r.success())
				co_return simple_message("* Error "+tostring(r.status));
			
			// TODO: mark every user/etc as unused, then ser_include_if(used)
			JSON json(r.text());
			self->process_events(json, true);
		}(this, &at));
	}
	else if (command == "join")
	{
		array<channel*> matches;
		
		for (int type : range(3))
		{
			for (auto& c : m_channels)
			{
				cstring name = c.value.display_name(this, nullptr);
				if (type == 0)
				{
					if (name.matches_globi(param+"*") || name.matches_globi("#"+param+"*"))
						matches.append(&c.value);
				}
				if (type == 1)
				{
					if (name.matches_globi(param+"*"))
						matches.append(&c.value);
				}
				if (type == 2)
				{
					if (name.matches_globi("*"+param+"*"))
						matches.append(&c.value);
				}
			}
			if (matches) break;
		}
		
		if (!matches)
			return simple_message("No such channel");
		
		if (matches.size() == 1 && matches[0] != ch)
		{
			channel* c = matches[0];
			channel_host(*c);
			c->host->focus();
		}
		else
		{
			for (channel* c : matches)
				simple_message(c->display_name(this, nullptr));
		}
	}
	else if (command == "http")
	{
		if (!param)
			return simple_message("* Example: /http PUT profile/@alice:example.com/displayname {\"displayname\":\"Alice Margatroid\"}");
		
		runloop2::detach([](matrix* self, cstring param, chanbase* at)->async<void> {
			auto simple_message = [at](cstring text) {
				span sp[1] = { { text } };
				at->message(chanbase::imp_scrollback, time(NULL), sp);
			};
			
			string method;
			string path;
			string json;
			
			if (isupper(param[0]))
			{
				array<cstring> parts = param.csplit<2>(" ");
				method = parts[0];
				path = parts[1];
				if (parts.size() == 3)
					json = parts[2];
			}
			else
			{
				array<cstring> parts = param.csplit<1>(" ");
				path = parts[0];
				if (parts.size() == 2)
					json = parts[1];
			}
			
			JSON jsonobj;
			if (json && !jsonobj.parse(json))
				co_return simple_message("* Invalid JSON");
			
			http_t::rsp r = co_await self->http_api(method, path, jsonobj);
			
			span sp[2] = { { "* " }, { r.body_unsafe() ? r.body_unsafe() : tostring(r.status) } };
			at->message(chanbase::imp_scrollback, time(NULL), sp);
		}(this, param, &at));
	}
	else
	{
		simple_message("* Unknown command");
	}
}

void begin_private(chanbase& at, cstrnul name) override
{
}

void close_chan(chanbase& at) override
{
}

~matrix()
{
	file::writeall(file::resolve(file::exedir(), m_cachename), jsonserialize([this](jsonserializer& s) { process_cache(s); }));
}

};
}
protocol*
protocol::create_matrix(impl* parent, bmldeserializer& s, cstring name) { return new matrix(parent, s, name); }
}
