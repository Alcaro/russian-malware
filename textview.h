#pragma once
#include "arlib.h"

//I don't know if this is guaranteed stable, but I'd rather not include the gtk header here
typedef struct _GdkPixbuf GdkPixbuf;
typedef struct _GdkPaintable GdkPaintable;
typedef struct _GtkScrolledWindow GtkScrolledWindow;
typedef struct _GtkTextBuffer GtkTextBuffer;
typedef struct _GtkTextIter GtkTextIter;
typedef struct _GtkTextMark GtkTextMark;
typedef struct _GtkTextTag GtkTextTag;
typedef struct _GtkTextView GtkTextView;
typedef struct _GtkWidget GtkWidget;
#ifdef ARLIB_GUI_GTK3
typedef union _GdkEvent GdkEvent;
#define GdkPaintable GdkPixbuf
#else
typedef struct _GdkEvent GdkEvent;
#endif

class textview : nocopy {
public:
	struct ctxaction {
		string text; // An underline will make the next character the keyboard shortcut. To emit an actual underline, double it.
		function<void()> action; // If null, the menu item won't be usable. To make an item do nothing, assign an empty lambda.
	};
	
	// Removes indentation after \n in a message, and halves indentation after word wrap. Value matches russian::chanbase::flags_t.
	static const uint32_t f_less_indent = 0x0010;
	
private:
	GtkScrolledWindow* scrollview;
	
	GtkTextView* view;
	
	GtkTextTag* t_message;
	
	uint32_t flags;
	
	bool scroll_allow_unlock = false; // set to true on user input, false on resize or content change
	bool scroll_at_bottom = true; // only updated if allow_unlock
	
	bool link_click = false;
	bool in_onscroll = false;
	
	function<void(bool now_at_bottom)> onscroll_cb;
	function<void(array<ctxaction>& actions, cstrnul msgid)> contextmenu_cb;
	function<void(string text)> ilink_cb;
	
	GtkTextBuffer* buf;
	GtkTextMark* lastread; // mark is either at the start of a message, or at the end of the buffer
	
	array<ctxaction> ctxmenu_actions; // just keep it around until next time the menu is opened, easiest way to handle memory management
	string ctxmenu_linktarget;
	void ctxmenu_update(int mouse_x, int mouse_y);
	
	textview(uint32_t flags);
	
	bool populate_menu(GtkTextView* text_view, GtkWidget* popup);
	
	//scrollbar behavior:
	//exactly one message per channel is known as last_read
	//on message:
	//  if the old scroll position is at the bottom:
	//    after adding the message, scroll so top pixel of last_read is top of screen
	//    (if last_read is new enough, this may still be the bottom)
	//on user activity in this program (mouse move, keyboard press, give focus, etc):
	//  set last_read to the bottom message
	//  if said activity was switching channels:
	//    do the above for both old and new channels
	//  if said activity was resizing the window:
	//    if old scroll position was at bottom, keep it that way
	//    otherwise, let gtk pick the new scroll position, it does a good job
	
	void onscroll(bool is_resize);
	void scroll_to_last_read();
	void content_changed();
	void move_last_read();
	
public:
	class image : nocopy {
		friend class textview;
		friend class buffer;
		GdkPaintable* pix;
		
		image() = delete;
		image(GdkPaintable* pix) : pix(pix) {}
		
	public:
		//If 'bytes' is a valid image according to gdk-pixbuf, it's loaded.
		//If 'bytes' is empty or an invalid image, NULL will be returned.
		//The image may be smaller than requested, to preserve the aspect ratio of the input.
		//Deleting an image while it's in some messages is fine, the textview will copy or refcount it.
		static image* create(arrayview<uint8_t> bytes, uint32_t width, uint32_t height);
		static image* create(arrayview<uint8_t> bytes, uint32_t size) { return create(bytes, size, size); }
		//Fully transparent.
		static image* blank(uint32_t width, uint32_t height);
		static image* blank(uint32_t size) { return blank(size, size); }
		
		uint32_t width() const;
		uint32_t height() const;
		~image();
	};
	struct span {
		span() {}
		span(cstring text) : text(text) {}
		
		//A span must be valid UTF-8, and may not contain NUL or CR.
		string text;
		
		//If this is non-null, 'text' isn't shown; instead, it's the alt-text if copied.
		//Most other fields do nothing (though bgcol works).
		//It's perfectly fine to insert the same image in multiple messages, or multiple times in the
		// same one. Don't create multiple identical images, that's a waste of RAM.
		image* img = NULL;
		
		bool bold = false;
		bool underline = false;
		bool italics = false;
		bool strike = false;
		bool monospace = false;
		
		// Hidden text is discarded if encountered, other than per i_link.
		bool hidden = false;
		//It is undefined behavior if a hyperlink span does not start with http:// or https://, or if it contains spaces or linebreaks.
		//TODO: glitches up if two consecutive spans are hyperlinks
		bool hyperlink = false;
		//An internal link will allow the caller to do something when the link is clicked. Visually, they're identical to hyperlinks;
		// however, right clicking them will operate only on the visible text. If the visible text starts with http:// or https://,
		// it's used, bypassing your handler; if not, the extra handlers are not added.
		//A span can only be one (or zero) of hidden, image, hyperlink and ilink, with one exception:
		//A hidden ilink is allowed, if followed by a non-hidden one. If the visible one is clicked,
		// the hidden one's text will be passed to the callback, instead of the visible. The hidden one's text is not copyable.
		bool i_link = false;
		
		// the above is 8 booleans; if it goes above 8, slap them into bitfields instead
		
		uint32_t fgcol = -1;
		uint32_t bgcol = -1;
		
		bool is_spoiler() const
		{
			return (fgcol != (uint32_t)-1 && fgcol == bgcol);
		}
		
		int fmt_diff(const span& other) const // Ignores .img and .text.
		{
			const span& a = *this;
			const span& b = other;
			return (a.bold != b.bold) +
			       (a.underline != b.underline) +
			       (a.italics != b.italics) +
			       (a.strike != b.strike) +
			       (a.monospace != b.monospace) +
			       (a.hyperlink != b.hyperlink) +
			       (a.i_link != b.i_link) +
			       (a.fgcol != b.fgcol) +
			       (a.bgcol != b.bgcol);
		}
		bool fmt_eq(const span& other) const // Ignores .img and .text.
		{
			return this->fmt_diff(other) == 0;
		}
	};
	
private:
	//No linebreaks will be added. It's the caller's responsibility to ensure there's a linebreak before and after 'iter'.
	//After calling this, 'iter' points to the \n after the message, or to the end.
	void message_insert_at(GtkTextIter* iter, arrayview<span> spans);
	
	void message_get_bounds(cstring id, GtkTextIter* start, GtkTextIter* end);
	//'replace' must always return a pixbuf, but can return the input.
	//After calling this, both iterators point to some arbitrary point inside the message. 
	void message_replace_image(GtkTextIter* start, GtkTextIter* end, function<GdkPaintable*(GdkPaintable* prev)> replace);
	void message_replace_image(cstring id, function<GdkPaintable*(GdkPaintable* prev)> replace);
	
	GdkPaintable* shrink_image(GdkPaintable* prev);
public:
	
	//If 'id' is nonempty and has already been seen, undefined behavior.
	//The message may contain linebreaks, but should probably not end with one.
	void message(cstring id, arrayview<span> spans) { message_at("", false, id, spans); }
	//The message 'prev' must exist.
	void message_at(cstring prev, bool after, cstring newid, arrayview<span> spans, bool mark_read = false);
	bool message_exists(cstring id);
	//Shrinks the old version of the message, and adds a new one.
	//If 'id' has not been seen, undefined behavior. If 'spans' is empty, no message is added, it's just deemphasized.
	void message_edit_visible(cstring id, arrayview<span> spans);
	//Like the above, but doesn't leave the old version around. 'spans' must not be empty.
	void message_replace(cstring id, arrayview<span> spans);
	void message_delete(cstring id);
	//Replaces every instance of 'prev' with 'next' in the given message. If message is "", operates on the entire textview.
	void message_replace_image(cstring id, image* prev, image* next)
	{
		struct state {
			image* prev;
			image* next;
		} st = { prev, next };
		message_replace_image(id, [&st](GdkPaintable* img)->GdkPaintable* { return img == st.prev->pix ? st.next->pix : img; });
	}
	
	//Can only be called before the first message(), and only once. It's allowed to not call it at all. The scrollback must end with \n.
	void scrollback(cstring text);
	
	
	unsigned lineheight();
	
	// Call this any time the application receives a user input event.
	// Alternatively, call with its GDK event type if you don't know whether to consider that a user input event.
#ifdef ARLIB_GUI_GTK3
	void user_input(int gdk_event_type = 8);
#else
	void user_input(int gdk_event_type = 4);
#endif
	
	void on_contextmenu(function<void(array<ctxaction>& actions, cstrnul msgid)> cb) { contextmenu_cb = cb; }
	void on_internal_link(function<void(string text)> cb) { ilink_cb = cb; }
	
	//Callback can be called with the same value multiple times consecutively. The callback is responsible for discarding duplicates.
	void on_scroll_state(function<void(bool now_at_bottom)> cb) { onscroll_cb = cb; }
	
	
	static textview* create(uint32_t flags) { return new textview(flags); }
	GtkWidget* gtkwidget();
	
	~textview();
	
	static bool is_rtl(cstring text);
};
