#pragma once
#include "arlib.h"

//don't know if this is guaranteed stable, but I'd rather not include the gtk header here
typedef struct _GdkCursor GdkCursor;
typedef struct _GdkEventKey GdkEventKey;
typedef struct _GdkPixbuf GdkPixbuf;
typedef struct _GtkScrolledWindow GtkScrolledWindow;
typedef struct _GtkTextBuffer GtkTextBuffer;
typedef struct _GtkTextIter GtkTextIter;
typedef struct _GtkTextTag GtkTextTag;
typedef struct _GtkTextTagTable GtkTextTagTable;
typedef struct _GtkTextView GtkTextView;
typedef struct _GtkWidget GtkWidget;
typedef union _GdkEvent GdkEvent;

class textview : nocopy {
	GtkScrolledWindow* scrollview;
	
	GtkTextView* view;
	GtkTextTagTable* tags;
	
	GtkTextTag* t_imgalt;
	GtkTextTag* t_message;
	GtkTextTag* t_oldmessage;
	
	GtkTextTag* t_bold;
	GtkTextTag* t_underline;
	GtkTextTag* t_italics;
	GtkTextTag* t_strike;
	
	GtkTextTag* t_hyperlink;
	
	GdkCursor* c_hyperlink;
	
	map<uint32_t, GtkTextTag*> t_fgcol_map;
	map<uint32_t, GtkTextTag*> t_bgcol_map;
	
public:
	class buffer;
private:
	buffer* cur_buf;
	
	uint64_t atbottom_until_ms = 0;
	bool at_bottom = true;
	
	bool link_click = false;
	//uint32_t link_hover_offset = 0;
	
	textview();
	
	bool hyperlink_event(GtkWidget* widget, GdkEvent* event);
	//static bool populate_popup_s(GtkTextView* text_view, GtkWidget* popup, void* user_data)
	//{
	//	return ((textview*)user_data)->populate_popup(text_view, popup);
	//}
	//bool populate_popup(GtkTextView* text_view, GtkWidget* popup);
	
	GtkTextTag* t_fgcol(uint32_t xrgb);
	GtkTextTag* t_bgcol(uint32_t xrgb);
	
	void onscroll(bool allow_leave);
	
public:
	class image : nocopy {
		friend class textview;
		friend class buffer;
		GdkPixbuf* pix;
	public:
		image(arrayview<byte> bytes, size_t width, size_t height);
		~image();
	};
	struct span {
		span() {}
		span(cstring text) : text(text) {}
		
		//A span must be valid UTF-8, and may not contain NUL or CR.
		string text;
		
		//If this is non-null, 'text' isn't shown. However, it is used; it's the alt-text if copied.
		//However, most other fields do nothing (though bgcol probably works).
		//It's perfectly fine to insert the same one in multiple messages, or multiple times in the
		// same one. Don't create multiple identical images, that's a waste of RAM.
		image* img = NULL;
		
		//Hidden text shows up if copied, but isn't normally visible. Use for formatting codes, like IRC's \x02 bold.
		//Hidden images are undefined behavior.
		bool hidden = false;
		
		bool bold = false;
		bool underline = false;
		bool italics = false;
		bool strike = false;
		
		bool hyperlink = false;
		
		uint32_t fgcol = -1;
		uint32_t bgcol = -1;
	};
	class buffer : nocopy {
		friend class textview;
		textview* parent;
		GtkTextBuffer* buf;
		
		//scrollbar behavior:
		//exactly one message per channel is known as last_read
		//on message:
		//  if the old scroll position is at the bottom:
		//    after adding the message, scroll so top pixel of last_read is top of screen
		//    (if last_read is new enough, this may still be the bottom)
		//on user activity in this program (mouse move, keyboard press, give focus, etc):
		//  if said activity was switching channels:
		//    for the old channel:
		//      if the scroll position is at the bottom:
		//        set last_read to the bottom message
		//      else:
		//        set last_read to whatever message contains the top visible pixel
		//    for the new channel:
		//      scroll so top pixel of last_read is top of screen
		//  if the scroll position is at the bottom:
		//    set last_read to the bottom message
		//  if said activity was resizing the window:
		//    if old scroll position was at bottom, keep it that way
		//    otherwise, let gtk pick the new scroll position, it does a good job
		
		void scroll_to_last_read();
		bool scroll_to_last_read_cb();
		
		void move_last_read();
		
		buffer(textview* parent, cstring scrollback);
		
		void message_insert_at(GtkTextIter* iter, arrayview<span> spans);
		
	public:
		//If 'id' is nonempty and has already been seen, undefined behavior.
		//The message may contain linebreaks, but should probably not end with one.
		void message(cstring id, arrayview<span> spans);
		bool message_exists(cstring id);
		//Shrinks the old version of the message, and adds a new one.
		//If 'id' has not been seen, undefined behavior. If 'spans' is empty, no message is added,
		//TODO: this one is a slightly too tight coupling to Russian. but on the other hand, yawn.
		void message_edit_visible(cstring id, arrayview<span> spans);
		void message_delete(cstring id);
		~buffer();
	};
	
	void user_input(int gdk_event_type); // Call this any time the application receives a user input event.
	void do_scroll(GdkEventKey* event); // Call this if an input event was sent to wrong widget.
	
	//The scrollback must end with a \n.
	buffer* child(cstring scrollback) { return new buffer(this, scrollback); }
	void set_buf(buffer* buf);
	
	static textview* create() { return new textview(); }
	//it's safe to not use GTK_WIDGET(foo), defining G_DISABLE_CAST_CHECKS replaces it with a straight cast
	GtkWidget* gtkwidget() { return (GtkWidget*)scrollview; }
	
	~textview();
};
