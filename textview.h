#pragma once
#include "arlib.h"

//I don't know if this is guaranteed stable, but I'd rather not include the gtk header here
typedef struct _GdkCursor GdkCursor;
typedef struct _GdkEventKey GdkEventKey;
typedef struct _GdkPixbuf GdkPixbuf;
typedef struct _GtkScrolledWindow GtkScrolledWindow;
typedef struct _GtkMenuItem GtkMenuItem;
typedef struct _GtkTextBuffer GtkTextBuffer;
typedef struct _GtkTextIter GtkTextIter;
typedef struct _GtkTextMark GtkTextMark;
typedef struct _GtkTextTag GtkTextTag;
typedef struct _GtkTextTagTable GtkTextTagTable;
typedef struct _GtkTextView GtkTextView;
typedef struct _GtkWidget GtkWidget;
typedef union _GdkEvent GdkEvent;

class textview : nocopy {
	GtkScrolledWindow* scrollview;
	
	GtkTextView* view;
	
	bool at_bottom = true;
	
	bool link_click = false;
	int32_t link_hover_offset = 0;
	int32_t link_click_offset = 0;
	
	function<void(bool now_at_bottom)> onscroll_cb;
	
	GtkTextBuffer* buf;
	GtkTextMark* lastread; // mark is either at the start of a message, or at the end of the buffer
	
	textview();
	
	bool hyperlink_event(GtkWidget* widget, GdkEvent* event);
	bool populate_menu(GtkTextView* text_view, GtkWidget* popup);
	void menu_copy(GtkMenuItem* menuitem);
	void menu_open(GtkMenuItem* menuitem);
	
	//scrollbar behavior:
	//exactly one message per channel is known as last_read
	//on message:
	//  if the old scroll position is at the bottom:
	//    after adding the message, scroll so top pixel of last_read is top of screen
	//    (if last_read is new enough, this may still be the bottom)
	//on user activity in this program (mouse move, keyboard press, give focus, etc):
	//  set last_read to the bottom message
	//  if said activity was switching channels:
	//    do the above for both old and new channels
	//  if said activity was resizing the window:
	//    if old scroll position was at bottom, keep it that way
	//    otherwise, let gtk pick the new scroll position, it does a good job
	
	bool scroll_at_bottom();
	void onscroll(bool allow_leave);
	void scroll_to_last_read();
	void move_last_read();
	
public:
	class image : nocopy {
		friend class textview;
		friend class buffer;
		GdkPixbuf* pix;
		
		image() = delete;
		image(GdkPixbuf* pix) : pix(pix) {}
		
	public:
		//If 'bytes' is a valid image according to gdk-pixbuf, it's loaded.
		//If 'bytes' is empty or an invalid image, NULL will be returned.
		//The image may be smaller than requested, to preserve the aspect ratio of the input.
		//Deleting an image while it's in some messages is fine, the textview will copy or refcount it.
		static image* create(arrayview<uint8_t> bytes, size_t width, size_t height);
		static image* create(arrayview<uint8_t> bytes, size_t size) { return create(bytes, size, size); }
		//Fully transparent.
		static image* blank(size_t width, size_t height);
		static image* blank(size_t size) { return blank(size, size); }
		~image();
	};
	struct span {
		span() {}
		span(cstring text) : text(text) {}
		
		//A span must be valid UTF-8, and may not contain NUL or CR.
		string text;
		
		//If this is non-null, 'text' isn't shown; instead, it's the alt-text if copied.
		//Most other fields do nothing (though bgcol works).
		//It's perfectly fine to insert the same image in multiple messages, or multiple times in the
		// same one. Don't create multiple identical images, that's a waste of RAM.
		image* img = NULL;
		
		//Hidden text shows up if copied, but isn't normally visible. Use for formatting codes, like IRC's \x02 bold.
		bool hidden = false;
		
		bool bold = false;
		bool underline = false;
		bool italics = false;
		bool strike = false;
		bool monospace = false;
		
		//It is undefined behavior if a hyperlink span does not start with http:// or https://, or if it contains spaces or linebreaks.
		bool hyperlink = false;
		//An internal link will allow the caller to do something when the link is clicked. Visually, they're identical to hyperlinks.
		//A span can only be one (or zero) of hidden, image, hyperlink and ilink, with one exception:
		//A hidden ilink is allowed, if followed by a non-hidden one. If the visible one is clicked,
		// the hidden one's text will be passed to the callback, instead of the visible. The hidden one's text is not copyable.
		bool i_link = false;
		
		//NOTE: the above is 8 booleans; if adding more, slap them into bitfields instead
		
		uint32_t fgcol = -1;
		uint32_t bgcol = -1;
		
		bool is_spoiler() const
		{
			return (fgcol != (uint32_t)-1 && fgcol == bgcol);
		}
		
		int fmt_diff(const span& other) const // Ignores .img and .text.
		{
			const span& a = *this;
			const span& b = other;
			return (a.hidden != b.hidden) +
			       (a.bold != b.bold) +
			       (a.underline != b.underline) +
			       (a.italics != b.italics) +
			       (a.strike != b.strike) +
			       (a.monospace != b.monospace) +
			       (a.hyperlink != b.hyperlink) +
			       (a.fgcol != b.fgcol) +
			       (a.bgcol != b.bgcol);
		}
		bool fmt_eq(const span& other) const // Ignores .img and .text.
		{
			return this->fmt_diff(other) == 0;
		}
	};
	
private:
	//No linebreaks will be added. It's the caller's responsibility to ensure there's a linebreak before and after 'iter'.
	//After calling this, 'iter' points to the \n after the message, or to the end.
	void message_insert_at(GtkTextIter* iter, arrayview<span> spans);
	
	void message_get_bounds(cstring id, GtkTextIter* start, GtkTextIter* end);
	//'replace' must always return a pixbuf, but can return the input.
	//After calling this, both iterators point to some arbitrary point inside the message. 
	void message_replace_image(GtkTextIter* start, GtkTextIter* end, function<GdkPixbuf*(GdkPixbuf* prev)> replace);
	void message_replace_image(cstring id, function<GdkPixbuf*(GdkPixbuf* prev)> replace);
	
	GdkPixbuf* shrink_image(GdkPixbuf* prev);
public:
	
	//If 'id' is nonempty and has already been seen, undefined behavior.
	//The message may contain linebreaks, but should probably not end with one.
	void message(cstring id, arrayview<span> spans) { message_at("", false, id, spans); }
	//The message 'prev' must exist.
	void message_at(cstring prev, bool after, cstring newid, arrayview<span> spans, bool mark_read = false);
	bool message_exists(cstring id);
	//Shrinks the old version of the message, and adds a new one.
	//If 'id' has not been seen, undefined behavior. If 'spans' is empty, no message is added, it's just deemphasized.
	void message_edit_visible(cstring id, arrayview<span> spans);
	//Like the above, but doesn't leave the old version around. 'spans' must not be empty.
	void message_replace(cstring id, arrayview<span> spans);
	void message_delete(cstring id);
	//Replaces every instance of 'prev' with 'next' in the given message.
	void message_replace_image(cstring id, image* prev, image* next)
	{
		message_replace_image(id, bind_lambda([prev,next](GdkPixbuf* img)->GdkPixbuf* { return img == prev->pix ? next->pix : img; }));
	}
	
	//Can only be called before the first message(), and only once. It's allowed to not call it at all. The scrollback must end with \n.
	void scrollback(cstring text);
	
	
	unsigned lineheight();
	
	// Call this any time the application receives a user input event.
	// Alternatively, call with its GDK event type if you don't know whether to consider that a user input event.
	void user_input(int gdk_event_type = 8);
	// Call this if an input event was sent to wrong widget.
	void do_scroll(GdkEventKey* event);
	
	//Callback can be called with the same value multiple times consecutively. The callback is responsible for discarding duplicates.
	void on_scroll_state(function<void(bool now_at_bottom)> cb) { onscroll_cb = cb; }
	
	
	static textview* create() { return new textview(); }
	GtkWidget* gtkwidget();
	
	~textview();
	
	static bool is_rtl(cstring text);
};
