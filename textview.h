#pragma once
#include "russian.h"

//don't know if this is guaranteed stable, but I'd rather not include the gtk header here
typedef struct _GtkScrolledWindow GtkScrolledWindow;
typedef struct _GtkTextView GtkTextView;
typedef struct _GtkTextBuffer GtkTextBuffer;
typedef struct _GtkTextTagTable GtkTextTagTable;
typedef struct _GtkTextTag GtkTextTag;
typedef struct _GtkWidget GtkWidget;
typedef struct _GdkPixbuf GdkPixbuf;

class textview : nocopy {
	GtkScrolledWindow* scrollview;
	
	GtkTextView* view;
	GtkTextTagTable* tags;
	
	GtkTextTag* t_imgalt;
	GtkTextTag* t_message;
	
public:
	class buffer;
private:
	buffer* cur_buf;
	
	bool atbottom_allow_release;
	bool at_bottom;
	
	textview();
	
public:
	// Private, listed as public to avoid some type shenanigans.
	void _priv_scrolled();
	void _priv_user_input(int gdk_event_type, int scrolldir);
	
	class image : nocopy {
		friend class textview;
		friend class buffer;
		GdkPixbuf* pix;
	public:
		image(arrayview<byte> bytes, size_t width, size_t height);
		~image();
	};
	struct span {
		span() {}
		span(cstring text) : text(text) {}
		string text;
		
		//If this is non-null, 'text' isn't shown. However, it is used; it's the alt-text if copied.
		//However, most other fields do nothing (though bgcol probably works).
		//It's perfectly fine to insert the same one in multiple messages, or multiple times in the
		// same one. Don't create multiple identical images, that's a waste of RAM.
		image* img = NULL;
		
		//Hidden text shows up if copied, but isn't normally visible. Use for formatting codes, like IRC's \x02 bold.
		//Hidden images are undefined behavior.
		bool hidden = false;
		
		bool bold = false;
		bool underline = false;
		bool italics = false;
		bool strike = false;
		
		static const uint32_t colors[16];
		uint8_t fgcol = -1;
		uint8_t bgcol = -1;
	};
	class buffer : nocopy {
		friend class textview;
		textview* parent;
		GtkTextBuffer* buf;
		
		//scrollbar behavior:
		//exactly one message per channel is known as last_read
		//on message:
		//  if the old scroll position is at the bottom:
		//    after adding the message, scroll so top pixel of last_read is top of screen
		//    (if last_read is new enough, this may still be the bottom)
		//on user activity in this program (mouse move, keyboard press, give focus, etc):
		//  if said activity was switching channels:
		//    for the old channel:
		//      if the scroll position is not at the bottom:
		//        set last_read to whatever message contains the top visible pixel
		//      else:
		//        set last_read to the top message
		//    for the new channel:
		//      scroll so top pixel of last_read is top of screen
		//  if the scroll position is at the bottom:
		//    set last_read to the bottom message
		//  if said activity was resizing the window:
		//    if old scroll position was at bottom, keep it that way
		//    otherwise, let gtk pick the new scroll position, it does a good job
		
		void scroll_to_last_read();
		bool scroll_to_last_read_cb();
		
		void move_last_read();
		
		buffer(textview* parent);
		
	public:
		//If 'id' is nonempty and has already been seen, it will be replaced.
		//The message may contain linebreaks, but should probably not end with one.
		void message(cstring id, arrayview<span> spans);
		~buffer();
	};
	
	void user_input(int gdk_event_type); // Call this any time the application receives a user input event.
	buffer* child() { return new buffer(this); }
	void set_buf(buffer* buf);
	
	static textview* create() { return new textview(); }
	//it's safe to not use GTK_WIDGET(foo), defining G_DISABLE_CAST_CHECKS replaces it with a straight cast
	GtkWidget* gtkwidget() { return (GtkWidget*)scrollview; }
	
	~textview();
};
