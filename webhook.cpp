#include "russian.h"

namespace russian {
namespace {

class webhook : public protocol {
public:

struct data {
	string baseurl;
	unsigned timeout_ms;
};
map<string, data> m_commands;

webhook(impl* parent, json5deserializer2& s) : protocol(parent, 0)
{
	SER_ENTER(s)
	{
		SER_NAME(s, "cmds")
		{
			SER_ENTER_ARRAY(s)
			{
				cstring name;
				cstring baseurl;
				double timeout = 5.0;
				SER_ENTER(s)
				{
					s.item("name", name);
					s.item("url", baseurl);
					s.item("timeout", timeout);
				}
				m_commands.insert(name, { baseurl, (unsigned)(timeout*1000) });
			}
		}
	}
}

ga_handle_t global_action(chanbase& at, uint32_t serial, cstrnul text) override
{
	data* d = nullptr;
	auto m = REGEX("/([^\\s]+)\\s?(.*)").match(text);
	if (m)
		d = m_commands.get_or_null((cstring)m[1]);
	if (d)
	{
		string url = d->baseurl + http_t::urlencode((cstring)m[2]);
		runloop2::detach([](webhook* self, data* d, string url, chanbase* at, uint32_t serial) -> async<void> {
			http_t http;
			http.wrap_socks(&autoproxy::socket_create_sslmaybe);
			http_t::req q = { .loc=url };
			variant<http_t::rsp, void> vr = co_await multi_waiter(http.request(q), runloop2::in_ms(d->timeout_ms));
			if (!self->channel_valid(at, serial)) co_return;
			
			cstring text;
			string tmp;
			
			if (vr.contains<void>())
				text = "Timeout";
			else if (http_t::rsp r = vr.get_destruct<http_t::rsp>())
			{
				if (r.header("Content-Type").startswith("text/"))
				{
					tmp = r.text_take();
					text = tmp;
				}
				else
					text = "Unexpected Content-Type";
				
				while (text.endswith("\n")) text = text.substr(0, ~1);
				
				if (!text)
					text = "Empty response";
			}
			else
			{
				tmp = "Error "+tostring(r.status);
				text = tmp;
			}
			
			array<span> sp;
			sp.append({ "* " });
			parse_irc(sp, span(), text);
			at->message(chanbase::imp_scrollback, time(NULL), sp);
		}(this, d, std::move(url), &at, serial));
		return ga_handled;
	}
	return ga_not_handled;
}

void action(chanbase& at, cstrnul text) override {} // no channels in this protocol
void close_chan(chanbase& at) override {} // which also makes this one useless

};

}
protocol*
protocol::create_webhook(impl* parent, json5deserializer2& s) { return new webhook(parent, s); }
}
