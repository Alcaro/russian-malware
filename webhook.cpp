#include "russian.h"

namespace russian {
namespace {

class webhook : public protocol {
public:

struct data {
	string baseurl;
	unsigned timeout_ms;
	HTTP http = runloop::global();
};
map<string, data> m_commands;

webhook(impl* parent, bmldeserializer& s, cstring name) : protocol(parent, 0)
{
	while (s.has_item())
	{
		data& item = m_commands.insert(s.name());
		s.item([&](bmldeserializer& s, cstring name) {
				item.baseurl = name;
				double d = 5.0;
				s.items("timeout", d);
				item.timeout_ms = d*1000;
			});
	}
}

ga_handle_t global_action(chanbase& at, uint32_t serial, cstrnul text) override
{
	data* d = nullptr;
	auto m = REGEX("/([^\\s]+)\\s?(.*)").match(text);
	if (m)
		d = m_commands.get_or_null((cstring)m[1]);
	if (d)
	{
		HTTP::req r;
		r.url = d->baseurl + HTTP::urlencode((cstring)m[2]);
		r.limit_ms = d->timeout_ms;
		d->http.send(std::move(r), [this, &at, serial](HTTP::rsp r){
			if (!channel_valid(&at, serial)) return;
			
			cstring text;
			string tmp;
			
			if (r.success())
			{
				if (r.header("Content-Type").startswith("text/"))
					text = r.text();
				else
					text = "Unexpected Content-Type";
				
				while (text.endswith("\n")) text = text.substr(0, ~1);
				
				if (!text)
					text = "Empty response";
			}
			else
			{
				tmp = "Error "+tostring(r.status);
				text = tmp;
			}
			
			array<span> sp;
			sp.append({ "* " });
			parse_irc(sp, span(), text);
			at.message(chanbase::imp_scrollback, time(NULL), sp);
		});
		return ga_handled;
	}
	return ga_not_handled;
}

void action(chanbase& at, cstrnul text) override {} // no channels in this protocol
void begin_private(chanbase& at, cstrnul name) override {} // which also makes these two useless
void close_chan(chanbase& at) override {}

};

}
protocol*
protocol::create_webhook(impl* parent, bmldeserializer& s, cstring name) { return new webhook(parent, s, name); }
}
