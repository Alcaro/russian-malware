#!/usr/bin/env python3

import os

# TODO: use global variables instead, so resources can be added and deleted without rebuilding
# TODO: switch to std::embed once it exists

use_incbin = True  # Massively speeds up build times if resources are big, but may reduce portability.
# use_incbin = False  # TODO: autodetect target output format, disable if not ELF or not GCC

header = '// Autogenerated, do not edit. All changes will be undone.\n'
body = header
w32_res = header

header += '#include <stdint.h>\n#include "../arlib/image.h"\nstruct resources {\nresources();\n'
body += '#include "resources.h"\n'
constructor = "resources::resources()\n{\n"
asm = ""

if use_incbin:
	body += r"""
#if defined(__unix__)
#define ASM_INCLUDE(varname, size, filename) \
	".section .rodata." varname ",\"a\",@progbits\n" \
	".size " varname ", " #size "\n" \
	".type " varname ", @object\n" \
	varname ":\n" \
	".incbin \"" filename "\"\n"
#elif defined(_WIN32)
#define ASM_INCLUDE(varname, size, filename) \
	".section .rdata$" varname ",\"dr\"\n" \
	varname ":\n" \
	".incbin \"" filename "\"\n"
#endif

"""

icon_names = {}  # { 0: "minir" } (0 is exe's icon, others are usable for file associations)
icon_paths = {}  # { 0: { 48: "resources/minir.icon-48.png", 32: etc, 16: etc } }

for fn in sorted(os.listdir("resources/")):
	if fn.startswith("x-"): continue
	fullfn = "resources/"+fn
	filesize = os.path.getsize(fullfn)
	
	# split on first period, not last, so 'monospace.font.png' becomes item 'monospace' of extension 'font.png'
	sfn,ext = fn.split(".",1)
	sfn = sfn
	
	varname = sfn.replace("-","_")
	varname_raw = varname+"_raw"
	
	if ext == "png":
		header += "image "+varname+";\n"
		constructor += varname+".init_decode_png("+varname_raw+");\n"
	elif ext == "jpg":
		header += "image "+varname+";\n"
		constructor += varname+".init_decode_jpg("+varname_raw+");\n"
	elif ext == "font.png":
		header += "font "+varname+";\n"
		constructor += "{ image font_tmp; font_tmp.init_decode_png("+varname_raw+"); "+varname+".init_from_image(font_tmp); }\n"
	elif ext == "bin":
		varname_raw = varname
	elif ext.startswith("icon"):
		if not ext.endswith(".png"): 1/0
		# bps.icon2-16.png
		icoid,icosize = ext[4:].split("-")
		icoid = int("0"+icoid) # "0"+ so blank becomes 0
		icosize = int(icosize.rsplit(".",1)[0])
		
		if icoid in icon_names:
			assert(sfn == icon_names[icoid])
		else:
			icon_names[icoid] = sfn
			icon_paths[icoid] = {}
		icon_paths[icoid][icosize] = fullfn
		
		continue
	else:
		print("Unknown file type "+ext)
		1/0
	
	if use_incbin:
		asmname = "_ZN9resources"+str(len(varname_raw))+varname_raw+"E"
		# sticking everything in separate sections doesn't do much when the resources' constructors autodecode them, but why not
		asm += 'ASM_INCLUDE("'+asmname+'", '+str(filesize)+', "resources/'+fn+'")\n'
	else:
		with open(fullfn, "rb") as f:
			b = f.read()
			body += "const uint8_t resources::"+varname_raw+"["+str(len(b))+"] = { "
			body += ",".join(str(n) for n in b)
			body += " };\n"
	
	header += "static const uint8_t "+varname_raw+"["+str(filesize)+"];\n"

asm += '".text"\n'
header += "};\n"
body += constructor + "}\n"

if use_incbin:
	body += '__asm__(\n'+asm+');\n'

# PNG-style .ico requires Vista or higher, but BMP-style requires messing with PIL (and BMP is bigger), so let's just use PNG
# (also not supported in GdkPixbuf, though Wine supports it since 2010. https://github.com/wine-mirror/wine/commit/666940902db2c693
#    https://gitlab.gnome.org/GNOME/gdk-pixbuf/-/issues/16 https://gitlab.gnome.org/GNOME/gdk-pixbuf/-/blob/master/gdk-pixbuf/io-ico.c)
for icoid in sorted(icon_paths):
	import struct
	
	w32_res += str(icoid)+' ICON DISCARDABLE "obj/ico'+str(icoid)+'.ico"\n'
	
	ico_head = struct.pack("<HHH", 0, 1, len(icon_paths[icoid]))
	ico_body = bytearray()
	ico_head_size = 6+16*len(icon_paths[icoid])
	
	for icosize in sorted(icon_paths[icoid], reverse=True):
		with open(icon_paths[icoid][icosize], "rb") as f:
			b = bytearray(f.read())
			ico_head += struct.pack("<BBBBHHII", icosize&255, icosize&255, 0, 0, 1, 0, len(b), ico_head_size+len(ico_body))
			ico_body += b
	
	with open('obj/ico'+str(icoid)+'.ico',"wb") as f:
		f.write(ico_head)
		f.write(ico_body)

with open("obj/resources.h", "wt") as f: f.write(header)
with open("obj/resources.cpp", "wt") as f: f.write(body)
with open("obj/icons.rc", "wt") as f: f.write(w32_res)
