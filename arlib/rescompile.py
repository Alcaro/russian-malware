#!/usr/bin/env python3

import os, struct, zlib

# silly tricks so __pycache__ goes away
# why is there no programmatic control over that thing, other than setting an env and reexecing? why is it not a dotfile?
# why does it even exist? no other scripting language I'm aware of does that, other than memory-only things
__name__ = "not __main__"
exec(open(os.path.dirname(__file__)+"/redeflate.py","rt").read())
#from redeflate import deflate_slow

use_incbin = True  # Massively speeds up compile time if resources are big, but may reduce portability.
# use_incbin = False  # TODO: autodetect target output format, disable if not GCC
# TODO: more std::embed, once it exists

header_early = '// Autogenerated, do not edit. All changes will be undone.\n'
body_early = header_early
w32_res = header_early

header_early += '#pragma once\n#include "../arlib.h"\n'
header = 'namespace resources {\nvoid init();\n'
body_early += '#include "resources.h"\nnamespace resources {\n'
body = ""
body_late = ""
constructor = ""
constructor_late = ""
asm = ""

asm_image_structs = ""
asm_image_first = None
imgbytes_decomp = bytearray()
imgbuf_size = 0
imgbuf_size_buf = 0
img_types = {}
img_type_names = ["IMG_0F", "IMG_17", "IMG_1F", "IMG_80", "IMG_81", "IMG_83", "IMG_87", "IMG_8F", "IMG_BARGB", "IMG_NOT_BARGB"]

if use_incbin:
	body += r"""
#if defined(__unix__)
#  define ASM_RODATA(text) \
     __asm__(".section .rodata,\"a\",@progbits\n" text ".text\n")
#  define ASM_LABEL(varname, size) \
     ".globl " varname "\n" \
     ".size " varname ", " STR(size) "\n" \
     ".type " varname ", @object\n" \
     varname ":\n"
#else
#  define ASM_RODATA(text) __asm__(".section .rdata,\"dr\"\n" text ".text\n")
#  define ASM_LABEL(varname, size) varname ":\n"
#endif

#if UINTPTR_MAX == UINT64_MAX
#  define ASM_POINTER ".quad "
#  define ASM_POINTER_SIZE 8
#else
#  define ASM_POINTER ".int "
#  define ASM_POINTER_SIZE 4
#endif

#  define ASM_INCLUDE_LIST(text) ASM_RODATA(text)
#  define ASM_INCLUDE(varname, size, filename) \
     ASM_LABEL(varname, size) \
     ".incbin \"" filename "\"\n"
"""
	
	body_imgdecode = r"""
#if END_LITTLE
#  define ifmt_argb8888_c ifmt_bgra8888_by_c
#else
#  define ifmt_argb8888_c ifmt_argb8888_by_c
#endif
#define ifmt_argb8888_by_c 3
#define ifmt_bgra8888_by_c 5
#define ifmt_bargb8888_c 8
#define ifmt_xrgb8888_c 6
static_assert(ifmt_argb8888_by_c == ifmt_argb8888_by);
static_assert(ifmt_bgra8888_by_c == ifmt_bgra8888_by);
static_assert(ifmt_bargb8888_c == ifmt_bargb8888);
static_assert(ifmt_xrgb8888_c == ifmt_xrgb8888);

#define ASM_IMAGE_LIST(bufsize, text) \
    __asm__(".bss\n" \
    ".balign 4\n" \
    ASM_LABEL("_ZN9resources15imgbuf_inflatedE", bufsize) \
    ".zero " STR(bufsize) "\n"); \
    ASM_RODATA(text)
#define ASM_IMAGE(varname, width, height, format_c, ptr) \
    ".globl " varname "\n" \
    ASM_LABEL(varname, ASM_POINTER_SIZE) \
    ".int " #width "," #height "," STR(format_c) "," #width "*4\n" \
    ASM_POINTER ptr "\n"

static void decomp_images(image * imgs, uint8_t * inflate_buf, uint8_t * inflate_buf_end, const uint8_t * deflated, size_t deflated_size)
{
	__asm__("" : "+r"(imgs)); // iterating a pointer to a single object is undefined behavior, force gcc to forget it's not an array
	uint32_t palette[(IMG_8F || IMG_87) ? 256 : 16];
	inflator::inflate(bytesw(inflate_buf, inflate_buf_end-inflate_buf), bytesr(deflated, deflated_size));
	while (inflate_buf != inflate_buf_end)
	{
		uint8_t head = *inflate_buf++;
		
		uint32_t transp = 0;
		
		// these IMG_ constants allow dead code elimination of unused image formats
		// they're also why this function is in a Python string rather than a normal cpp - can't DCE across files
		if (head&0x80)
		{
			if (IMG_8F && head == 0x8F) // grayscale
			{
				for (int i=0;i<256;i++) palette[i] = 0xFF000000 + i*0x010101;
			}
			else if (IMG_80 || IMG_81 || IMG_83 || IMG_87)
			{
				int len;
				if (IMG_87 && head == 0x87) len = *inflate_buf++;
				else if (IMG_80 || IMG_81 || IMG_83) len = (head&0x7F)>>3;
				else __builtin_unreachable();
				
				for (int i=0;i<=len;i++)
				{
					palette[i] = readu_le32(inflate_buf);
					inflate_buf += 4;
				}
			}
			else __builtin_unreachable();
			head &= 0x87; // mask out palette length
		}
		else if (IMG_BARGB && imgs->fmt == ifmt_bargb8888)
		{
			transp = readu_le32(inflate_buf);
			inflate_buf += 4;
		}
		else if (IMG_NOT_BARGB) {}
		else __builtin_unreachable();
		
		size_t line_size_raw = (((head&0x1F)+1) * imgs->width + 7) >> 3;
		size_t filtered_size = (line_size_raw+1) * imgs->height;
		size_t defiltered_line_size = line_size_raw+4;
		size_t defiltered_size = defiltered_line_size * imgs->height;
		
		uint8_t * defilter_start = inflate_buf + filtered_size - defiltered_size;
		
		image::png_defilter(defilter_start, defiltered_line_size, inflate_buf, ((head&0x1F)+7)>>3, line_size_raw, imgs->height);
		defilter_start += 4;
		
		if(0);
		else if (IMG_0F && head == 0x0F) imgs->png_unpack_rgb<4>(defilter_start, defiltered_line_size);
		else if (IMG_17 && head == 0x17) imgs->png_unpack_rgb<2>(defilter_start, defiltered_line_size);
		else if (IMG_1F && head == 0x1F) imgs->png_unpack_rgb<6>(defilter_start, defiltered_line_size);
		else if (IMG_80 && head == 0x80) imgs->png_unpack_plte<1>(defilter_start, defiltered_line_size, palette, -1);
		else if (IMG_81 && head == 0x81) imgs->png_unpack_plte<2>(defilter_start, defiltered_line_size, palette, -1);
		else if (IMG_83 && head == 0x83) imgs->png_unpack_plte<4>(defilter_start, defiltered_line_size, palette, -1);
		else if ((IMG_87 || IMG_8F) && head == 0x87) imgs->png_unpack_plte<8>(defilter_start, defiltered_line_size, palette, -1);
		else __builtin_unreachable();
		
		if (transp != 0)
		{
			uint32_t * px = imgs->pixels32;
			size_t n = imgs->width * imgs->height;
			while (n--)
			{
				if (px[n] == transp) px[n] &= 0x00FFFFFF;
			}
		}
		
		inflate_buf += filtered_size;
		imgs++;
	}
}

"""


def asmmangle(name): return "_ZN9resources"+str(len(name))+name+"E"


# Assumes its input is a valid, normal PNG, will misbehave arbitrarily if it's not.
# There are some sanity checks, but not all weird inputs are rejected.
# Will also reject some valid PNGs, if they're poorly optimized. Run them through e.g. zopflipng.
# Returns { "width": 123, "height": 123, "fmt": "ifmt_xrgb8888", "bytes": bytes(), "buf_tail": 0 }
# Uncompressed size is width*height*sizeof(uint32_t).
# buf_tail is how many bytes of scratch space must exist between the end of compressed data and uncompressed.
#  Often zero; only nonzero on format 6, width <= 3, and format 0 with padding on the last byte.
def disassemble_png(pngbytes, imgtypes):
	if pngbytes[0:8] != b"\x89PNG\r\n\x1A\n": 1/0
	pngbytes = pngbytes[8:]
	
	chunks = {}
	while pngbytes:
		sz,ty = struct.unpack(">I4s", pngbytes[0:8])
		if ty in chunks: ty/0  # hits if, for example, image contains multiple IDAT. optimize your png better
		chunks[ty.decode("ASCII")] = pngbytes[8 : 8+sz]
		pngbytes = pngbytes[8+sz+4:]
	
	width, height, bits_per_sample, color_type, comp_meth, filter_meth, interlace_meth = struct.unpack(">IIBBBBB", chunks["IHDR"])
	
	if comp_meth != 0 or filter_meth != 0 or interlace_meth != 0: 1/0  # not supported and/or not allowed by png standard
	if bits_per_sample != 8 and color_type != 3 and color_type != 0: 1/0
	if bits_per_sample not in (1,2,4,8): 1/0
	
	palette = []
	tRNS = chunks.get("tRNS", b"")
	PLTE = chunks.get("PLTE", b"")
	rgb_trns = None
	
	if color_type == 0:
		color_type = 3
		if bits_per_sample == 1: palette = [ 0xFF000000, 0xFFFFFFFF ]
		if bits_per_sample == 2: palette = [ 0xFF000000, 0xFF555555, 0xFFAAAAAA, 0xFFFFFFFF ]
		if bits_per_sample == 4: palette = [ 0xFF000000, 0xFF111111, 0xFF222222, 0xFF333333,
		                                     0xFF444444, 0xFF555555, 0xFF666666, 0xFF777777,
		                                     0xFF888888, 0xFF999999, 0xFFAAAAAA, 0xFFBBBBBB,
		                                     0xFFCCCCCC, 0xFFDDDDDD, 0xFFEEEEEE, 0xFFFFFFFF ]
		if bits_per_sample == 8: color_type = 0
		arlfmt = "ifmt_xrgb8888"
		if tRNS:
			col, = struct.unpack(">H", tRNS)
			if col:
				print("ERROR png grayshort tRNS",imgname)
				1/0
			if bits_per_sample==8:
				print("ERROR png grayfull tRNS",imgname)
				1/0
			palette[0] = 0x00000000
			arlfmt = "ifmt_bargb8888"
	elif color_type == 1: 1/0  # grayscale palette isn't a thing
	elif color_type == 2:  # rgb
		if tRNS:
			arlfmt = "ifmt_bargb8888"
			r,g,b = struct.unpack(">HHH", tRNS)
			if r or g or b:
				print("ERROR png rgb tRNS",imgname)
				1/0
			rgb_trns = 0xFF000000
		else: arlfmt = "ifmt_xrgb8888"
	elif color_type == 3:  # palette
		for i in range(0,len(PLTE),3):
			palette.append(0xFF000000+int.from_bytes(PLTE[i:i+3], byteorder="big"))
		if tRNS:
			if 255 in tRNS: 1/0  # optimize your tRNS chunk better
			if all(b==0 for b in tRNS): arlfmt = "ifmt_bargb8888"
			else: arlfmt = "ifmt_argb8888"
			for i in range(len(tRNS)):
				palette[i] = (palette[i]&0x00FFFFFF)|(tRNS[i]<<24)
		else: arlfmt = "ifmt_xrgb8888"
	elif color_type == 4: arlfmt = "ifmt_argb8888"  # gray with alpha
	elif color_type == 5: 1/0  # palette with alpha isn't a thing
	elif color_type == 6: arlfmt = "ifmt_argb8888"  # rgba
	else: 1/0  # invalid png
	
	imgtypes[[None,None,"IMG_17",None,"IMG_0F",None,"IMG_1F"][color_type]] = True
	
	by = bytearray(zlib.decompress(chunks["IDAT"][2:-4], wbits=-15))
	if by[0] == 2: by[0] = 0  # Up on first scanline just predicts zeroes, so set prediction to None
	if by[0] == 3: 1/0  # average, makes little if any sense for first scanline (if it hits, I'll have to unpack it manually)
	if by[0] == 4: by[0] = 1  # Paeth on first scanline predicts left, so set prediction to Left
	
	samples_per_px = (0x04021301 >> (color_type*4))&15
	bytes_per_line_raw = (bits_per_sample*samples_per_px*width + 7)//8
	
	pixels_size = 4*width*height
	
	# unpacking is done to the end of inflated data
	# unpacked data must start at or before the pixel data
	bytes_packed = (4+bytes_per_line_raw)*height
	bytes_pad = max(bytes_packed-pixels_size, 0)
	
	# pixel data overflows if a paletted image isn't an integer number of pixels
	if color_type == 3:
		pixels_per_byte = 8 // bits_per_sample
		pixels_overflow = (-width) % pixels_per_byte
		bytes_pad = max(bytes_pad, 4*pixels_overflow)
	
	ret = bytearray()
	
	# header byte:
	# 0x80 - palette bit
	# if true: 0x78 - palette size minus 1
	#          0x07 - bits per pixel minus 1
	#  exactly 0x87 - palette length follows
	#  exactly 0x8F - the grayscale palette
	# if false: 0x60 - unused
	#           0x1F - bits per pixel minus 1
	
	log2_bits_per_sample = {8:3,4:2,2:1,1:0}[bits_per_sample]
	if color_type == 3:
		if bits_per_sample < 8: ret.append(0x80 | (len(palette)-1)<<3 | (bits_per_sample-1))
		else: ret.append(0x87, len(palette)-1)
		imgtypes[["IMG_80","IMG_81","IMG_83","IMG_87"][log2_bits_per_sample]] = True
	elif color_type == 0:
		ret.append(0x8F)
		imgtypes["IMG_8F"] = True
	else: ret.append(8 * samples_per_px - 1)
	
	ret += b''.join(struct.pack("<I",n) for n in palette)
	
	if rgb_trns is not None:
		imgtypes["IMG_BARGB"] = True
		ret += struct.pack("<I",rgb_trns)
	else:
		imgtypes["IMG_NOT_BARGB"] = True
	
	ret += by
	return { "width": width, "height": height, "fmt": arlfmt, "bytes": ret, "buf_tail": bytes_pad }


icon_names = {}  # { 0: "minir" } (0 is exe's icon, others are usable for file associations)
icon_paths = {}  # { 0: { 48: "resources/minir.icon-48.png", 32: etc, 16: etc } }

for fn in sorted(os.listdir("resources/")):
	if fn.startswith("x-"): continue
	fullfn = "resources/"+fn
	filesize = os.path.getsize(fullfn)
	
	# split on first period, not last, so 'monospace.font.png' becomes item 'monospace' of extension 'font.png'
	sfn,ext = fn.split(".",1)
	sfn = sfn
	
	varname = sfn.replace("-","_")
	varname_raw = varname+"_raw"
	
	file_bytes = None
	raw_private = False
	
	if 0: 1/0
	# enable this only if investigating bugs in the png dissector or adding support for a new platform
	elif ext == "png" and False:
		header += "extern oimage "+varname+";\n"
		body += "oimage "+varname+";\n"
		constructor += varname+".init_decode_png("+varname_raw+");\n"
	elif fn == "images.deflate": continue
	elif ext == "png":
		with open(fullfn, "rb") as f:
			pnginf = disassemble_png(f.read(), img_types)
		
		asm_image_structs += "ASM_IMAGE(\""+asmmangle(varname)+"\","+str(pnginf["width"])+","+str(pnginf["height"])+","+\
		                     pnginf["fmt"]+"_c,\""+asmmangle("imgbuf_inflated")+"+"+str(imgbuf_size)+"\")\n"
		
		imgbytes_decomp += pnginf["bytes"]
		imgbuf_size += 4*pnginf["width"]*pnginf["height"]
		imgbuf_size_buf = max(imgbuf_size_buf, imgbuf_size+pnginf["buf_tail"])
		header += "extern const image "+varname+";\n"
		
		fullfn = None
		if not asm_image_first: asm_image_first = varname
	elif ext == "jpg":
		# init_decode_jpg doesn't exist, but...
		header += "image "+varname+";\n"
		constructor += varname+".init_decode_jpg("+varname_raw+");\n"
	elif ext == "bin" or ext.startswith("raw."):
		varname_raw = varname
	elif ext == "cpp":
		with open(fullfn, "rt") as f:
			text = f.read()
		fullfn = None
		parts = text.split("//@")
		if parts[0]: 1/0
		for part in parts[1:]:
			ty,text = part.split("\n",1)
			ty = ty.strip()
			if ty == "header":
				for line in text.split("\n"):
					if not line: continue
					if line[0] == '#': header_early += line+"\n"
					else: header += line+"\n"
			elif ty == "body":
				body_late += text
			elif ty == "constructor":
				constructor_late += "{\n"+text+"}\n"
			else:
				1/0
	elif ext.startswith("icon"):
		if not ext.endswith(".png"): 1/0
		# minir.icon2-48.png
		icoid,icosize = ext[4:].split("-")
		icoid = int("0"+icoid) # "0"+ so blank becomes 0
		icosize = int(icosize.rsplit(".",1)[0])
		
		if icoid in icon_names:
			assert(sfn == icon_names[icoid])
		else:
			icon_names[icoid] = sfn
			icon_paths[icoid] = {}
		icon_paths[icoid][icosize] = fullfn
		
		continue
	else:
		print("Unknown file type "+ext)
		1/0
	
	
	if fullfn is None:
		continue
	
	if file_bytes is not None:
		fullfn = "obj/resource-"+varname+".bin"
		with open(fullfn,"wb") as f: f.write(file_bytes)
		filesize = len(file_bytes)
	
	if use_incbin:
		asm += 'ASM_INCLUDE("'+asmmangle(varname_raw)+'", '+str(filesize)+', "'+fullfn+'")\n'
	else:
		with open(fullfn, "rb") as f:
			b = f.read()
			body += "extern const uint8_t "+varname_raw+"["+str(len(b))+"] = { "
			body += ",".join(str(n) for n in b)
			body += " };\n"
	
	header += "extern const uint8_t "+varname_raw+"["+str(filesize)+"];\n"

if imgbytes_decomp:
	body += body_imgdecode
	
	try:
		imgbytes_comp = open("resources/images.deflate","rb").read()
	except:
		imgbytes_comp = None
	if not imgbytes_comp or zlib.decompress(imgbytes_comp, wbits=-15) != imgbytes_decomp:
		imgbytes_comp = deflate_slow(imgbytes_decomp)
		open("resources/images.deflate","wb").write(imgbytes_comp)
	imgbytes_comp_len = len(imgbytes_comp)
	
	for k in img_types:
		if k not in img_type_names and k is not None: 1/0  # I typoed something
	for v in img_type_names:
		body_early += "#define "+v+" "+str(int(img_types.get(v,False)))+"\n"
	
	asm += 'ASM_INCLUDE("'+asmmangle("images_deflate")+'", '+str(len(imgbytes_comp))+', "resources/images.deflate")\n'
	body += "extern uint8_t imgbuf_inflated["+str(imgbuf_size_buf)+"];\n"
	body += "extern const uint8_t images_deflate["+str(len(imgbytes_comp))+"];\n"
	constructor += "decomp_images((image*)&"+asm_image_first+", imgbuf_inflated+"+str(imgbuf_size_buf-len(imgbytes_decomp))+ \
	               ", imgbuf_inflated+"+str(imgbuf_size_buf)+", images_deflate, sizeof(images_deflate));\n"

header = header_early + header + "}\n"
if constructor:
	constructor = "RUN_ONCE_FN(init_inner)\n{\n" + constructor + constructor_late + "}\n"
	constructor += "void init() { init_inner(); }\n"
body = body_early + body + body_late + constructor + "}\n"

if use_incbin and asm: body += 'ASM_INCLUDE_LIST(\n'+asm+');\n'
if imgbytes_decomp: body += 'ASM_IMAGE_LIST('+str(imgbuf_size_buf)+',\n'+asm_image_structs+');\n'

# PNG-style .ico requires Vista or higher, but BMP-style requires messing with PIL or zlib (and BMP is bigger), so let's just use PNG
# (also not supported in GdkPixbuf, though Wine supports it since 2010. https://github.com/wine-mirror/wine/commit/666940902db2c693
#    https://gitlab.gnome.org/GNOME/gdk-pixbuf/-/issues/16 https://gitlab.gnome.org/GNOME/gdk-pixbuf/-/blob/master/gdk-pixbuf/io-ico.c)
for icoid in sorted(icon_paths):
	import struct
	
	w32_res += str(icoid)+' ICON DISCARDABLE "obj/ico'+str(icoid)+'.ico"\n'
	
	ico_head = struct.pack("<HHH", 0, 1, len(icon_paths[icoid]))
	ico_body = bytearray()
	ico_head_size = 6+16*len(icon_paths[icoid])
	
	for icosize in sorted(icon_paths[icoid], reverse=True):
		with open(icon_paths[icoid][icosize], "rb") as f:
			b = bytearray(f.read())
			ico_head += struct.pack("<BBBBHHII", icosize&255, icosize&255, 0, 0, 1, 0, len(b), ico_head_size+len(ico_body))
			ico_body += b
	
	with open('obj/ico'+str(icoid)+'.ico',"wb") as f:
		f.write(ico_head)
		f.write(ico_body)

with open("obj/resources.h", "wt") as f: f.write(header)
with open("obj/resources.cpp", "wt") as f: f.write(body)
with open("obj/icons.rc", "wt") as f: f.write(w32_res)
