#if 0
gcc -std=c89 -O3 shitty-server.c -o /usr/local/sbin/shitty-server
exit
#endif
/*
 * Shitty Server: an unusually agressive Discard Protocol server <https://en.wikipedia.org/wiki/Discard_Protocol>
 * it reads and discards all your data as long as you feed it regularly
 * after a few seconds of idling (at least 5), it drops your connection on the floor, without a FIN or anything
 * probably somewhat useful to test your program's resilience against network failures
 *
 * system requirements: requires linux and root because TCP_REPAIR demands that, and because port 9 is privileged
 * if you need to test a windows program against dropped sockets, run this on another machine, possibly a virtual machine
 * or if you just want a quick test, you may use my instance: floating.muncher.se:9 or :99
 *
 * license: WTFPL, any version (for this file only, the rest of this directory is differently licensed)
 *
 * further reading: http://oroboro.com/dealing-with-network-port-abuse-in-sockets-in-c
 */

/* feel free to replace with port 99 if you want to test in firefox or something */
/* while 9 is Discard Protocol, it's also Wake-on-LAN, which is generally not a desirable port to let browsers poke */
#ifndef PORTNR
#define PORTNR 9
#endif

#define _GNU_SOURCE
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <stdio.h>
#include <time.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>

#ifndef NO_SECCOMP
#include <stddef.h>
#include <sys/prctl.h>
#include <linux/audit.h>
#include <linux/filter.h>
#include <linux/seccomp.h>
#endif

#ifndef DEBUG
#define DEBUG 0
#endif

#ifndef bool
#define bool int
#endif
#ifndef true
#define true 1
#endif
#ifndef false
#define false 0
#endif

static int listen_create(int port)
{
	struct sockaddr_in sa;
	int fd;
	int status;
	
	memset(&sa, 0, sizeof(sa));
	sa.sin_family = AF_INET;
	sa.sin_addr.s_addr = htonl(INADDR_ANY);
	sa.sin_port = htons(port);
	
	fd = socket(AF_INET, SOCK_STREAM, 0);
	if (fd < 0)
	{
		perror("socket");
		return -1;
	}
	status = bind(fd, (struct sockaddr*)&sa, sizeof(sa));
	if (status < 0)
	{
		perror("bind");
		return -1;
	}
	status = listen(fd, 10);
	if (status < 0)
	{
		perror("listen");
		return -1;
	}
	
	return fd;
}

#ifndef NO_SECCOMP
static bool add_seccomp()
{
	static const struct sock_filter filter[] = {
/* source code (assemble with bpfasm.py in the sandbox):

let arch = (offsetof(struct seccomp_data, arch))
let sysno = (offsetof(struct seccomp_data, nr))
let arg1l = (offsetof(struct seccomp_data, args[0]))
let arg1h = (offsetof(struct seccomp_data, args[0])+4)
let arg2l = (offsetof(struct seccomp_data, args[1]))
let arg2h = (offsetof(struct seccomp_data, args[1])+4)
let arg3l = (offsetof(struct seccomp_data, args[2]))
let arg3h = (offsetof(struct seccomp_data, args[2])+4)
let arg4l = (offsetof(struct seccomp_data, args[3]))
let arg4h = (offsetof(struct seccomp_data, args[3])+4)
let arg5l = (offsetof(struct seccomp_data, args[4]))
let arg5h = (offsetof(struct seccomp_data, args[4])+4)
let arg6l = (offsetof(struct seccomp_data, args[5]))
let arg6h = (offsetof(struct seccomp_data, args[5])+4)

defines /usr/include/x86_64-linux-gnu/asm/unistd_64.h

ld [arch]
jne #AUDIT_ARCH_X86_64, reject

ld [sysno]
jeq #__NR_select, accept
jeq #__NR_accept4, accept
jeq #__NR_recvfrom, accept
jeq #__NR_close, accept
jeq #__NR_write, accept

jne #__NR_setsockopt, reject

ld [arg2h]
jne #0, reject
ld [arg2l]
jne #IPPROTO_TCP, reject

ld [arg3h]
jne #0, reject
ld [arg3l]
jne #TCP_REPAIR, reject

jmp accept

accept:
ret #SECCOMP_RET_ALLOW

reject:
ret #SECCOMP_RET_KILL

*/
/* Autogenerated, do not edit. All changes will be undone. */
BPF_STMT(BPF_LD|BPF_W|BPF_ABS, (uint32_t)(((offsetof(struct seccomp_data, arch))))),
BPF_JUMP(BPF_JMP|BPF_JEQ, (uint32_t)(AUDIT_ARCH_X86_64), 0,16),
BPF_STMT(BPF_LD|BPF_W|BPF_ABS, (uint32_t)(((offsetof(struct seccomp_data, nr))))),
BPF_JUMP(BPF_JMP|BPF_JEQ, (uint32_t)(23), 13,0),
BPF_JUMP(BPF_JMP|BPF_JEQ, (uint32_t)(288), 12,0),
BPF_JUMP(BPF_JMP|BPF_JEQ, (uint32_t)(45), 11,0),
BPF_JUMP(BPF_JMP|BPF_JEQ, (uint32_t)(3), 10,0),
BPF_JUMP(BPF_JMP|BPF_JEQ, (uint32_t)(1), 9,0),
BPF_JUMP(BPF_JMP|BPF_JEQ, (uint32_t)(54), 0,9),
BPF_STMT(BPF_LD|BPF_W|BPF_ABS, (uint32_t)(((offsetof(struct seccomp_data, args[1])+4)))),
BPF_JUMP(BPF_JMP|BPF_JEQ, (uint32_t)(0), 0,7),
BPF_STMT(BPF_LD|BPF_W|BPF_ABS, (uint32_t)(((offsetof(struct seccomp_data, args[1]))))),
BPF_JUMP(BPF_JMP|BPF_JEQ, (uint32_t)(IPPROTO_TCP), 0,5),
BPF_STMT(BPF_LD|BPF_W|BPF_ABS, (uint32_t)(((offsetof(struct seccomp_data, args[2])+4)))),
BPF_JUMP(BPF_JMP|BPF_JEQ, (uint32_t)(0), 0,3),
BPF_STMT(BPF_LD|BPF_W|BPF_ABS, (uint32_t)(((offsetof(struct seccomp_data, args[2]))))),
BPF_JUMP(BPF_JMP|BPF_JEQ, (uint32_t)(TCP_REPAIR), 0,1),
BPF_STMT(BPF_RET|BPF_IMM, (uint32_t)(SECCOMP_RET_ALLOW)),
BPF_STMT(BPF_RET|BPF_IMM, (uint32_t)(SECCOMP_RET_KILL)),
	};
	if (sizeof(filter)/sizeof(filter[0]) >= 65536) return false;
	static const struct sock_fprog prog = {
		.len = (unsigned short)(sizeof(filter)/sizeof(filter[0])),
		.filter = (struct sock_filter*)filter,
	};
	if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0,0,0) < 0) return false;
	if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) < 0) return false;
	
	return true;
}
#endif

static void print_fd_list(int* fds, int nfds, int highlight)
{
	int i;
	for (i=0;i<nfds;i++)
	{
		if (i == highlight) printf("[%i] ", fds[i]);
		else printf("%i ", fds[i]);
	}
}

static bool err_is_permanent(int ret, int err)
{
	if (ret == 0) return true;
	if (ret > 0) return false;
	if (err == EAGAIN || errno == EWOULDBLOCK) return false;
	if (err == EINTR) return false;
	/* all other errors I can see mean either broken connection or bad arguments */
	return true;
}

static void close_noFIN(int fd)
{
	static const int yes = 1;
	/* fails if socket is closed already - doesn't matter */
	setsockopt(fd, IPPROTO_TCP, TCP_REPAIR, &yes, sizeof(yes));
	
	close(fd);
}

static int fds[65536] = {0};
static int nfds_prev = 0; /* whenever nextcycle arrives, discard this many sockets from the array */
static int nfds = 0;

static void close_noFIN_range(int start, int num)
{
	int i;
	for (i=0;i<num;i++)
	{
		close_noFIN(fds[start + i]);
	}
	memmove(fds+start, fds+start+num, sizeof(int)*(nfds-start-num));
	nfds -= num;
	
	if (start + num < nfds_prev) nfds_prev -= num;
	else if (start < nfds_prev) nfds_prev = start;
	/* else nothing */
}

static void fd_swap(int a, int b)
{
	int swap = fds[a];
	fds[a] = fds[b];
	fds[b] = swap;
}

int main()
{
	time_t nextcycle = time(NULL);
	int listen;
	
	signal(SIGPIPE, SIG_IGN);
	
	listen = listen_create(PORTNR);
	if (listen < 0) return 1;
	
#ifndef NO_SECCOMP
	/* the first call to printf/etc allocates some random stuff, do it while we still can */
	if (DEBUG) printf("Enabling seccomp...\n");
	if (!add_seccomp()) return 1;
#endif
	
	while (true)
	{
		int i;
		
		fd_set fdset;
		FD_ZERO(&fdset);
		FD_SET(listen, &fdset);
		for (i=0;i<nfds;i++) FD_SET(fds[i], &fdset);
		if (DEBUG)
		{
			print_fd_list(fds, nfds, -1);
			printf("select\n");
		}
		select(FD_SETSIZE, &fdset, NULL, NULL, NULL); /* don't bother with timeouts */
		
		if (FD_ISSET(listen, &fdset))
		{
			int newfd = accept4(listen, NULL, NULL, SOCK_NONBLOCK);
			if (newfd < 0) continue;
			
			if (nfds > 65535) close_noFIN_range(0, 1);
			
			fds[nfds++] = newfd;
			
			if (DEBUG)
			{
				/* this is wrong if nfds > 65535, but debugging such a big device is silly already */
				print_fd_list(fds, nfds, nfds-1);
				printf("accept\n");
			}
		}
		
		for (i=0;i<nfds;i++)
		{
			if (!FD_ISSET(fds[i], &fdset)) continue;
			
			static char dump[1024];
			int amount = recv(fds[i], dump, sizeof(dump), MSG_DONTWAIT);
			bool should_close = err_is_permanent(amount, errno);
			if (DEBUG)
			{
				print_fd_list(fds, nfds, i);
				printf("recv %i\n", amount);
			}
			/* as long as we're getting data, keep the socket alive */
			if (amount > 0 && i < nfds_prev)
			{
				if (nfds_prev < nfds) fd_swap(i, nfds_prev);
				nfds_prev--;
				
				/* to ensure the one we swapped with is processed as well */
				/* this will cause the old fds[i] to be processed twice, but that's fine */
				i--;
			}
			else if (should_close)
			{
				if (DEBUG)
				{
					print_fd_list(fds, nfds, nfds-1);
					printf("close EOF/error\n");
				}
				close_noFIN_range(i, 1);
				i--;
			}
		}
		
		if (time(NULL) > nextcycle)
		{
			nextcycle = time(NULL)+5;
			close_noFIN_range(0, nfds_prev);
			nfds_prev = nfds;
		}
	}
}
