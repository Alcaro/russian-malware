#include "russian.h"
#include <gtk/gtk.h>

#if !GTK_CHECK_VERSION(3,16,0)
//this is somewhat glitchy (textview works fine, but channel list gets scrollbar), but there's no better option for old gtks
#define GTK_POLICY_EXTERNAL GTK_POLICY_AUTOMATIC
#endif

//Gtk is a complete piece of shit with slowly expanding textviews like this.
//To start with, gtk_text_view_scroll_to_mark applies some ugly animation, so I have to recalculate the thing to wipe it.
//And, far worse, GtkScrolledWindow uses some funky kinetic algorithm when scrolling.
//  Normally, that would be fine, but it keeps overriding my settings:
//  - Scroll fast towards the bottom, which stops at ... let's say y=500
//  - Gtk now tries to scroll from 500 to 510, then 509, then 508, 507, 506, each time failing because window isn't that big
//  - Programmatically resize the contents to 20px more
//  - gtk_adjustment_set_value(520)
//  - SOMEHOW it now starts scrolling UPWARDS a tiny bit!
//  - Program, which is sensitive to scroll position, is sad
//To work around this amount of bullshit, I catch the GtkScrollableWindow::edge-reached signal and set a 'you're at the bottom' flag.
//The position is now locked to the bottom. No matter how Gtk decides to scroll, I'll override it.
//The only things that can unlock the position are (1) lastRead going offscreen (2) any user input (GtkWidget::event signal).
//Naturally, finding that this works and every more obvious method doesn't took about four hours.

//Qt is looking like an increasingly attractive option, despite not looking 100% like GTK (GTK2 doesn't look like GTK3 anyways),
//  and its mandatory minus 1000 points for not UTF-8.

static void scrolled_cb(GtkAdjustment* adjustment, gpointer user_data)
{
	((textview*)user_data)->_priv_scrolled();
}

bool textview::any_event(GtkWidget* widget, GdkEvent* event)
{
	int scrolldir = 0;
	if (event->type == GDK_SCROLL)
	{
		if (event->scroll.direction == GDK_SCROLL_UP) scrolldir = -1;
		if (event->scroll.direction == GDK_SCROLL_DOWN) scrolldir = 1;
		if (event->scroll.direction == GDK_SCROLL_SMOOTH) scrolldir = (event->scroll.delta_y > 0) - (event->scroll.delta_y < 0);
	}
	
	//wasted another hour trying to find a way to do this without counting mouse buttons
	if (event->type == GDK_BUTTON_PRESS)
		n_mouse_grabs++;
	if (event->type == GDK_BUTTON_RELEASE)
		n_mouse_grabs--;
	if (event->type == GDK_MOTION_NOTIFY && n_mouse_grabs>0)
		this->atbottom_allow_release = true;
	
	user_input(event->type);
	if (scrolldir < 0) this->atbottom_allow_release = true;
	if (scrolldir > 0) this->atbottom_allow_release = false;
	
	return false;
}

static double scrollbar_max(GtkAdjustment* scroll)
{
	return gtk_adjustment_get_upper(scroll) - gtk_adjustment_get_page_size(scroll);
}

static bool scrollbar_at_bottom(GtkAdjustment* scroll)
{
	double y = gtk_adjustment_get_value(scroll);
	double ymax = scrollbar_max(scroll);
	
	return (y >= ymax-1); // -1 to allow rounding errors
}

void textview::_priv_scrolled()
{
	GtkAdjustment* scroll = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(view));
	bool new_at_bottom = scrollbar_at_bottom(scroll);
	if (at_bottom && !new_at_bottom)
	{
		if (atbottom_allow_release) at_bottom = false;
		else cur_buf->scroll_to_last_read_cb();
	}
	if (new_at_bottom)
	{
		at_bottom = true;
		atbottom_allow_release = false;
	}
}

textview::textview()
{
	cur_buf = NULL;
	
	tags = gtk_text_tag_table_new();
	view = GTK_TEXT_VIEW(gtk_text_view_new());
	
	gtk_text_view_set_wrap_mode(view, GTK_WRAP_WORD_CHAR);
	
	//known bugs if not readonly:
	//- backspacing images removes the alt-text, one character at the time
	//- left arrow has no effect if beside an image, you end up back where you started
	//no known bugs in mouse selection, or if otherwise readonly
	gtk_text_view_set_editable(view, false);
	gtk_text_view_set_cursor_visible(view, false);
	
	t_imgalt = gtk_text_tag_new(NULL);
	g_object_set(t_imgalt, "scale", (gdouble)0, NULL);
	gtk_text_tag_table_add(tags, t_imgalt);
	
	t_message = gtk_text_tag_new(NULL);
	gtk_text_tag_table_add(tags, t_message);
	//three guesses whether negative indent is documented anywhere other than pango_layout_set_indent()
	//eight guesses how I got the idea of looking there
	g_object_set(t_message, "indent", (gint)-45, NULL);
	
	t_oldmessage = gtk_text_tag_new(NULL);
	g_object_set(t_oldmessage, "scale", (gdouble)0.75, NULL);
	gtk_text_tag_table_add(tags, t_oldmessage);
	
	scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	//I'd rather have NEVER than EXTERNAL, but that makes textview refuse to
	// shrink if that would change word wrapping
	gtk_scrolled_window_set_policy(scrollview, GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(view));
	
	g_signal_connect(scrollview, "event", G_CALLBACK(any_event_s), this);
	g_signal_connect(gtk_scrolled_window_get_vscrollbar(scrollview), "event", G_CALLBACK(any_event_s), this);
	GtkAdjustment* scrollbar = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(view));
	g_signal_connect(scrollbar, "value-changed", G_CALLBACK(scrolled_cb), this);
	g_signal_connect(scrollbar, "changed", G_CALLBACK(scrolled_cb), this);
}

textview::image::image(arrayview<byte> bytes, size_t width, size_t height)
{
	GInputStream* is = g_memory_input_stream_new_from_data(bytes.ptr(), bytes.size(), NULL);
	pix = gdk_pixbuf_new_from_stream_at_scale(is, width, height, true, NULL, NULL);
	g_object_unref(is);
}
textview::image::~image()
{
	g_object_unref(pix);
}

const uint32_t textview::span::colors[16] = {
	//rrggbb
	0xcccccc, 0x000000, 0x3535b3, 0x2a8c2a,
	0xd02a2a, 0x6f2828, 0x80267f, 0xdc721d,
	0xd9a641, 0x3dcc3d, 0x195555, 0x27d6c0,
	0x4545e6, 0xda31da, 0x6c6c6c, 0xafafaf,
};

//a selection bound may not lie between a GdkPixbuf and the alt-text tag, or inside the tag
// if it does, it must be put on the far side of the image
//since the alt-text tag always lies to the right of the image, this simplifies to
// 'if a selection bound points inside, or to the start of, an alt-ext tag, move it to the end of said tag'
//which further simplifies to 'if the pointed-to character is inside the tag, move to after the tag end'
static GtkTextIter imgalt_get_iter(GtkTextBuffer* buf,
                                   GtkTextMark* mark,
                                   GtkTextTag* t_imgalt,
                                   bool* do_move)
{
	GtkTextIter ret;
	gtk_text_buffer_get_iter_at_mark(buf, &ret, mark);
	if (gtk_text_iter_has_tag(&ret, t_imgalt))
	{
		*do_move = true;
		gtk_text_iter_forward_to_tag_toggle(&ret, t_imgalt);
	}
	return ret;
}

static void imgalt_update(GtkTextBuffer* buf, GtkTextTag* t_imgalt)
{
	bool do_move = false;
	GtkTextIter insert = imgalt_get_iter(buf, gtk_text_buffer_get_insert(         buf), t_imgalt, &do_move);
	GtkTextIter sbound = imgalt_get_iter(buf, gtk_text_buffer_get_selection_bound(buf), t_imgalt, &do_move);
	
	if (do_move)
	{
		gtk_text_buffer_select_range(buf, &insert, &sbound);
	}
}

static void imgalt_cb(GObject* gobject, GParamSpec* pspec, gpointer user_data)
{
	imgalt_update(GTK_TEXT_BUFFER(gobject), GTK_TEXT_TAG(user_data));
}

textview::buffer::buffer(textview* parent)
{
	this->parent = parent;
	this->buf = gtk_text_buffer_new(parent->tags);
	
	GtkTextIter iter;
	gtk_text_buffer_get_end_iter(buf, &iter);
	for (int i=0;i<100;i++)
	{
		gtk_text_buffer_insert(buf, &iter, "\n", -1);
	}
	
	//this doesn't do anything if selection-bound moves without cursor moving, but as far as I've seen,
	// user can't move it to any place other than 'right where main cursor is' which is always a valid position
	//(okay, code can move it, but it won't.)
	
	//the cursor itself is invisible, but selecting text isn't
	g_signal_connect(this->buf, "notify::cursor-position", G_CALLBACK(imgalt_cb), parent->t_imgalt);
	
	GtkTextMark* mark = gtk_text_mark_new("lastRead", true);
	gtk_text_buffer_add_mark(buf, mark, &iter);
//gtk_text_mark_set_visible(mark, true); // TODO: remove
}

bool textview::buffer::scroll_to_last_read_cb()
{
	//can happen if switching channels really fast
	if (parent->cur_buf != this) return false;
	
	GtkTextMark* mark = gtk_text_buffer_get_mark(buf, "lastRead");
	//the obvious method fails because Gtk insists on some stupid animation and I can't throw it out
	//there are plenty of usable functions, but they're all undocumented and private for some absurd reason
	//gtk_text_view_scroll_to_mark(parent->view, mark, 0.0, true, 0.0, 0.0);
	
	GtkTextIter iter;
	gtk_text_buffer_get_iter_at_mark(buf, &iter, mark);
	
	GdkRectangle rect;
	gtk_text_view_get_iter_location(parent->view, &iter, &rect);
	
	GtkAdjustment* scroll = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(parent->view));
	gtk_adjustment_set_value(scroll, rect.y);
	
	if (rect.y < scrollbar_max(scroll)) parent->at_bottom = false;
	
	return false;
}

void textview::buffer::scroll_to_last_read()
{
	if (parent->cur_buf == this)
	{
		//apparently Gtk sends its own scroll events sometimes, which run after mine
		//I'm not interested, just ditch that
		runloop::global()->set_idle(bind_this(&buffer::scroll_to_last_read_cb));
	}
}

void textview::buffer::move_last_read()
{
	if (gtk_text_view_get_buffer(parent->view) == this->buf)
	{
		GtkAdjustment* scroll = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(parent->view));
		GtkTextIter iter;
		if (scrollbar_at_bottom(scroll))
		{
			gtk_text_buffer_get_end_iter(this->buf, &iter);
		}
		else
		{
			gtk_text_view_get_line_at_y(parent->view, &iter, gtk_adjustment_get_value(scroll), NULL);
		}
		gtk_text_buffer_move_mark_by_name(this->buf, "lastRead", &iter);
	}
}

void textview::buffer::message_insert_at(GtkTextIter* iter, arrayview<span> spans)
{
	for (size_t i=0;i<spans.size();i++)
	{
		const span& sp = spans[i];
		if (sp.img)
		{
			gtk_text_buffer_insert_pixbuf(buf, iter, sp.img->pix);
		}
		
		size_t start_offset = gtk_text_iter_get_offset(iter);
		string newtext = sp.text;
		newtext = newtext.replace("\n", "\n               ");
		gtk_text_buffer_insert(buf, iter, newtext, newtext.length());
		
		GtkTextIter start;
		gtk_text_buffer_get_iter_at_offset(buf, &start, start_offset);
		if (sp.img) gtk_text_buffer_apply_tag(buf, parent->t_imgalt, &start, iter);
		
		gtk_text_buffer_apply_tag(buf, parent->t_message, &start, iter);
		
		//TODO: check other formats and apply them
	}
}

void textview::buffer::message(cstring id, arrayview<span> spans)
{
	GtkTextIter iter;
	
	GtkTextMark* mark = NULL;
	if (id)
	{
		//gtk has builtin marks 'insert' and 'selection_bound', namespace ourselves so gtk goes away
		string idReal = "$"+id;
		mark = gtk_text_mark_new(idReal, true);
	}
	
	gtk_text_buffer_get_end_iter(buf, &iter);
	gtk_text_buffer_insert(buf, &iter, "\n", -1);
	
	if (mark) gtk_text_buffer_add_mark(buf, mark, &iter);
	
	message_insert_at(&iter, spans);
	
	if (parent->at_bottom)
	{
		scroll_to_last_read();
	}
}

void textview::buffer::message_edit_visible(cstring id, arrayview<span> spans)
{
	GtkTextIter iter;
	
	//gtk has builtin marks 'insert' and 'selection_bound', namespace ourselves so gtk goes away
	string idReal = "$"+id;
	
	GtkTextMark* mark = gtk_text_buffer_get_mark(buf, idReal);
	gtk_text_buffer_get_iter_at_mark(buf, &iter, mark);
	GtkTextIter iterend = iter;
	//don't replace with 'go one line forward', messages can be multiline
	gtk_text_iter_forward_to_tag_toggle(&iterend, parent->t_message);
	//iter to iterend is one message, excluding \n
	gtk_text_buffer_insert(buf, &iterend, "\n", -1);
	gtk_text_buffer_get_iter_at_mark(buf, &iter, mark); // addding that \n invalidates the iterator
	gtk_text_buffer_apply_tag(buf, parent->t_oldmessage, &iter, &iterend);
	//treat new and old messages as a single message, with a \n in the middle
	gtk_text_buffer_apply_tag(buf, parent->t_message, &iter, &iterend);
	
	message_insert_at(&iterend, spans);
	
	if (parent->at_bottom)
	{
		scroll_to_last_read();
	}
}

void textview::buffer::message_delete(cstring id)
{
	GtkTextIter iter;
	
	string idReal = "$"+id;
	
	GtkTextMark* mark = gtk_text_buffer_get_mark(buf, idReal);
	if (mark)
	{
		gtk_text_buffer_get_iter_at_mark(buf, &iter, mark);
		GtkTextIter iterend = iter;
		
		//don't replace with 'go one line forward', messages can be multiline
		gtk_text_iter_forward_to_tag_toggle(&iterend, parent->t_message);
		//iter to iterend is one message, excluding \n
		
		//the \n after a line isn't guaranteed to exist, but the one before is, and all \n are equal
		//so nuke the previous one instead
		gtk_text_iter_backward_char(&iter);
		gtk_text_buffer_delete(buf, &iter, &iterend);
		gtk_text_buffer_delete_mark(buf, mark);
		return;
	}
	
	if (parent->at_bottom)
	{
		scroll_to_last_read();
	}
}

textview::buffer::~buffer()
{
	g_object_unref(buf);
}

void textview::user_input(int gdk_event_type)
{
	if (gdk_event_type == GDK_MOTION_NOTIFY ||
	    gdk_event_type == GDK_BUTTON_PRESS ||
	    gdk_event_type == GDK_KEY_PRESS ||
	    gdk_event_type == GDK_FOCUS_CHANGE ||
	    gdk_event_type == GDK_SCROLL ||
	    gdk_event_type == GDK_TOUCH_UPDATE)
	{
		cur_buf->move_last_read();
	}
}

void textview::do_scroll(GdkEventKey* event)
{
	//couldn't get this working, it said stack smashing
	//_priv_user_input(GDK_KEY_PRESS, scrolldir);
	//bool x;
	//g_signal_emit_by_name(this->scrollview, "scroll-child", (scrolldir<0 ? GTK_SCROLL_PAGE_UP : GTK_SCROLL_PAGE_DOWN), false, &x);
	
	this->atbottom_allow_release = true;
	gtk_bindings_activate_event(G_OBJECT(this->scrollview), event);
	cur_buf->move_last_read();
}

void textview::set_buf(buffer* buf)
{
	if (cur_buf == buf) return;
	if (cur_buf)
	{
		cur_buf->move_last_read();
	}
	gtk_text_view_set_buffer(view, buf->buf);
	cur_buf = buf;
	buf->scroll_to_last_read();
}

textview::~textview()
{
	g_object_unref(tags);
	g_object_unref(t_imgalt);
	gtk_widget_destroy(GTK_WIDGET(view));
}
