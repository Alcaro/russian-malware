#ifndef ARGUI_NONE
#include "russian.h"
#include <gtk/gtk.h>

#if !GTK_CHECK_VERSION(3,16,0)
//this is somewhat glitchy (textview works fine, but channel list gets scrollbar), but there's no better option for old gtks
#define GTK_POLICY_EXTERNAL GTK_POLICY_AUTOMATIC
#endif

//Gtk is a complete piece of shit with slowly expanding textviews like this.
//To start with, gtk_text_view_scroll_to_mark applies some ugly animation, so I have to recalculate the thing to wipe it.
//And, far worse, GtkScrolledWindow uses some funky kinetic algorithm when scrolling.
//  Normally, that would be fine, but it keeps overriding my settings:
//  - Scroll fast towards the bottom, which stops at ... let's say y=500
//  - Gtk now tries to scroll from 500 to 510, then 509, then 508, 507, 506, each time failing because window isn't that big
//  - Programmatically resize the contents to 20px more
//  - gtk_adjustment_set_value(520)
//  - SOMEHOW it now starts scrolling UPWARDS a tiny bit!
//  - Program, which is sensitive to scroll position, is sad
//To work around this amount of bullshit, I catch the GtkScrollableWindow::edge-reached signal and set a 'you're at the bottom' flag.
//The position is now locked to the bottom. No matter how Gtk decides to scroll, I'll override it.
//The only things that can unlock the position are (1) lastRead going offscreen (2) any user input (GtkWidget::event signal).
//Naturally, finding that this works and every more obvious method doesn't took about four hours.

//Qt is looking like an increasingly attractive option, despite not looking 100% like GTK (GTK2 doesn't look like GTK3 anyways),
//  and its mandatory minus 1000 points for not UTF-8.

static void scrollval_cb(GtkAdjustment* adjustment, gpointer user_data)
{
	((textview*)user_data)->_priv_scrolled(true);
}

static void scrolled_cb(GtkAdjustment* adjustment, gpointer user_data)
{
	((textview*)user_data)->_priv_scrolled(false);
}

bool textview::any_event(GtkWidget* widget, GdkEvent* event)
{
	user_input(event->type);
	
	return false;
}

static double scrollbar_max(GtkAdjustment* scroll)
{
	return gtk_adjustment_get_upper(scroll) - gtk_adjustment_get_page_size(scroll);
}

static bool scrollbar_at_bottom(GtkAdjustment* scroll)
{
	double y = gtk_adjustment_get_value(scroll);
	double ymax = scrollbar_max(scroll);
	
	return (y >= ymax-1); // -1 to allow rounding errors
}

void textview::_priv_scrolled(bool allow_leave)
{
	GtkAdjustment* scroll = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(view));
	
	bool new_at_bottom = scrollbar_at_bottom(scroll);
	if ((!new_at_bottom && time_ms_ne() < atbottom_until_ms) || (at_bottom && !new_at_bottom && !allow_leave))
	{
		cur_buf->scroll_to_last_read_cb();
		atbottom_until_ms = time_ms_ne() + 100;
		at_bottom = true;
	}
	else at_bottom = new_at_bottom;
}

textview::textview()
{
	cur_buf = NULL;
	
	tags = gtk_text_tag_table_new();
	view = GTK_TEXT_VIEW(gtk_text_view_new());
	gtk_text_view_set_wrap_mode(view, GTK_WRAP_WORD_CHAR);
	
	//known bugs if not readonly:
	//- backspacing images removes the alt-text, one character at the time
	//- left arrow has no effect if beside an image, you end up back where you started
	//no known bugs in mouse selection, or if otherwise readonly
	gtk_text_view_set_editable(view, false);
	gtk_text_view_set_cursor_visible(view, false);
	
#define TAG(var, tag, val) \
	do { \
		var = gtk_text_tag_new(NULL); \
		g_object_set(var, tag, val, NULL); \
		gtk_text_tag_table_add(tags, var); \
	} while(0)
	
	TAG(t_imgalt, "scale", (gdouble)0.0);
	//three guesses whether negative indent is documented anywhere other than pango_layout_set_indent()
	//eight guesses how I got the idea of looking there
	TAG(t_message, "indent", (gint)-45);
	TAG(t_oldmessage, "scale", (gdouble)0.75);
	
	TAG(t_bold, "weight", PANGO_WEIGHT_BOLD);
	TAG(t_underline, "underline", PANGO_UNDERLINE_SINGLE);
	TAG(t_italics, "style", PANGO_STYLE_ITALIC);
	TAG(t_strike, "strikethrough", true);
#undef TAG
	
	scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	//I'd rather have NEVER than EXTERNAL, but that makes textview refuse to
	// shrink if that would change word wrapping
	gtk_scrolled_window_set_policy(scrollview, GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(view));
	
	g_signal_connect(scrollview, "event", G_CALLBACK(any_event_s), this);
	g_signal_connect(gtk_scrolled_window_get_vscrollbar(scrollview), "event", G_CALLBACK(any_event_s), this);
	GtkAdjustment* scrollbar = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(view));
	g_signal_connect(scrollbar, "value-changed", G_CALLBACK(scrollval_cb), this);
	g_signal_connect(scrollbar, "changed", G_CALLBACK(scrolled_cb), this);
}

GtkTextTag* textview::t_fgcol(uint32_t xrgb)
{
	if (!t_fgcol_map.contains(xrgb))
	{
		uint8_t r = xrgb>>16;
		uint8_t g = xrgb>>8;
		uint8_t b = xrgb>>0;
		
		GdkRGBA col;
		col.red = r/255.0;
		col.green = g/255.0;
		col.blue = b/255.0;
		col.alpha = 1.0;
		
		GtkTextTag* tag = gtk_text_tag_new(NULL);
		g_object_set(tag, "foreground-rgba", &col, NULL);
		gtk_text_tag_table_add(tags, tag);
		
		t_fgcol_map.insert(xrgb, tag);
	}
	return t_fgcol_map.get(xrgb);
}

GtkTextTag* textview::t_bgcol(uint32_t xrgb)
{
	if (!t_bgcol_map.contains(xrgb))
	{
		uint8_t r = xrgb>>16;
		uint8_t g = xrgb>>8;
		uint8_t b = xrgb>>0;
		
		GdkRGBA col;
		col.red = r/255.0;
		col.green = g/255.0;
		col.blue = b/255.0;
		col.alpha = 1.0;
		
		GtkTextTag* tag = gtk_text_tag_new(NULL);
		g_object_set(tag, "background-rgba", &col, NULL);
		gtk_text_tag_table_add(tags, tag);
		
		t_bgcol_map.insert(xrgb, tag);
	}
	return t_bgcol_map.get(xrgb);
}

textview::image::image(arrayview<byte> bytes, size_t width, size_t height)
{
	GInputStream* is = g_memory_input_stream_new_from_data(bytes.ptr(), bytes.size(), NULL);
	pix = gdk_pixbuf_new_from_stream_at_scale(is, width, height, true, NULL, NULL);
	g_object_unref(is);
}
textview::image::~image()
{
	g_object_unref(pix);
}

//a selection bound may not lie between a GdkPixbuf and the alt-text tag, or inside the tag
// if it does, it must be put on the far side of the image
//since the alt-text tag always lies to the right of the image, this simplifies to
// 'if a selection bound points inside, or to the start of, an alt-ext tag, move it to the end of said tag'
//which further simplifies to 'if the pointed-to character is inside the tag, move to after the tag end'
static GtkTextIter imgalt_get_iter(GtkTextBuffer* buf,
                                   GtkTextMark* mark,
                                   GtkTextTag* t_imgalt,
                                   bool* do_move)
{
	GtkTextIter ret;
	gtk_text_buffer_get_iter_at_mark(buf, &ret, mark);
	if (gtk_text_iter_has_tag(&ret, t_imgalt))
	{
		*do_move = true;
		gtk_text_iter_forward_to_tag_toggle(&ret, t_imgalt);
	}
	return ret;
}

static void imgalt_update(GtkTextBuffer* buf, GtkTextTag* t_imgalt)
{
	bool do_move = false;
	GtkTextIter insert = imgalt_get_iter(buf, gtk_text_buffer_get_insert(         buf), t_imgalt, &do_move);
	GtkTextIter sbound = imgalt_get_iter(buf, gtk_text_buffer_get_selection_bound(buf), t_imgalt, &do_move);
	
	if (do_move)
	{
		gtk_text_buffer_select_range(buf, &insert, &sbound);
	}
}

static void imgalt_cb(GObject* gobject, GParamSpec* pspec, gpointer user_data)
{
	imgalt_update(GTK_TEXT_BUFFER(gobject), GTK_TEXT_TAG(user_data));
}

textview::buffer::buffer(textview* parent, cstring scrollback)
{
	this->parent = parent;
	this->buf = gtk_text_buffer_new(parent->tags);
	
	GtkTextIter iter;
	gtk_text_buffer_get_end_iter(buf, &iter);
	for (int i=0;i<100;i++)
	{
		gtk_text_buffer_insert(buf, &iter, "\n", -1);
	}
	gtk_text_buffer_insert(buf, &iter, scrollback.c_str(), scrollback.length()-1); // -1 to drop the final \n
	
	//this doesn't do anything if selection-bound moves without cursor moving, but as far as I've seen,
	// user can't move it to any place other than 'right where main cursor is' which is always a valid position
	//(okay, code can move it, but it won't.)
	
	//the cursor itself is invisible, but selecting text isn't
	g_signal_connect(this->buf, "notify::cursor-position", G_CALLBACK(imgalt_cb), parent->t_imgalt);
	
	GtkTextMark* mark = gtk_text_mark_new("lastRead", true);
	gtk_text_buffer_add_mark(buf, mark, &iter);
//gtk_text_mark_set_visible(mark, true); // TODO: remove
}

bool textview::buffer::scroll_to_last_read_cb()
{
	//can happen if switching channels really fast
	if (parent->cur_buf != this) return false;
	
	GtkTextMark* mark = gtk_text_buffer_get_mark(buf, "lastRead");
	//the obvious method fails because Gtk insists on some stupid animation and I can't throw it out
	//there are plenty of usable functions, but they're all undocumented and private for some absurd reason
	//gtk_text_view_scroll_to_mark(parent->view, mark, 0.0, true, 0.0, 0.0);
	
	GtkTextIter iter;
	gtk_text_buffer_get_iter_at_mark(buf, &iter, mark);
	
	GdkRectangle rect;
	gtk_text_view_get_iter_location(parent->view, &iter, &rect);
	
	GtkAdjustment* scroll = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(parent->view));
	gtk_adjustment_set_value(scroll, rect.y);
	
	if (rect.y < scrollbar_max(scroll)) { parent->atbottom_until_ms = 0; parent->at_bottom = false; }
	
	return false;
}

void textview::buffer::scroll_to_last_read()
{
	if (parent->cur_buf == this)
	{
		//apparently Gtk sends its own scroll events sometimes, which run after mine
		//override that, mine must be last
		runloop::global()->set_idle(bind_this(&buffer::scroll_to_last_read_cb));
	}
}

void textview::buffer::move_last_read()
{
	if (gtk_text_view_get_buffer(parent->view) == this->buf)
	{
		GtkAdjustment* scroll = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(parent->view));
		GtkTextIter iter;
		if (scrollbar_at_bottom(scroll))
		{
			gtk_text_buffer_get_end_iter(this->buf, &iter);
		}
		else
		{
			gtk_text_view_get_line_at_y(parent->view, &iter, gtk_adjustment_get_value(scroll), NULL);
		}
		gtk_text_buffer_move_mark_by_name(this->buf, "lastRead", &iter);
	}
}

void textview::buffer::message_insert_at(GtkTextIter* iter, arrayview<span> spans)
{
	for (size_t i=0;i<spans.size();i++)
	{
		const span& sp = spans[i];
		if (sp.img)
		{
			gtk_text_buffer_insert_pixbuf(buf, iter, sp.img->pix);
		}
		
		size_t start_offset = gtk_text_iter_get_offset(iter);
		string newtext = sp.text;
		newtext = newtext.replace("\n", "\n               "); // TODO: fiddle with margins instead
		gtk_text_buffer_insert(buf, iter, newtext, newtext.length());
		
		GtkTextIter start;
		gtk_text_buffer_get_iter_at_offset(buf, &start, start_offset);
		if (sp.img)
		{
			gtk_text_buffer_apply_tag(buf, parent->t_imgalt, &start, iter);
			gtk_text_buffer_get_iter_at_offset(buf, &start, start_offset-1); // t_message and t_bgcol should be applied to the image too
		}
		gtk_text_buffer_apply_tag(buf, parent->t_message, &start, iter);
		
		if (sp.bold) gtk_text_buffer_apply_tag(buf, parent->t_bold, &start, iter);
		if (sp.underline) gtk_text_buffer_apply_tag(buf, parent->t_underline, &start, iter);
		if (sp.italics) gtk_text_buffer_apply_tag(buf, parent->t_italics, &start, iter);
		if (sp.strike) gtk_text_buffer_apply_tag(buf, parent->t_strike, &start, iter);
		
		if (sp.fgcol != (uint32_t)-1)
			gtk_text_buffer_apply_tag(buf, parent->t_fgcol(sp.fgcol), &start, iter);
		if (sp.bgcol != (uint32_t)-1)
			gtk_text_buffer_apply_tag(buf, parent->t_bgcol(sp.bgcol), &start, iter);
	}
}

void textview::buffer::message(cstring id, arrayview<span> spans)
{
	bool atbottom = (scrollbar_at_bottom(gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(parent->view))));
	
	GtkTextIter iter;
	
	GtkTextMark* mark = NULL;
	if (id)
	{
		//gtk has builtin marks 'insert' and 'selection_bound', namespace ourselves so gtk goes away
		string idReal = "$"+id;
		mark = gtk_text_mark_new(idReal, true);
	}
	
	gtk_text_buffer_get_end_iter(buf, &iter);
	gtk_text_buffer_insert(buf, &iter, "\n", -1);
	
	if (mark) gtk_text_buffer_add_mark(buf, mark, &iter);
	
	message_insert_at(&iter, spans);
	
	if (atbottom)
	{
		scroll_to_last_read();
		parent->atbottom_until_ms = time_ms_ne() + 100;
		parent->at_bottom = true;
	}
}

void textview::buffer::message_edit_visible(cstring id, arrayview<span> spans)
{
	bool atbottom = (scrollbar_at_bottom(gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(parent->view))));
	
	GtkTextIter iter;
	
	//gtk has builtin marks 'insert' and 'selection_bound', namespace ourselves so gtk goes away
	string idReal = "$"+id;
	
	GtkTextMark* mark = gtk_text_buffer_get_mark(buf, idReal);
	gtk_text_buffer_get_iter_at_mark(buf, &iter, mark);
	GtkTextIter iterend = iter;
	//don't replace with 'go one line forward', messages can be multiline
	gtk_text_iter_forward_to_tag_toggle(&iterend, parent->t_message);
	//iter to iterend is one message, excluding \n
	gtk_text_buffer_insert(buf, &iterend, "\n", -1);
	gtk_text_buffer_get_iter_at_mark(buf, &iter, mark); // addding that \n invalidates the iterator
	gtk_text_buffer_apply_tag(buf, parent->t_oldmessage, &iter, &iterend);
	//treat new and old messages as a single message, with a \n in the middle
	gtk_text_buffer_apply_tag(buf, parent->t_message, &iter, &iterend);
	
	message_insert_at(&iterend, spans);
	
	if (atbottom)
	{
		scroll_to_last_read();
		parent->atbottom_until_ms = time_ms_ne() + 100;
		parent->at_bottom = true;
	}
}

void textview::buffer::message_delete(cstring id)
{
	GtkTextIter iter;
	
	string idReal = "$"+id;
	
	GtkTextMark* mark = gtk_text_buffer_get_mark(buf, idReal);
	if (mark)
	{
		gtk_text_buffer_get_iter_at_mark(buf, &iter, mark);
		GtkTextIter iterend = iter;
		
		//don't replace with 'go one line forward', messages can be multiline
		gtk_text_iter_forward_to_tag_toggle(&iterend, parent->t_message);
		//iter to iterend is one message, excluding \n
		
		//the \n after a line isn't guaranteed to exist, but the one before is, and all \n are equal
		//so nuke the previous one instead
		gtk_text_iter_backward_char(&iter);
		gtk_text_buffer_delete(buf, &iter, &iterend);
		gtk_text_buffer_delete_mark(buf, mark);
	}
	
	parent->at_bottom = (scrollbar_at_bottom(gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(parent->view))));
}

textview::buffer::~buffer()
{
	g_object_unref(buf);
}

void textview::user_input(int gdk_event_type)
{
	if (gdk_event_type == GDK_MOTION_NOTIFY ||
	    gdk_event_type == GDK_BUTTON_PRESS ||
	    gdk_event_type == GDK_KEY_PRESS ||
	    gdk_event_type == GDK_FOCUS_CHANGE ||
	    gdk_event_type == GDK_SCROLL ||
	    gdk_event_type == GDK_TOUCH_UPDATE)
	{
		cur_buf->move_last_read();
	}
}

void textview::do_scroll(GdkEventKey* event)
{
	//couldn't get this working, it said stack smashing
	//_priv_user_input(GDK_KEY_PRESS, scrolldir);
	//bool x;
	//g_signal_emit_by_name(this->scrollview, "scroll-child", (scrolldir<0 ? GTK_SCROLL_PAGE_UP : GTK_SCROLL_PAGE_DOWN), false, &x);
	
	gtk_bindings_activate_event(G_OBJECT(this->scrollview), event);
	cur_buf->move_last_read();
}

void textview::set_buf(buffer* buf)
{
	if (cur_buf == buf) return;
	if (cur_buf)
	{
		cur_buf->move_last_read();
	}
	gtk_text_view_set_buffer(view, buf->buf);
	cur_buf = buf;
	buf->scroll_to_last_read();
}

textview::~textview()
{
	for (auto& pair : t_fgcol_map) { g_object_unref(pair.value); }
	for (auto& pair : t_bgcol_map) { g_object_unref(pair.value); }
	
	g_object_unref(t_imgalt);
	g_object_unref(t_message);
	g_object_unref(t_oldmessage);
	
	g_object_unref(t_bold);
	g_object_unref(t_underline);
	g_object_unref(t_italics);
	g_object_unref(t_strike);
	
	g_object_unref(tags);
	gtk_widget_destroy(GTK_WIDGET(view));
}
#endif
