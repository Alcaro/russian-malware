#include "textview.h"
#include <gtk/gtk.h>

#define INDENT_NEWLINE 20
#define INDENT_WRAP 40

// TODO: insert this at the start of every line once ctrl-c is overridden, so things like Ù´ don't make the line RTL
#define LTR_OVERRIDE "\xE2\x80\xAD"

//TODO: figure out if this does anything, the textbuffer sends 'changed' rather than 'notify'
#define g_object_freeze_notify(x) g_object_freeze_notify(G_OBJECT(x))
#define g_object_thaw_notify(x) g_object_thaw_notify(G_OBJECT(x))

namespace {
	class tags_t {
	public:
		GtkTextTagTable* table;
		
		// Everything, except the linebreaks between messages, has one of these two tags. Scrollback counts as one big message.
		// Each textview picks one of them, depending on the f_less_indent flag.
		GtkTextTag* t_message_large;
		GtkTextTag* t_message_small;
		
		GtkTextTag* t_oldmessage;
		GtkTextTag* t_img;
		GtkTextTag* t_imgalt;
		
		GtkTextTag* t_bold;
		GtkTextTag* t_underline;
		GtkTextTag* t_italics;
		GtkTextTag* t_strike;
		GtkTextTag* t_monospace;
		
		GtkTextTag* t_hyperlink;
		GtkTextTag* t_ilink_target;
		GtkTextTag* t_hidden;
		
		GdkCursor* c_hyperlink;
		
		map<uint32_t, GtkTextTag*> t_fgcol_map;
		map<uint32_t, GtkTextTag*> t_bgcol_map;
		
		unsigned line_height;
		
		//yes, 20x17 blank image; it's creepy, but anything else yields improper background color, bad selection behavior,
		// or wrong line height on blank lines
		GdkPaintable* img_indent;
		GdkPaintable* img_indent_small;
		
		
		GtkTextTag* t_fgcol(uint32_t xrgb)
		{
			if (!t_fgcol_map.contains(xrgb))
			{
				uint8_t r = xrgb>>16;
				uint8_t g = xrgb>>8;
				uint8_t b = xrgb>>0;
				
				GdkRGBA col;
				col.red = r/255.0;
				col.green = g/255.0;
				col.blue = b/255.0;
				col.alpha = 1.0;
				
				GtkTextTag* tag = gtk_text_tag_new(NULL);
				g_object_set(tag, "foreground-rgba", &col, NULL);
				gtk_text_tag_table_add(table, tag);
				
				t_fgcol_map.insert(xrgb, tag);
			}
			return t_fgcol_map.get(xrgb);
		}
		GtkTextTag* t_bgcol(uint32_t xrgb)
		{
			if (!t_bgcol_map.contains(xrgb))
			{
				uint8_t r = xrgb>>16;
				uint8_t g = xrgb>>8;
				uint8_t b = xrgb>>0;
				
				GdkRGBA col;
				col.red = r/255.0;
				col.green = g/255.0;
				col.blue = b/255.0;
				col.alpha = 1.0;
				
				GtkTextTag* tag = gtk_text_tag_new(NULL);
				g_object_set(tag, "background-rgba", &col, NULL);
				gtk_text_tag_table_add(table, tag);
				
				t_bgcol_map.insert(xrgb, tag);
			}
			return t_bgcol_map.get(xrgb);
		}
		
		tags_t()
		{
			table = gtk_text_tag_table_new();
			t_message_large = NULL;
		}
		void init(GtkWidget* widget) // not in constructor because needs a widget to grab text size
		{
#define TAG(var, ...) \
			do { \
				var = gtk_text_tag_new(NULL); \
				g_object_set(var, __VA_ARGS__, NULL); \
				gtk_text_tag_table_add(table, var); \
			} while(0)
#define TAG0(var) \
			do { \
				var = gtk_text_tag_new(NULL); \
				gtk_text_tag_table_add(table, var); \
			} while(0)
			
			GdkRGBA c_blue = { 0/255.0, 0/255.0, 255/255.0, 1.0 };
			TAG(t_hyperlink, "underline", PANGO_UNDERLINE_SINGLE, "foreground-rgba", &c_blue);
			
			// creepy rounding to make sure line height is line height... the obvious methods give off-by-one errors
			// or maybe this is wrong approach. don't know don't care
			// this returns 17 for line height 17 and being right for anything else is nonmandatory
			PangoFontMetrics* metrics = pango_context_get_metrics(gtk_widget_get_pango_context(widget), NULL, NULL);
			line_height = PANGO_PIXELS_CEIL(pango_font_metrics_get_ascent(metrics)) +
			              PANGO_PIXELS_CEIL(pango_font_metrics_get_descent(metrics));
			TAG(t_img, "rise", -PANGO_PIXELS_CEIL(pango_font_metrics_get_descent(metrics))*PANGO_SCALE);
			pango_font_metrics_unref(metrics);
			
			// gtk docs say the tag added to the GtkTextTagTable last wins if two set the same tag,
			// but this one wins over oldmessage no matter which is first. not sure what's going on
			TAG(t_imgalt, "scale", (gdouble)0.0);
			
			//three guesses whether negative indent is documented anywhere other than pango_layout_set_indent()
			//eight guesses how I got the idea of looking there
			TAG(t_message_large, "indent", (gint)-INDENT_WRAP);
			TAG(t_message_small, "indent", (gint)-(INDENT_WRAP/2));
			TAG(t_oldmessage, "scale", (gdouble)0.75);
			
			TAG(t_bold, "weight", PANGO_WEIGHT_BOLD);
			TAG(t_underline, "underline", PANGO_UNDERLINE_SINGLE);
			TAG(t_italics, "style", PANGO_STYLE_ITALIC);
			TAG(t_strike, "strikethrough", true);
			
			TAG(t_ilink_target, "invisible", true);
			TAG(t_hidden, "invisible", true);
			
			GdkRGBA c_gray = { 0, 0, 0, 0.125 };
			TAG(t_monospace, "family", "monospace", "background-rgba", &c_gray);
#undef TAG
#undef TAG0
			
#ifdef ARLIB_GUI_GTK3
			//https://developer.gnome.org/gdk3/stable/gdk3-Cursors.html#GdkCursorType
			//"The recommended way to create cursors is to use gdk_cursor_new_from_name()"
			//except that just returns null for some weird reason.
			c_hyperlink = gdk_cursor_new_for_display(gdk_display_get_default(), GDK_HAND1);
#else
			c_hyperlink = gdk_cursor_new_from_name("pointer", NULL);
#endif
			
#ifdef ARLIB_GUI_GTK3
			img_indent = gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8, INDENT_NEWLINE, line_height);
			gdk_pixbuf_fill(img_indent, 0x00000000);
			
			img_indent_small = gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8, INDENT_NEWLINE, shrink_size(line_height));
			gdk_pixbuf_fill(img_indent_small, 0x00000000);
#else
			img_indent = gdk_paintable_new_empty(INDENT_NEWLINE, line_height);
			img_indent_small = gdk_paintable_new_empty(INDENT_NEWLINE, shrink_size(line_height));
#endif
		}
		
		static unsigned shrink_size(unsigned in)
		{
			// TODO: figure out if this formula is correct, the only known value is 17->13
			unsigned ret = (unsigned)(in*0.75 + 0.5);
			return ret ? ret : 1;
		}
		
		~tags_t()
		{
			//this isn't really necessary, but it's harmless
			if (t_message_large)
			{
				for (auto& pair : t_fgcol_map) { g_object_unref(pair.value); }
				for (auto& pair : t_bgcol_map) { g_object_unref(pair.value); }
				
				g_object_unref(t_message_large);
				g_object_unref(t_message_small);
				g_object_unref(t_oldmessage);
				g_object_unref(t_img);
				g_object_unref(t_imgalt);
				
				g_object_unref(t_bold);
				g_object_unref(t_underline);
				g_object_unref(t_italics);
				g_object_unref(t_strike);
				g_object_unref(t_monospace);
				
				g_object_unref(t_hyperlink);
				g_object_unref(t_ilink_target);
				g_object_unref(t_hidden);
				
				g_object_unref(c_hyperlink);
				
				g_object_unref(img_indent);
				g_object_unref(img_indent_small);
			}
			
			g_object_unref(table);
		}
	};
	
	//I don't like global variables, but the alternative is passing around textview pointers in messy ways.
	//It's forcibly single-threaded, constant post-initialization, and always used in a correct run of the program,
	// which covers all complaints except 'global variable bad because global variable bad'.
	//('Correct run' excludes bad config with no protocols installed.)
	static tags_t g_tags;
}

//Gtk somehow likes to calculate wrong scroll position. It seems to not know the correct size right away.
//(To demonstrate, remove scroll_to_last_read from onscroll().)
//To delete that nonsense, I catch the 'changed' signal on the scrollbar. If it resizes such that
// the scroll position is no longer at the bottom, scroll back to the bottom.
//
//And it has some strange 'kinetic' scroll animation. Luckily, it can be disabled - though
// I didn't find that without writing some really nasty workaround first...
//
//and some part of that is buggy; sometimes it hops to the top of the buffer, sometimes half of it is rendered from
// wrong Y coordinate (forcing a redraw, for example click -> focus change -> state-flags-changed signal, fixes it)
//not sure how to fix that one, I can't even reliably reproduce it...

//replacing the GdkPixbufs is also quite nasty

static double scrollbar_max(GtkAdjustment* scroll)
{
	return gtk_adjustment_get_upper(scroll) - gtk_adjustment_get_page_size(scroll);
}

bool textview::scroll_at_bottom(bool* strict)
{
	if (!view) return false;
	
	GtkAdjustment* scroll = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(view));
	double y = gtk_adjustment_get_value(scroll);
	double ymax = scrollbar_max(scroll);
	
	if (strict) *strict = (y == ymax);
	return (y >= ymax-1); // -1 to allow rounding errors
}

void textview::onscroll(bool allow_leave)
{
	bool new_at_bottom_strict;
	bool new_at_bottom = scroll_at_bottom(&new_at_bottom_strict);
	if (at_bottom && !new_at_bottom && !allow_leave)
	{
		at_bottom = true;
		scroll_to_last_read();
	}
	else
	{
		at_bottom = new_at_bottom;
		if (new_at_bottom && !new_at_bottom_strict)
			scroll_to_last_read();
	}
	
	if (onscroll_cb)
	{
		onscroll_cb(scroll_at_bottom());
	}
}


//a selection bound may not lie between a GdkPixbuf and the alt-text tag, or inside the tag
// if it does, it must be put on the far side of the image
//since the alt-text tag always lies to the right of the image, this simplifies to
// 'if a selection bound points inside, or to the start of, an alt-ext tag, move it to the end of said tag'
//which further simplifies to 'if the pointed-to character is inside the tag, move to after the tag end'
static GtkTextIter imgalt_get_iter(GtkTextBuffer* buf,
                                   GtkTextMark* mark,
                                   bool* do_move)
{
	GtkTextIter ret;
	gtk_text_buffer_get_iter_at_mark(buf, &ret, mark);
	if (gtk_text_iter_has_tag(&ret, g_tags.t_imgalt))
	{
		*do_move = true;
		gtk_text_iter_forward_to_tag_toggle(&ret, g_tags.t_imgalt);
	}
	
	//with my spacing images, possible cursor positions are
	// abc*<lf>*<img>*def
	//with corresponding mouse positions with word wrap, gtk puts cursor at first one for all three options
	//but I'd rather leave the third position available, so text can be copied without adding an extra linebreak
	//second is pointless, it should redirect to third
	//-> if cursor is on the image, one char forward
#ifdef ARLIB_GUI_GTK3
	if (gtk_text_iter_get_pixbuf(&ret) == g_tags.img_indent)
#else
	if (gtk_text_iter_get_paintable(&ret) == g_tags.img_indent)
#endif
	{
		*do_move = true;
		gtk_text_iter_forward_char(&ret);
	}
	//it's impossible for both of those to be true simultaneously, in either order
	return ret;
}

static void imgalt_update(GtkTextBuffer* buf)
{
	bool do_move = false;
	GtkTextIter insert = imgalt_get_iter(buf, gtk_text_buffer_get_insert(         buf), &do_move);
	GtkTextIter sbound = imgalt_get_iter(buf, gtk_text_buffer_get_selection_bound(buf), &do_move);
	
	if (do_move)
	{
		gtk_text_buffer_select_range(buf, &insert, &sbound);
	}
}

static void imgalt_cb(GObject* gobject, GParamSpec* pspec, void* user_data)
{
	imgalt_update(GTK_TEXT_BUFFER(gobject));
}

textview::textview(uint32_t flags)
{
	this->flags = flags;
	
	view = NULL;
	this->buf = gtk_text_buffer_new(g_tags.table);
	
	GtkTextIter end;
	gtk_text_buffer_get_end_iter(buf, &end);
	this->lastread = gtk_text_buffer_create_mark(buf, "lastRead", &end, true);
	
	if (!g_tags.t_message_large)
	{
		gtkwidget(); // create it, taglist needs a widget. this one's gonna be focused immediately anyways
		g_tags.init(GTK_WIDGET(view));
	}
	if (flags & f_less_indent)
		t_message = g_tags.t_message_small;
	else
		t_message = g_tags.t_message_large;
	
	//this doesn't do anything if selection-bound moves without cursor moving, but as far as I've seen,
	// user can't move it to any place other than 'right where main cursor is' which is caught
	//(okay, code can move it, but it won't.)
	
	//the cursor itself is invisible, but selecting text isn't; also affects copypaste
	g_signal_connect(buf, "notify::cursor-position", G_CALLBACK(imgalt_cb), NULL);
//gtkwidget();
gtk_text_mark_set_visible(this->lastread, true);
}

//Undefined behavior if t_hyperlink is not set at the pointed-to character. g_free() the return value when you're done.
//If t_ilink_target is non-NULL and set on the text immediately before the hyperlink, that tag's text is returned instead.
//If used_ilink is non-NULL and t_ilink_target was used, it will be set to true.
// If not used, will remain unchanged; caller should initialize it to false.
static char* link_from_iter(GtkTextIter* iter, GtkTextTag* t_hyperlink, GtkTextTag* t_ilink_target, bool* used_ilink)
{
	GtkTextIter begin = *iter;
	if (!gtk_text_iter_starts_tag(&begin, t_hyperlink))
		gtk_text_iter_backward_to_tag_toggle(&begin, t_hyperlink);
	if (t_ilink_target && gtk_text_iter_ends_tag(&begin, t_ilink_target))
	{
		if (used_ilink) *used_ilink = true;
		gtk_text_iter_backward_to_tag_toggle(&begin, t_ilink_target);
		t_hyperlink = t_ilink_target;
	}
	GtkTextIter end = begin;
	if (!gtk_text_iter_ends_tag(&end, t_hyperlink))
		gtk_text_iter_forward_to_tag_toggle(&end, t_hyperlink);
	
	gchar* text = gtk_text_iter_get_text(&begin, &end);
	return text;
}

static bool mouse_on_link(GtkTextView* view, GtkTextIter* iter, double x, double y)
{
	GtkTextIter tmp;
	if (!iter) iter = &tmp;
	
	int tx, ty;
	gtk_text_view_window_to_buffer_coords(view, GTK_TEXT_WINDOW_TEXT, x, y, &tx, &ty);
	
	bool mouse_on_char = gtk_text_view_get_iter_at_position(view, iter, NULL, tx, ty);
	return (mouse_on_char && gtk_text_iter_has_tag(iter, g_tags.t_hyperlink));
}

GtkWidget* textview::gtkwidget()
{
	if (view) return GTK_WIDGET(scrollview);
	
	view = GTK_TEXT_VIEW(gtk_text_view_new_with_buffer(buf));
	gtk_text_view_set_wrap_mode(view, GTK_WRAP_WORD_CHAR);
	
	//known bugs if not readonly:
	//- backspacing images removes the alt-text, one character at the time
	//- left arrow has no effect if beside an image, you end up back where you started
	//no known bugs in mouse selection
	gtk_text_view_set_editable(view, false);
	gtk_text_view_set_cursor_visible(view, false);
	
	scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(
#ifdef ARLIB_GUI_GTK3
NULL, NULL
#endif
	));
	//I'd rather have NEVER than EXTERNAL, but that makes the textview refuse to
	// shrink if that would change word wrapping
	gtk_scrolled_window_set_policy(scrollview, GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC);
#ifdef ARLIB_GUI_GTK3
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(view));
#else
	gtk_scrolled_window_set_has_frame(scrollview, true);
	gtk_scrolled_window_set_child(scrollview, GTK_WIDGET(view));
#endif
	
	gtk_text_view_set_top_margin(view, 1440);
	
	GtkAdjustment* scrollbar = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(view));
	void(*scrollval_cb)(GtkAdjustment* adjustment, void* user_data) =
	                 [](GtkAdjustment* adjustment, void* user_data)
	{
		((textview*)user_data)->onscroll(true);
	};
	void(*scrolled_cb)(GtkAdjustment* adjustment, void* user_data) =
	                [](GtkAdjustment* adjustment, void* user_data)
	{
		((textview*)user_data)->onscroll(false);
	};
	g_signal_connect(scrollbar, "value-changed", G_CALLBACK(scrollval_cb), this);
	g_signal_connect(scrollbar, "changed", G_CALLBACK(scrolled_cb), this);
	
	
#ifdef ARLIB_GUI_GTK3
	GtkEventController* motion_ctrl = gtk_event_controller_motion_new(GTK_WIDGET(view));
#else
	GtkEventController* motion_ctrl = gtk_event_controller_motion_new();
	gtk_widget_add_controller(GTK_WIDGET(view), motion_ctrl);
#endif
	gtk_event_controller_set_propagation_phase(motion_ctrl, GTK_PHASE_CAPTURE);
	auto motion_cb = decompose_lambda([this](double x, double y, GtkEventControllerMotion* self) {
#ifdef ARLIB_GUI_GTK3
		gdk_window_set_cursor(gtk_text_view_get_window(this->view, GTK_TEXT_WINDOW_TEXT),
			mouse_on_link(this->view, NULL, x, y) ? g_tags.c_hyperlink : NULL);
#else
		gtk_widget_set_cursor(GTK_WIDGET(this->view), mouse_on_link(this->view, NULL, x, y) ? g_tags.c_hyperlink : NULL);
#endif
	});
	g_signal_connect_swapped(motion_ctrl, "motion", G_CALLBACK(motion_cb.fp), motion_cb.ctx);
	
#ifdef ARLIB_GUI_GTK3
	auto event_cb = decompose_lambda([this](GdkEvent* event, GtkWidget* widget)->gboolean
	{
		gint x;
		gint y;
		if (event->type == GDK_MOTION_NOTIFY)
		{
			x = event->motion.x;
			y = event->motion.y;
		}
		else if (event->type == GDK_BUTTON_PRESS || event->type == GDK_BUTTON_RELEASE)
		{
			x = event->button.x;
			y = event->button.y;
		}
		else return GDK_EVENT_PROPAGATE;
		
		GtkTextIter active_char;
		if (mouse_on_link(view, &active_char, x, y))
		{
			if (event->type == GDK_BUTTON_PRESS && event->button.button == 1) link_click = true;
			else if (event->type == GDK_BUTTON_RELEASE && event->button.button == 1 && link_click)
			{
				bool is_ilink = false;
				gchar* text = link_from_iter(&active_char, g_tags.t_hyperlink, g_tags.t_ilink_target, &is_ilink);
				if (is_ilink)
				{
					ilink_cb(string::create_usurp(text));
				}
				else
				{
					//firefox doesn't properly tell gtk that the link is open, so cursor gets stuck on 'opening...' for a few seconds
					//GtkWindow* parent = GTK_WINDOW(gtk_widget_get_toplevel(widget)); // clicked = in a window = toplevel is a window
					//gtk_show_uri_on_window(parent, text, event->button.time, NULL);
					//g_free(text);
					system("x-www-browser '"+string::create_usurp(text).replace("'","'\"'\"'")+"'");
				}
			}
			else link_click = false;
			
			goto cur_link;
		}
		else link_click = false;
		
		gdk_window_set_cursor(gtk_text_view_get_window(this->view, GTK_TEXT_WINDOW_TEXT), NULL);
		return GDK_EVENT_PROPAGATE;
		
	cur_link:
		gdk_window_set_cursor(gtk_text_view_get_window(this->view, GTK_TEXT_WINDOW_TEXT), g_tags.c_hyperlink);
		// PROPAGATE would be more polite, but if ilink_cb rewrites the textview too much (for example todo list Open 5 links),
		// Gtk will crash with 'Byte index 58 is off the end of the line'
		if (link_click) return GDK_EVENT_STOP;
		return GDK_EVENT_PROPAGATE;
	});
	//don't put this event on the tag, we need to unset the cursor if mouse is no longer on a link
	//also the given GtkTextIter is off by half a character; it points to where cursor would end up if mouse is clicked,
	//  not the actual pointed-to character
	g_signal_connect_swapped(view, "event", G_CALLBACK(event_cb.fp), event_cb.ctx);
	
	void(*reset_cursor)(GtkWidget* widget, GtkStateFlags flags, void* user_data) =
	                 [](GtkWidget* widget, GtkStateFlags flags, void* user_data)
	{
		textview* this_ = (textview*)user_data;
		GdkWindow* wnd = gtk_text_view_get_window(this_->view, GTK_TEXT_WINDOW_TEXT);
		// this is NULL if state flags change before the object is realized
		// for example the gtk_widget_set_sensitive hack in main.cpp, but others wouldn't be obviously impossible
		if (!wnd) return;
		
		GdkDevice* dev = gdk_seat_get_pointer(gdk_display_get_default_seat(gdk_display_get_default()));
		int x, y;
		gdk_window_get_device_position(gtk_widget_get_window(GTK_WIDGET(widget)), dev, &x, &y, NULL);
		
		if (mouse_on_link(GTK_TEXT_VIEW(widget), NULL, x, y))
			gdk_window_set_cursor(wnd, g_tags.c_hyperlink);
		else
			gdk_window_set_cursor(wnd, NULL);
	};
	g_signal_connect(view, "state-flags-changed", G_CALLBACK(reset_cursor), this);
	
	auto menu_cb = decompose_lambda([this](GtkWidget* popup, GtkTextView* text_view)->gboolean
	{
		if (!GTK_IS_MENU_SHELL(popup)) return GDK_EVENT_PROPAGATE;
		gtk_container_foreach(GTK_CONTAINER(popup), (GtkCallback)gtk_widget_destroy, NULL);
		
		GdkDevice* dev = gdk_seat_get_pointer(gdk_display_get_default_seat(gdk_display_get_default()));
		int x, y;
		gdk_window_get_device_position(gtk_widget_get_window(GTK_WIDGET(text_view)), dev, &x, &y, NULL);
		
		ctxmenu_update(x, y);
		
		for (ctxaction& act : ctxmenu_actions)
		{
			GtkWidget* item;
			if (act.text.length() < 50)
				item = gtk_menu_item_new_with_mnemonic(act.text);
			else
				item = gtk_menu_item_new_with_mnemonic(act.text.substr(0, 40)+"...");
			if (act.action)
			{
				auto [ b, fn, ctx ] = act.action.try_decompose();
				g_signal_connect_swapped(item, "activate", G_CALLBACK(fn), ctx);
			}
			else
			{
				gtk_widget_set_sensitive(item, false);
			}
			gtk_menu_shell_append(GTK_MENU_SHELL(popup), item);
			gtk_widget_show(item);
		}
		
		return GDK_EVENT_PROPAGATE;
	});
	g_signal_connect_swapped(view, "populate-popup", G_CALLBACK(menu_cb.fp), menu_cb.ctx);
#else
	GtkGesture* click_ctrl = gtk_gesture_click_new();
	gtk_gesture_single_set_button(GTK_GESTURE_SINGLE(click_ctrl), 0);
	gtk_event_controller_set_propagation_phase(GTK_EVENT_CONTROLLER(click_ctrl), GTK_PHASE_CAPTURE);
	gtk_widget_add_controller(GTK_WIDGET(view), GTK_EVENT_CONTROLLER(click_ctrl));
	auto click_press_cb = decompose_lambda([this](int n_press, double x, double y, GtkGestureClick* self) {
		if (gtk_gesture_single_get_current_button(GTK_GESTURE_SINGLE(self)) == GDK_BUTTON_PRIMARY)
			link_click = true;
		
		GdkEventSequence* seq = gtk_gesture_single_get_current_sequence(GTK_GESTURE_SINGLE(self));
		GdkEvent* ev = gtk_gesture_get_last_event(GTK_GESTURE(self), seq);
		
		// GtkTextView checks n_press == 1, but I need to consume all, or it gets the click
		if (gdk_event_triggers_context_menu(ev))
		{
			gtk_gesture_set_sequence_state(GTK_GESTURE(self), seq, GTK_EVENT_SEQUENCE_CLAIMED);
			if (n_press == 1)
			{
				ctxmenu_update(x, y);
				
				GSimpleActionGroup* ag = g_simple_action_group_new();
				GSimpleAction* act = g_simple_action_new("textview", G_VARIANT_TYPE_STRING);
				g_action_map_add_action(G_ACTION_MAP(ag), G_ACTION(act));
				gtk_widget_insert_action_group(GTK_WIDGET(this->view), "russian", G_ACTION_GROUP(ag));
				
				auto menu_cb = decompose_lambda([this](GVariant* parameter, GSimpleAction* self)
				{
					uint32_t id;
					fromstring(g_variant_get_string(parameter, NULL), id);
					ctxmenu_actions[id].action();
				});
				g_signal_connect_swapped(act, "activate", G_CALLBACK(menu_cb.fp), menu_cb.ctx);
				
				GMenu* menu = g_menu_new();
				uint32_t i=0;
				for (ctxaction& act : ctxmenu_actions)
				{
					string name;
					if (act.action) name = "russian.textview::"+tostring(i);
					else name = "russian.inactive";
					
					GMenuItem* item;
					if (act.text.length() < 50)
						item = g_menu_item_new(act.text, name);
					else
						item = g_menu_item_new(act.text.substr(0, 40)+"...", name);
					g_menu_append_item(menu, item);
					
					i++;
				}
				
				GtkPopover* pop = GTK_POPOVER(gtk_popover_menu_new_from_model(G_MENU_MODEL(menu)));
				gtk_widget_set_parent(GTK_WIDGET(pop), GTK_WIDGET(this->view));
				
				GdkRectangle rect = { (int)x, (int)y, 1, 1 };
				gtk_popover_set_pointing_to(pop, &rect);
				
				gtk_popover_popup(pop);
			}
		}
	});
	auto click_release_cb = decompose_lambda([this](int n_press, double x, double y, GtkGestureClick* self) {
		if (!link_click)
			return;
		if (gtk_gesture_single_get_current_button(GTK_GESTURE_SINGLE(self)) != GDK_BUTTON_PRIMARY)
			return;
		
		GtkTextIter active_char;
		if (!mouse_on_link(this->view, &active_char, x, y)) return;
		
		bool is_ilink = false;
		gchar* text = link_from_iter(&active_char, g_tags.t_hyperlink, g_tags.t_ilink_target, &is_ilink);
		if (is_ilink)
		{
			ilink_cb(string::create_usurp(text));
		}
		else
		{
			//GtkWindow* parent = GTK_WINDOW(gtk_widget_get_root(GTK_WIDGET(this->view)));
			//gtk_show_uri(parent, text, gtk_event_controller_get_current_event_time(GTK_EVENT_CONTROLLER(self)));
			system("x-www-browser '"+text.replace("'","'\"'\"'")+"'");
			g_free(text);
		}
	});
	auto click_stop_cb = decompose_lambda([this](GtkGestureClick* self) {
		if (gtk_gesture_single_get_current_button(GTK_GESTURE_SINGLE(self)) != GDK_BUTTON_PRIMARY)
			return;
		link_click = false;
	});
	g_signal_connect_swapped(click_ctrl, "pressed", G_CALLBACK(click_press_cb.fp), click_press_cb.ctx);
	g_signal_connect_swapped(click_ctrl, "released", G_CALLBACK(click_release_cb.fp), click_release_cb.ctx);
	g_signal_connect_swapped(click_ctrl, "stopped", G_CALLBACK(click_stop_cb.fp), click_stop_cb.ctx);
#endif
	
	scroll_to_last_read();
	
	gtk_widget_set_name(GTK_WIDGET(view), "textview");
	
	return GTK_WIDGET(scrollview);
}

void textview::ctxmenu_update(int mouse_x, int mouse_y)
{
	ctxmenu_actions.reset();
	
	if (gtk_text_buffer_get_selection_bounds(buf, NULL, NULL))
	{
		ctxmenu_actions.append({ "_Copy", [this](){
#ifdef ARLIB_GUI_GTK3
				gtk_text_buffer_copy_clipboard(this->buf, gtk_clipboard_get(GDK_SELECTION_CLIPBOARD));
#else
				gtk_text_buffer_copy_clipboard(this->buf, gtk_widget_get_clipboard(GTK_WIDGET(this->view)));
#endif
			} });
	}
	else
	{
		ctxmenu_actions.append({ "_Copy", NULL });
	}
	
	GtkTextIter it;
	if (mouse_on_link(this->view, &it, mouse_x, mouse_y))
	{
		string link_target = string::create_usurp(link_from_iter(&it, g_tags.t_hyperlink, NULL, NULL));
		
		if (link_target.startswith("http://") || link_target.startswith("https://"))
		{
			ctxmenu_actions.append({ link_target, NULL });
			
			ctxmenu_actions.append({ "Open Link in Browser", [this, link_target](){
					//g_app_info_launch_default_for_uri(link_target, NULL, NULL);
					system("x-www-browser '"+link_target.replace("'","'\"'\"'")+"'");
				} });
			
			ctxmenu_actions.append({ "Copy Selected Link", [this, link_target](){
#ifdef ARLIB_GUI_GTK3
					gtk_clipboard_set_text(gtk_clipboard_get(GDK_SELECTION_CLIPBOARD), link_target, -1);
#else
					gdk_clipboard_set_text(gtk_widget_get_clipboard(GTK_WIDGET(this->view)), link_target);
#endif
				} });
		}
	}
	
	const char * msgname = "";
	
	if (!gtk_text_iter_starts_tag(&it, t_message))
		gtk_text_iter_backward_to_tag_toggle(&it, t_message);
	GSList* marks = gtk_text_iter_get_marks(&it);
	GSList* mark_iter = marks;
	while (mark_iter)
	{
		const char * thisname = gtk_text_mark_get_name(GTK_TEXT_MARK(mark_iter->data));
		// gtk itself creates a few anonymous marks
		if (thisname && thisname[0] == '$') msgname = thisname+1;
		mark_iter = mark_iter->next;
	}
	g_slist_free(marks);
	
	onctxmenu_cb(ctxmenu_actions, msgname);
}


textview::image* textview::image::create(arrayview<uint8_t> bytes, uint32_t width, uint32_t height)
{
	GInputStream* is = g_memory_input_stream_new_from_data(bytes.ptr(), bytes.size(), NULL);
	GdkPixbuf* pix = gdk_pixbuf_new_from_stream_at_scale(is, width, height, true, NULL, NULL);
	g_object_unref(is);
	if (pix)
#ifdef ARLIB_GUI_GTK3
		return new image(pix);
#else
		return new image(GDK_PAINTABLE(gdk_texture_new_for_pixbuf(pix)));
#endif
	else
		return NULL;
}

textview::image* textview::image::blank(uint32_t width, uint32_t height)
{
#ifdef ARLIB_GUI_GTK3
	GdkPixbuf* pix = gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8, width, height);
	gdk_pixbuf_fill(pix, 0x00000000);
	return new image(pix);
#else
	return new image(gdk_paintable_new_empty(width, height));
#endif
}

uint32_t textview::image::width() const { return gdk_pixbuf_get_width(pix); }
uint32_t textview::image::height() const { return gdk_pixbuf_get_height(pix); }

textview::image::~image()
{
	g_object_unref(pix);
}


void textview::scrollback(cstring text)
{
	GtkTextIter iter;
	gtk_text_buffer_get_end_iter(buf, &iter);
	gtk_text_buffer_insert(buf, &iter, text.c_str(), text.length()-1); // -1 to drop the final \n
	gtk_text_buffer_move_mark(this->buf, this->lastread, &iter);
	
	GtkTextIter start;
	gtk_text_buffer_get_start_iter(buf, &start);
	gtk_text_buffer_apply_tag(buf, t_message, &start, &iter);
}


void textview::scroll_to_last_read()
{
	bool prev_kinetic = gtk_scrolled_window_get_kinetic_scrolling(scrollview);
	gtk_scrolled_window_set_kinetic_scrolling(scrollview, false);
	//put mark to the top right rather than the obvious top left; GTK_WRAP_WORD_CHAR says there should be no scrollbars (unless some single
	// char is wider than viewport), but there was a bug in Gtk 3.10 (but not 3.22) with large numbers of consecutive punctuation marks
	//I could ifdef the workaround, but there's no reason. The bug will resurface if I start embedding images,
	// and the workaround has exactly zero cost.
	gtk_text_view_scroll_to_mark(view, lastread, 0.0, true, 1.0, 0.0);
	gtk_scrolled_window_set_kinetic_scrolling(scrollview, prev_kinetic);
}

void textview::move_last_read()
{
	if (!view) return;
	
	GtkTextIter iter;
	if (scroll_at_bottom())
		gtk_text_buffer_get_end_iter(buf, &iter);
	else
		gtk_text_view_get_line_at_y(view, &iter, gtk_adjustment_get_value(gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(view))), NULL);
	gtk_text_buffer_move_mark(buf, lastread, &iter);
}

void textview::message_insert_at(GtkTextIter* iter, arrayview<span> spans)
{
	bool prev_link = false;
	for (size_t i=0;i<spans.size();i++)
	{
		if (spans[i].i_link)
		{
			const string& text = spans[i].text;
			if (spans[i].hidden) i++;
			
			if (LIKELY(g_utf8_validate(text, text.length(), NULL)))
			{
				gtk_text_buffer_insert_with_tags(buf, iter, text, text.length(), t_message, g_tags.t_ilink_target, NULL);
			}
			else
			{
				debug_warn("textview: utf8 error\n");
				gtk_text_buffer_insert(buf, iter, "<UTF8 ERROR>", -1);
				string sanitized = string::create_usurp(g_utf8_make_valid(text, text.length()));
				gtk_text_buffer_insert_with_tags(buf, iter, sanitized, sanitized.length(), t_message, g_tags.t_ilink_target, NULL);
			}
			prev_link = false;
		}
		
		const span& sp = spans[i];
		if (sp.hidden) continue;
		if (sp.img)
		{
#ifdef ARLIB_GUI_GTK3
			gtk_text_buffer_insert_pixbuf(buf, iter, sp.img->pix);
#else
			gtk_text_buffer_insert_paintable(buf, iter, sp.img->pix);
#endif
			GtkTextIter start = *iter;
			gtk_text_iter_backward_char(&start);
			gtk_text_buffer_apply_tag(buf, g_tags.t_img, &start, iter);
			prev_link = false;
		}
		
		if (sp.hyperlink && prev_link) // a separator so consecutive hyperlinks don't get merged
			gtk_text_buffer_insert_with_tags(buf, iter, "a", 1, t_message, g_tags.t_hidden, NULL);
		prev_link = (sp.hyperlink || sp.i_link);
		
		size_t start_offset = gtk_text_iter_get_offset(iter);
		if (LIKELY(g_utf8_validate(sp.text, sp.text.length(), NULL)))
		{
			gtk_text_buffer_insert(buf, iter, sp.text, sp.text.length());
		}
		else
		{
			debug_warn("textview: utf8 error\n");
			string sanitized = (cstring)"<UTF8 ERROR>" + g_utf8_make_valid(sp.text, sp.text.length());
			gtk_text_buffer_insert(buf, iter, sanitized, sanitized.length());
		}
		
		GtkTextIter start;
		gtk_text_buffer_get_iter_at_offset(buf, &start, start_offset);
		if (sp.img)
		{
			gtk_text_buffer_apply_tag(buf, g_tags.t_imgalt, &start, iter);
			gtk_text_buffer_get_iter_at_offset(buf, &start, start_offset-1); // t_message and t_bgcol should be applied to the image too
		}
		gtk_text_buffer_apply_tag(buf, t_message, &start, iter);
		
		if (sp.bold) gtk_text_buffer_apply_tag(buf, g_tags.t_bold, &start, iter);
		if (sp.underline) gtk_text_buffer_apply_tag(buf, g_tags.t_underline, &start, iter);
		if (sp.italics) gtk_text_buffer_apply_tag(buf, g_tags.t_italics, &start, iter);
		if (sp.strike) gtk_text_buffer_apply_tag(buf, g_tags.t_strike, &start, iter);
		if (sp.monospace) gtk_text_buffer_apply_tag(buf, g_tags.t_monospace, &start, iter);
		
		// don't apply both fgcol and hyperlink; fgcol is added to the tag table later, so it'd win, but we'd prefer if hyperlink wins
		// except for spoilers, which should have both (fgcol, being created dynamically, is newer and wins)
		if (prev_link)
			gtk_text_buffer_apply_tag(buf, g_tags.t_hyperlink, &start, iter);
		if ((!prev_link || sp.is_spoiler()) && sp.fgcol != (uint32_t)-1)
			gtk_text_buffer_apply_tag(buf, g_tags.t_fgcol(sp.fgcol), &start, iter);
		
		if (sp.bgcol != (uint32_t)-1)
			gtk_text_buffer_apply_tag(buf, g_tags.t_bgcol(sp.bgcol), &start, iter);
		
		if (sp.text.contains("\n") && !(flags & f_less_indent))
		{
			while (!gtk_text_iter_equal(&start, iter))
			{
				//this is almost gtk_text_iter_forward_find_char, but that one is left-exclusive, right-inclusive,
				// and takes no significant performance shortcuts, so it's easier to reinvent it
				if (gtk_text_iter_get_char(&start) == '\n')
				{
					gtk_text_iter_forward_char(&start);
					
					size_t end_offset = gtk_text_iter_get_offset(iter);
#ifdef ARLIB_GUI_GTK3
					gtk_text_buffer_insert_pixbuf(buf, &start, g_tags.img_indent);
#else
					gtk_text_buffer_insert_paintable(buf, &start, g_tags.img_indent);
#endif
					// +1 because insertion shifting everything
					gtk_text_buffer_get_iter_at_offset(buf, iter, end_offset+1);
					
					GtkTextIter imgbefore = start;
					gtk_text_iter_backward_char(&imgbefore);
					gtk_text_buffer_apply_tag(buf, t_message,    &imgbefore, &start);
					gtk_text_buffer_apply_tag(buf, g_tags.t_img, &imgbefore, &start);
					
					//if I want same tags as previous char (replace_image), they disappear; if I'd rather have text untagged (here), they stay?
					//what are the exact rules for tag inheritance on fresh text, and what's the probability they'll cause even bigger bugs somewhere?
					if (sp.monospace) gtk_text_buffer_remove_tag(buf, g_tags.t_monospace, &imgbefore, &start);
					if (sp.bgcol != (uint32_t)-1)
						gtk_text_buffer_remove_tag(buf, g_tags.t_bgcol(sp.bgcol), &imgbefore, &start);
				}
				else gtk_text_iter_forward_char(&start);
			}
		}
	}
	//no protection is needed against U+202E RIGHT-TO-LEFT OVERRIDE, GTK automatically terminates its effect on linebreak
}

void textview::message_at(cstring prev, bool after, cstring newid, arrayview<span> spans, bool mark_read)
{
	g_object_freeze_notify(buf);
	bool to_bottom = scroll_at_bottom();
	
	GtkTextIter iter;
	
	if (prev)
	{
		//gtk has builtin marks 'insert' and 'selection_bound', namespace ourselves so gtk goes away
		//also to allow the lastRead mark to not collide with anything
		GtkTextMark* prevmark = gtk_text_buffer_get_mark(buf, "$"+prev);
		gtk_text_buffer_get_iter_at_mark(buf, &iter, prevmark);
		
		if (after)
		{
			if (mark_read)
			{
				GtkTextIter lastread_iter;
				gtk_text_buffer_get_iter_at_mark(buf, &lastread_iter, this->lastread);
				mark_read = (gtk_text_iter_equal(&iter, &lastread_iter));
			}
			
			gtk_text_iter_forward_to_tag_toggle(&iter, t_message);
		}
		else
		{
			mark_read = false; // inserting before a message will put lastRead after it, as appropriate; nothing to do
			gtk_text_iter_backward_char(&iter);
		}
	}
	else
	{
		gtk_text_buffer_get_end_iter(buf, &iter);
		
		if (mark_read)
		{
			GtkTextIter lastread_iter;
			gtk_text_buffer_get_iter_at_mark(buf, &lastread_iter, this->lastread);
			mark_read = (gtk_text_iter_equal(&iter, &lastread_iter));
		}
	}
	gtk_text_buffer_insert(buf, &iter, "\n", -1);
	
	if (newid)
	{
		gtk_text_buffer_create_mark(buf, "$"+newid, &iter, true);
	}
	
	message_insert_at(&iter, spans);
	
	if (mark_read)
	{
		gtk_text_iter_forward_char(&iter); // does nothing on end iterator; if not end, goes to the next line
		gtk_text_buffer_move_mark(buf, this->lastread, &iter);
	}
	
	if (to_bottom)
		scroll_to_last_read();
	
	g_object_thaw_notify(buf);
}

bool textview::message_exists(cstring id)
{
	return gtk_text_buffer_get_mark(buf, "$"+id) != NULL;
}

void textview::message_edit_visible(cstring id, arrayview<span> spans)
{
	g_object_freeze_notify(buf);
	bool to_bottom = scroll_at_bottom();
	
	GtkTextIter iter;
	
	//gtk has builtin marks 'insert' and 'selection_bound', namespace ourselves so gtk goes away
	string idReal = "$"+id;
	
	GtkTextMark* mark = gtk_text_buffer_get_mark(buf, idReal);
	gtk_text_buffer_get_iter_at_mark(buf, &iter, mark);
	GtkTextIter iterend = iter;
	gtk_text_iter_forward_to_tag_toggle(&iterend, t_message);
	
	int x = gtk_text_iter_get_offset(&iterend);
	if (spans.size())
	{
		gtk_text_buffer_insert(buf, &iterend, "\n", -1);
		message_insert_at(&iterend, spans);
	}
	gtk_text_iter_set_offset(&iterend, x + (bool)spans.size());
	gtk_text_buffer_get_iter_at_mark(buf, &iter, mark);
	
	// iter - start of the message
	// iterend - just after \n on the now-old message, or after its end if the message is being deleted
	
	if (gtk_text_iter_has_tag(&iter, g_tags.t_oldmessage)) // forward so images aren't shrunk twice
		gtk_text_iter_forward_to_tag_toggle(&iter, g_tags.t_oldmessage);
	gtk_text_buffer_apply_tag(buf, g_tags.t_oldmessage, &iter, &iterend);
	//treat new and old messages as a single message, with a \n in the middle
	gtk_text_buffer_apply_tag(buf, t_message, &iter, &iterend);
	
	message_replace_image(&iter, &iterend, bind_this(&textview::shrink_image));
	
	g_object_thaw_notify(buf);
	
	if (to_bottom)
		scroll_to_last_read();
}
GdkPaintable* textview::shrink_image(GdkPaintable* prev)
{
	if (prev == g_tags.img_indent) // hardcode this one, to avoid some pointless duplication
		return g_tags.img_indent_small;
#ifdef ARLIB_GUI_GTK3
	return gdk_pixbuf_scale_simple(prev,
	                               tags_t::shrink_size(gdk_pixbuf_get_width(prev)),
	                               tags_t::shrink_size(gdk_pixbuf_get_height(prev)),
	                               GDK_INTERP_BILINEAR);
#else
	GdkPixbuf* prevpix = gdk_pixbuf_get_from_texture(GDK_TEXTURE(prev)); // we already know this is a pixbuf
	GdkPixbuf* newpix = gdk_pixbuf_scale_simple(prevpix,
	                               tags_t::shrink_size(gdk_pixbuf_get_width(prevpix)),
	                               tags_t::shrink_size(gdk_pixbuf_get_height(prevpix)),
	                               GDK_INTERP_BILINEAR);
	g_object_unref(prevpix);
	return GDK_PAINTABLE(gdk_texture_new_for_pixbuf(newpix));
#endif
}


void textview::message_replace(cstring id, arrayview<span> spans)
{
	g_object_freeze_notify(buf);
	
	GtkTextIter iter;
	
	string idReal = "$"+id;
	
	GtkTextMark* mark = gtk_text_buffer_get_mark(buf, idReal);
	gtk_text_buffer_get_iter_at_mark(buf, &iter, mark);
	GtkTextIter iterend = iter;
	
	gtk_text_iter_forward_to_tag_toggle(&iterend, t_message);
	
	gtk_text_buffer_delete(buf, &iter, &iterend);
	message_insert_at(&iter, spans);
	
	g_object_thaw_notify(buf);
}

void textview::message_delete(cstring id)
{
	g_object_freeze_notify(buf);
	
	GtkTextIter iter;
	
	string idReal = "$"+id;
	
	GtkTextMark* mark = gtk_text_buffer_get_mark(buf, idReal);
	gtk_text_buffer_get_iter_at_mark(buf, &iter, mark);
	GtkTextIter iterend = iter;
	
	gtk_text_iter_forward_to_tag_toggle(&iterend, t_message);
	
	//the \n after a line isn't guaranteed to exist, but the one before is, and all \n are equal
	//so nuke the previous one instead
	gtk_text_iter_backward_char(&iter);
	gtk_text_buffer_delete(buf, &iter, &iterend);
	gtk_text_buffer_delete_mark(buf, mark);
	
	g_object_thaw_notify(buf);
}

void textview::message_get_bounds(cstring id, GtkTextIter* start, GtkTextIter* end)
{
	string idReal = "$"+id;
	
	GtkTextMark* mark = gtk_text_buffer_get_mark(buf, idReal);
	gtk_text_buffer_get_iter_at_mark(buf, start, mark);
	
	*end = *start;
	gtk_text_iter_forward_to_tag_toggle(end, t_message);
}
void textview::message_replace_image(GtkTextIter* start, GtkTextIter* end, function<GdkPaintable*(GdkPaintable* prev)> replace)
{
	g_object_freeze_notify(buf);
	
	//all this crap just to replace some images
	array<int> indices;
	array<GdkPaintable*> replacements;
	
	while (!gtk_text_iter_equal(start, end))
	{
#ifdef ARLIB_GUI_GTK3
		GdkPaintable* pix = gtk_text_iter_get_pixbuf(start);
#else
		GdkPaintable* pix = gtk_text_iter_get_paintable(start);
#endif
		GdkPaintable* newpix = pix ? replace(pix) : NULL;
		if (pix != newpix)
		{
			indices.append(gtk_text_iter_get_offset(start));
			replacements.append(newpix);
		}
		gtk_text_iter_forward_char(start);
	}
	
	for (size_t i=0;i<indices.size();i++)
	{
		int index = indices[i];
		GdkPaintable* pix = replacements[i];
		
		gtk_text_iter_set_offset(start, index);
		GSList* tags = gtk_text_iter_get_tags(start);
		
		*end = *start;
		gtk_text_iter_forward_char(end);
		gtk_text_buffer_delete(buf, start, end);
		
#ifdef ARLIB_GUI_GTK3
		gtk_text_buffer_insert_pixbuf(buf, end, pix);
#else
		gtk_text_buffer_insert_paintable(buf, end, pix);
#endif
		*start = *end;
		gtk_text_iter_backward_char(start);
		
		GSList* tagiter = tags;
		while (tagiter)
		{
			GtkTextTag* tag = (GtkTextTag*)tagiter->data;
			gtk_text_buffer_apply_tag(buf, tag, start, end);
			tagiter = tagiter->next;
		}
		
		g_slist_free(tags);
	}
	
	g_object_thaw_notify(buf);
}
void textview::message_replace_image(cstring id, function<GdkPaintable*(GdkPaintable* prev)> replace)
{
	GtkTextIter start;
	GtkTextIter end;
	if (id)
	{
		message_get_bounds(id, &start, &end);
	}
	else
	{
		gtk_text_buffer_get_start_iter(buf, &start);
		gtk_text_buffer_get_end_iter(buf, &end);
	}
	message_replace_image(&start, &end, replace);
}


unsigned textview::lineheight() { return g_tags.line_height; }

void textview::user_input(int gdk_event_type)
{
#ifdef ARLIB_GUI_GTK3
	static_assert(GDK_KEY_PRESS == 8);
#else
	static_assert(GDK_KEY_PRESS == 4); // if not, update this function's default argument in textview.h
#endif
	if (gdk_event_type == GDK_MOTION_NOTIFY ||
	    gdk_event_type == GDK_BUTTON_PRESS ||
	    gdk_event_type == GDK_KEY_PRESS ||
	    gdk_event_type == GDK_FOCUS_CHANGE ||
	    gdk_event_type == GDK_SCROLL ||
	    gdk_event_type == GDK_TOUCH_UPDATE)
	{
		move_last_read();
	}
}


textview::~textview()
{
	if (view)
		g_object_unref(view);
	g_object_unref(buf);
}

// stupid extra lib for a single function...
#include <fribidi.h>
bool textview::is_rtl(cstring text)
{
	uint32_t pos = 0;
	while (pos < text.length())
	{
		FriBidiCharType ty = fribidi_get_bidi_type(text.codepoint_at(pos));
		if (!FRIBIDI_IS_STRONG(ty))
			continue;
		return FRIBIDI_IS_RTL(ty);
	}
	return false;
}
