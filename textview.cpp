#include "textview.h"
#include <gtk/gtk.h>

#define INDENT_NEWLINE 20
#define INDENT_WRAP 40

// TODO: insert this at the start of every line once ctrl-c is overridden, so things like Ù´ don't make the line RTL
#define LTR_OVERRIDE "\xE2\x80\xAD"

//TODO: figure out if this does anything, the textbuffer sends 'changed' rather than 'notify'
#define g_object_freeze_notify(x) g_object_freeze_notify(G_OBJECT(x))
#define g_object_thaw_notify(x) g_object_thaw_notify(G_OBJECT(x))

namespace {
	class tags_t {
	public:
		GtkTextTagTable* table;
		
		GtkTextTag* t_message; // Everything, except the linebreaks between messages, has this tag. Scrollback counts as one big message.
		GtkTextTag* t_oldmessage;
		GtkTextTag* t_img;
		GtkTextTag* t_imgalt;
		
		GtkTextTag* t_bold;
		GtkTextTag* t_underline;
		GtkTextTag* t_italics;
		GtkTextTag* t_strike;
		GtkTextTag* t_monospace;
		
		GtkTextTag* t_hyperlink;
		GtkTextTag* t_ilink_target;
		
		GdkCursor* c_hyperlink;
		
		map<uint32_t, GtkTextTag*> t_fgcol_map;
		map<uint32_t, GtkTextTag*> t_bgcol_map;
		
		unsigned line_height;
		
		//yes, 20x17 blank image; it's creepy, but anything else yields improper background color, bad selection behavior,
		// or wrong line height on blank lines
		GdkPixbuf* img_indent;
		GdkPixbuf* img_indent_small;
		
		
		GtkTextTag* t_fgcol(uint32_t xrgb)
		{
			if (!t_fgcol_map.contains(xrgb))
			{
				uint8_t r = xrgb>>16;
				uint8_t g = xrgb>>8;
				uint8_t b = xrgb>>0;
				
				GdkRGBA col;
				col.red = r/255.0;
				col.green = g/255.0;
				col.blue = b/255.0;
				col.alpha = 1.0;
				
				GtkTextTag* tag = gtk_text_tag_new(NULL);
				g_object_set(tag, "foreground-rgba", &col, NULL);
				gtk_text_tag_table_add(table, tag);
				
				t_fgcol_map.insert(xrgb, tag);
			}
			return t_fgcol_map.get(xrgb);
		}
		GtkTextTag* t_bgcol(uint32_t xrgb)
		{
			if (!t_bgcol_map.contains(xrgb))
			{
				uint8_t r = xrgb>>16;
				uint8_t g = xrgb>>8;
				uint8_t b = xrgb>>0;
				
				GdkRGBA col;
				col.red = r/255.0;
				col.green = g/255.0;
				col.blue = b/255.0;
				col.alpha = 1.0;
				
				GtkTextTag* tag = gtk_text_tag_new(NULL);
				g_object_set(tag, "background-rgba", &col, NULL);
				gtk_text_tag_table_add(table, tag);
				
				t_bgcol_map.insert(xrgb, tag);
			}
			return t_bgcol_map.get(xrgb);
		}
		
		tags_t()
		{
			table = gtk_text_tag_table_new();
			t_message = NULL;
		}
		void init(GtkWidget* widget) // not in constructor because needs a widget to grab text size
		{
#define TAG(var, ...) \
			do { \
				var = gtk_text_tag_new(NULL); \
				g_object_set(var, __VA_ARGS__, NULL); \
				gtk_text_tag_table_add(table, var); \
			} while(0)
#define TAG0(var) \
			do { \
				var = gtk_text_tag_new(NULL); \
				gtk_text_tag_table_add(table, var); \
			} while(0)
			
			GdkRGBA c_blue = { 0/255.0, 0/255.0, 255/255.0, 1.0 };
			TAG(t_hyperlink, "underline", PANGO_UNDERLINE_SINGLE, "foreground-rgba", &c_blue);
			
			//Spaghetticode(tm)
			//does Gtk really need this many nested objects?
			const PangoFontDescription * fontdesc;
			GdkRGBA c_fg = {}; // GTK_STYLE_PROPERTY_COLOR doesn't seem gettable...? Probably unset, which should be treated as zero.
			gtk_style_context_get(gtk_widget_get_style_context(widget),
			                      GTK_STATE_FLAG_NORMAL,
			                      GTK_STYLE_PROPERTY_FONT, &fontdesc,
			                      GTK_STYLE_PROPERTY_COLOR, &c_fg,
			                      NULL);
			
			PangoFontMetrics* fontmet =
				pango_context_get_metrics(gtk_widget_get_pango_context(widget),
					fontdesc, pango_language_from_string("en-us"));
			
			line_height = PANGO_PIXELS(pango_font_metrics_get_ascent(fontmet) + pango_font_metrics_get_descent(fontmet));
			TAG(t_img, "rise", -pango_font_metrics_get_descent(fontmet));
			
			pango_font_metrics_unref(fontmet);
			
			// gtk docs say the tag added to the GtkTextTagTable last wins if two set the same tag,
			// but this one wins over oldmessage no matter which is first, not sure what's going on
			TAG(t_imgalt, "scale", (gdouble)0.0);
			
			//three guesses whether negative indent is documented anywhere other than pango_layout_set_indent()
			//eight guesses how I got the idea of looking there
			TAG(t_message, "indent", (gint)-INDENT_WRAP);
			TAG(t_oldmessage, "scale", (gdouble)0.75);
			
			TAG(t_bold, "weight", PANGO_WEIGHT_BOLD);
			TAG(t_underline, "underline", PANGO_UNDERLINE_SINGLE);
			TAG(t_italics, "style", PANGO_STYLE_ITALIC);
			TAG(t_strike, "strikethrough", true);
			
			TAG(t_ilink_target, "invisible", true);
			
			c_fg.alpha = 0.125;
			TAG(t_monospace, "family", "monospace", "background-rgba", &c_fg);
		#undef TAG
			
			//https://developer.gnome.org/gdk3/stable/gdk3-Cursors.html#GdkCursorType
			//"The recommended way to create cursors is to use gdk_cursor_new_from_name()"
			//except that just returns null for some weird reason.
			c_hyperlink = gdk_cursor_new_for_display(gdk_display_get_default(), GDK_HAND1);
			
			img_indent = gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8, INDENT_NEWLINE, line_height);
			gdk_pixbuf_fill(img_indent, 0x00000000);
			
			img_indent_small = gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8, INDENT_NEWLINE, shrink_size(line_height));
			gdk_pixbuf_fill(img_indent_small, 0x00000000);
		}
		
		static unsigned shrink_size(unsigned in)
		{
			// TODO: figure out if this formula is correct, the only known value is 17->13
			unsigned ret = (unsigned)(in*0.75 + 0.5);
			return ret ? ret : 1;
		}
		
		~tags_t()
		{
			//this isn't really necessary, but it's harmless
			if (t_message)
			{
				for (auto& pair : t_fgcol_map) { g_object_unref(pair.value); }
				for (auto& pair : t_bgcol_map) { g_object_unref(pair.value); }
				
				g_object_unref(t_message);
				g_object_unref(t_oldmessage);
				g_object_unref(t_img);
				g_object_unref(t_imgalt);
				
				g_object_unref(t_bold);
				g_object_unref(t_underline);
				g_object_unref(t_italics);
				g_object_unref(t_strike);
				g_object_unref(t_monospace);
				g_object_unref(t_hyperlink);
				g_object_unref(t_ilink_target);
				
				g_object_unref(c_hyperlink);
				
				g_object_unref(img_indent);
				g_object_unref(img_indent_small);
			}
			
			g_object_unref(table);
		}
	};
	
	//I don't like global variables, but the alternative is passing around textview pointers in messy ways.
	//It's forcibly single-threaded, constant post-initialization, and always used in a correct run of the program,
	// which covers all complaints except 'global variable bad because global variable bad'.
	//('Correct run' excludes bad config with no protocols installed.)
	static tags_t g_tags;
}

//Gtk somehow likes to calculate wrong scroll position. It seems to not know the correct size right away.
//(To demonstrate, remove scroll_to_last_read from onscroll().)
//To delete that nonsense, I catch the 'changed' signal on the scrollbar. If it resizes such that
// the scroll position is no longer at the bottom, scroll back to the bottom.
//
//And it has some strange 'kinetic' scroll animation. Luckily, it can be disabled - though
// I didn't find that without writing some really nasty workaround first...
//
//and some part of that is buggy; sometimes it hops to the top of the buffer, sometimes half of it is rendered from
// wrong Y coordinate (forcing a redraw, for example click -> focus change -> state-flags-changed signal, fixes it)
//not sure how to fix that one, I can't even reliably reproduce it...

//replacing the GdkPixbufs is also quite nasty

static double scrollbar_max(GtkAdjustment* scroll)
{
	return gtk_adjustment_get_upper(scroll) - gtk_adjustment_get_page_size(scroll);
}

bool textview::scroll_at_bottom()
{
	if (!view) return false;
	
	GtkAdjustment* scroll = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(view));
	double y = gtk_adjustment_get_value(scroll);
	double ymax = scrollbar_max(scroll);
	
	return (y >= ymax-1); // -1 to allow rounding errors
}

void textview::onscroll(bool allow_leave)
{
	bool new_at_bottom = scroll_at_bottom();
	if (at_bottom && !new_at_bottom && !allow_leave)
	{
		at_bottom = true;
		scroll_to_last_read();
	}
	else at_bottom = new_at_bottom;
	
	if (onscroll_cb)
	{
		onscroll_cb(scroll_at_bottom());
	}
}


//a selection bound may not lie between a GdkPixbuf and the alt-text tag, or inside the tag
// if it does, it must be put on the far side of the image
//since the alt-text tag always lies to the right of the image, this simplifies to
// 'if a selection bound points inside, or to the start of, an alt-ext tag, move it to the end of said tag'
//which further simplifies to 'if the pointed-to character is inside the tag, move to after the tag end'
static GtkTextIter imgalt_get_iter(GtkTextBuffer* buf,
                                   GtkTextMark* mark,
                                   bool* do_move)
{
	GtkTextIter ret;
	gtk_text_buffer_get_iter_at_mark(buf, &ret, mark);
	if (gtk_text_iter_has_tag(&ret, g_tags.t_imgalt))
	{
		*do_move = true;
		gtk_text_iter_forward_to_tag_toggle(&ret, g_tags.t_imgalt);
	}
	
	//with my spacing images, possible cursor positions are
	// abc*<lf>*<img>*def
	//with corresponding mouse positions with word wrap, gtk puts cursor at first one for all three options
	//but I'd rather leave the third position available, so text can be copied without adding an extra linebreak
	//second is pointless, it should redirect to third
	//-> if cursor is on the image, one char forward
	if (gtk_text_iter_get_pixbuf(&ret) == g_tags.img_indent)
	{
		*do_move = true;
		gtk_text_iter_forward_char(&ret);
	}
	//it's impossible for both of those to be true simultaneously, in either order
	return ret;
}

static void imgalt_update(GtkTextBuffer* buf)
{
	bool do_move = false;
	GtkTextIter insert = imgalt_get_iter(buf, gtk_text_buffer_get_insert(         buf), &do_move);
	GtkTextIter sbound = imgalt_get_iter(buf, gtk_text_buffer_get_selection_bound(buf), &do_move);
	
	if (do_move)
	{
		gtk_text_buffer_select_range(buf, &insert, &sbound);
	}
}

static void imgalt_cb(GObject* gobject, GParamSpec* pspec, void* user_data)
{
	imgalt_update(GTK_TEXT_BUFFER(gobject));
}

textview::textview()
{
	view = NULL;
	this->buf = gtk_text_buffer_new(g_tags.table);
	
	GtkTextIter end;
	gtk_text_buffer_get_end_iter(buf, &end);
	this->lastread = gtk_text_buffer_create_mark(buf, "lastRead", &end, true);
	
	GtkTextIter start;
	gtk_text_buffer_get_end_iter(buf, &start);
	this->mouse_pos = gtk_text_buffer_create_mark(buf, "mousePos", &start, true);
	
	if (!g_tags.t_message)
	{
		gtkwidget(); // create it, taglist needs a widget. this one's gonna be focused immediately anyways
		g_tags.init(GTK_WIDGET(view));
	}
	
	//this doesn't do anything if selection-bound moves without cursor moving, but as far as I've seen,
	// user can't move it to any place other than 'right where main cursor is' which is caught
	//(okay, code can move it, but it won't.)
	
	//the cursor itself is invisible, but selecting text isn't; also affects copypaste
	g_signal_connect(buf, "notify::cursor-position", G_CALLBACK(imgalt_cb), NULL);
//gtkwidget();
gtk_text_mark_set_visible(this->lastread, true);
}

GtkWidget* textview::gtkwidget()
{
	if (view) return GTK_WIDGET(scrollview);
	
	view = GTK_TEXT_VIEW(gtk_text_view_new_with_buffer(buf));
	gtk_text_view_set_wrap_mode(view, GTK_WRAP_WORD_CHAR);
	
	//known bugs if not readonly:
	//- backspacing images removes the alt-text, one character at the time
	//- left arrow has no effect if beside an image, you end up back where you started
	//no known bugs in mouse selection, or if otherwise readonly
	gtk_text_view_set_editable(view, false);
	gtk_text_view_set_cursor_visible(view, false);
	
	scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	//I'd rather have NEVER than EXTERNAL, but that makes the textview refuse to
	// shrink if that would change word wrapping
	gtk_scrolled_window_set_policy(scrollview, GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(view));
	
	gtk_text_view_set_top_margin(view, 1440);
	
	GtkAdjustment* scrollbar = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(view));
	void(*scrollval_cb)(GtkAdjustment* adjustment, void* user_data) =
	                 [](GtkAdjustment* adjustment, void* user_data)
	{
		((textview*)user_data)->onscroll(true);
	};
	void(*scrolled_cb)(GtkAdjustment* adjustment, void* user_data) =
	                [](GtkAdjustment* adjustment, void* user_data)
	{
		((textview*)user_data)->onscroll(false);
	};
	g_signal_connect(scrollbar, "value-changed", G_CALLBACK(scrollval_cb), this);
	g_signal_connect(scrollbar, "changed", G_CALLBACK(scrolled_cb), this);
	
	gboolean(*view_event_wrap)(GtkWidget* widget, GdkEvent* event, void* user_data) =
	                             [](GtkWidget* widget, GdkEvent* event, void* user_data) -> gboolean
	{
		return ((textview*)user_data)->view_event(widget, event);
	};
	//don't put this event on the tag, we need to unset the cursor if mouse is no longer on a link
	//also the given GtkTextIter is off by half a character; it points to where cursor would end up if mouse is clicked,
	//  not the actual pointed-to character
	g_signal_connect(view, "event", G_CALLBACK(view_event_wrap), this);
	
	void(*reset_cursor)(GtkWidget* widget, GtkStateFlags flags, void* user_data) =
	                 [](GtkWidget* widget, GtkStateFlags flags, void* user_data)
	{
		textview* this_ = (textview*)user_data;
		GdkWindow* wnd = gtk_text_view_get_window(this_->view, GTK_TEXT_WINDOW_TEXT);
		// this is NULL if state flags change before the object is realized
		// for example the gtk_widget_set_sensitive hack in main.cpp, but others wouldn't be obviously impossible
		if (!wnd) return;
		if (this_->mouse_on_link)
			gdk_window_set_cursor(wnd, g_tags.c_hyperlink);
		else
			gdk_window_set_cursor(wnd, NULL);
	};
	g_signal_connect(view, "state-flags-changed", G_CALLBACK(reset_cursor), this);
	
	gboolean(*populate_menu)(GtkTextView* text_view, GtkWidget* popup, void* user_data) =
	                      [](GtkTextView* text_view, GtkWidget* popup, void* user_data) -> gboolean
	{
		return ((textview*)user_data)->populate_menu(text_view, popup);
	};
	g_signal_connect(view, "populate-popup", G_CALLBACK(populate_menu), this);
	scroll_to_last_read();
	
	gtk_widget_set_name(GTK_WIDGET(view), "textview");
	
	return GTK_WIDGET(scrollview);
}


//Undefined behavior if t_hyperlink is not set at the pointed-to character. g_free() the return value when you're done.
//If t_ilink_target is non-NULL and set on the text immediately before the hyperlink, that tag's text is returned instead.
//If used_ilink is non-NULL and t_ilink_target was used, it will be set to true.
// If not used, will remain unchanged; caller should initialize it to false.
static char* link_from_iter(GtkTextIter* iter, GtkTextTag* t_hyperlink, GtkTextTag* t_ilink_target, bool* used_ilink)
{
	GtkTextIter begin = *iter;
	if (!gtk_text_iter_starts_tag(&begin, t_hyperlink))
		gtk_text_iter_backward_to_tag_toggle(&begin, t_hyperlink);
	if (t_ilink_target && gtk_text_iter_ends_tag(&begin, t_ilink_target))
	{
		if (used_ilink) *used_ilink = true;
		gtk_text_iter_backward_to_tag_toggle(&begin, t_ilink_target);
		t_hyperlink = t_ilink_target;
	}
	GtkTextIter end = begin;
	if (!gtk_text_iter_ends_tag(&end, t_hyperlink))
		gtk_text_iter_forward_to_tag_toggle(&end, t_hyperlink);
	
	gchar* text = gtk_text_iter_get_text(&begin, &end);
	return text;
}

bool textview::view_event(GtkWidget* widget, GdkEvent* event)
{
	gint x;
	gint y;
	if (event->type == GDK_MOTION_NOTIFY)
	{
		x = event->motion.x;
		y = event->motion.y;
	}
	else if (event->type == GDK_BUTTON_PRESS || event->type == GDK_BUTTON_RELEASE)
	{
		x = event->button.x;
		y = event->button.y;
	}
	else return GDK_EVENT_PROPAGATE;
	
	gtk_text_view_window_to_buffer_coords(view, GTK_TEXT_WINDOW_TEXT, x, y, &x, &y);
	
	GtkTextIter active_char;
	mouse_on_char = gtk_text_view_get_iter_at_position(this->view, &active_char, NULL, x, y);
	gtk_text_buffer_move_mark(buf, mouse_pos, &active_char);
	
	if (!mouse_on_char) goto cur_default;
	
	if (gtk_text_iter_has_tag(&active_char, g_tags.t_hyperlink))
	{
		if (event->type == GDK_BUTTON_PRESS && event->button.button == 1) link_click = true;
		else if (event->type == GDK_BUTTON_RELEASE && event->button.button == 1 && link_click)
		{
			bool is_ilink = false;
			gchar* text = link_from_iter(&active_char, g_tags.t_hyperlink, g_tags.t_ilink_target, &is_ilink);
			if (is_ilink)
			{
				ilink_cb(string::create_usurp(text));
			}
			else
			{
				GtkWindow* parent = GTK_WINDOW(gtk_widget_get_toplevel(widget)); // clicked = in a window = toplevel is a window
				gtk_show_uri_on_window(parent, text, event->button.time, NULL);
				g_free(text);
			}
		}
		else link_click = false;
		
		goto cur_link;
	}
	else link_click = false;
	
cur_default:
	mouse_on_link = false;
	gdk_window_set_cursor(gtk_text_view_get_window(this->view, GTK_TEXT_WINDOW_TEXT), NULL);
	return GDK_EVENT_PROPAGATE;
	
cur_link:
	mouse_on_link = true;
	gdk_window_set_cursor(gtk_text_view_get_window(this->view, GTK_TEXT_WINDOW_TEXT), g_tags.c_hyperlink);
	return GDK_EVENT_PROPAGATE;
}


bool textview::populate_menu(GtkTextView* text_view, GtkWidget* popup)
{
	if (!GTK_IS_MENU_SHELL(popup)) return GDK_EVENT_PROPAGATE;
	
	gtk_container_foreach(GTK_CONTAINER(popup), (GtkCallback)gtk_widget_destroy, NULL);
	
	GtkTextIter it;
	gtk_text_buffer_get_iter_at_mark(buf, &it, mouse_pos);
	
	ctxmenu_actions.reset();
	
	if (gtk_text_buffer_get_selection_bounds(buf, NULL, NULL))
	{
		ctxmenu_actions.append({ "_Copy", [this](){
				gtk_text_buffer_copy_clipboard(this->buf, gtk_clipboard_get(GDK_SELECTION_CLIPBOARD));
			} });
	}
	else
	{
		ctxmenu_actions.append({ "_Copy", NULL });
	}
	
	if (mouse_on_link)
	{
		string link_target = string::create_usurp(link_from_iter(&it, g_tags.t_hyperlink, NULL, NULL));
		
		if (link_target.startswith("http://") || link_target.startswith("https://"))
		{
			ctxmenu_actions.append({ link_target, NULL });
			
			ctxmenu_actions.append({ "Open Link in Browser", [this, link_target](){
					g_app_info_launch_default_for_uri(link_target, NULL, NULL);
				} });
			
			ctxmenu_actions.append({ "Copy Selected Link", [this, link_target](){
					clipboard_set_text(link_target);
				} });
		}
	}
	
	const char * msgname = "";
	
	if (!gtk_text_iter_starts_tag(&it, g_tags.t_message))
		gtk_text_iter_backward_to_tag_toggle(&it, g_tags.t_message);
	GSList* marks = gtk_text_iter_get_marks(&it);
	GSList* mark_iter = marks;
	while (mark_iter)
	{
		const char * thisname = gtk_text_mark_get_name(GTK_TEXT_MARK(mark_iter->data));
		// gtk itself creates a few anonymous marks
		if (thisname && thisname[0] == '$') msgname = thisname+1;
		mark_iter = mark_iter->next;
	}
	g_slist_free(marks);
	
	onctxmenu_cb(ctxmenu_actions, msgname);
	
	for (ctxaction& act : ctxmenu_actions)
	{
		GtkWidget* item;
		if (act.text.length() < 50)
			item = gtk_menu_item_new_with_mnemonic(act.text);
		else
			item = gtk_menu_item_new_with_mnemonic(act.text.substr(0, 40)+"...");
		if (act.action)
		{
			auto [ b, fn, ctx ] = act.action.try_decompose();
			g_signal_connect_swapped(item, "activate", G_CALLBACK(fn), ctx);
		}
		else
		{
			gtk_widget_set_sensitive(item, false);
		}
		gtk_menu_shell_append(GTK_MENU_SHELL(popup), item);
		gtk_widget_show(item);
	}
	
	return GDK_EVENT_PROPAGATE;
}

void textview::clipboard_set_text(cstring text)
{
	gtk_clipboard_set_text(gtk_clipboard_get(GDK_SELECTION_CLIPBOARD), (char*)text.bytes().ptr(), text.length());
}


textview::image* textview::image::create(arrayview<uint8_t> bytes, size_t width, size_t height)
{
	GInputStream* is = g_memory_input_stream_new_from_data(bytes.ptr(), bytes.size(), NULL);
	GdkPixbuf* pix = gdk_pixbuf_new_from_stream_at_scale(is, width, height, true, NULL, NULL);
	g_object_unref(is);
	if (pix)
		return new image(pix);
	else
		return NULL;
}

textview::image* textview::image::blank(size_t width, size_t height)
{
	GdkPixbuf* pix = gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8, width, height);
	gdk_pixbuf_fill(pix, 0x00000000);
	return new image(pix);
}

textview::image::~image()
{
	g_object_unref(pix);
}


void textview::scrollback(cstring text)
{
	GtkTextIter iter;
	gtk_text_buffer_get_end_iter(buf, &iter);
	gtk_text_buffer_insert(buf, &iter, text.c_str(), text.length()-1); // -1 to drop the final \n
	gtk_text_buffer_move_mark(this->buf, this->lastread, &iter);
	
	GtkTextIter start;
	gtk_text_buffer_get_start_iter(buf, &start);
	gtk_text_buffer_apply_tag(buf, g_tags.t_message, &start, &iter);
}


void textview::scroll_to_last_read()
{
	bool prev_kinetic = gtk_scrolled_window_get_kinetic_scrolling(scrollview);
	gtk_scrolled_window_set_kinetic_scrolling(scrollview, false);
	//put mark to the top right rather than the obvious top left; GTK_WRAP_WORD_CHAR says there should be no scrollbars (unless
	// some single char is wider than viewport), but there's some Gtk bug nearby with large numbers of
	// consecutive punctuation marks (present in Gtk 3.10, fixed in GTK 3.22)
	//I could ifdef the workaround, but there's no reason. The bug will resurface if I start embedding images,
	// and the workaround has exactly zero cost.
	gtk_text_view_scroll_to_mark(view, lastread, 0.0, true, 1.0, 0.0);
	gtk_scrolled_window_set_kinetic_scrolling(scrollview, prev_kinetic);
}

void textview::move_last_read()
{
	if (!view) return;
	
	GtkTextIter iter;
	if (scroll_at_bottom())
		gtk_text_buffer_get_end_iter(buf, &iter);
	else
		gtk_text_view_get_line_at_y(view, &iter, gtk_adjustment_get_value(gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(view))), NULL);
	gtk_text_buffer_move_mark(buf, lastread, &iter);
}

void textview::message_insert_at(GtkTextIter* iter, arrayview<span> spans)
{
	for (size_t i=0;i<spans.size();i++)
	{
		if (spans[i].i_link)
		{
			const string& text = spans[i].text;
			if (spans[i].hidden) i++;
			
			if (LIKELY(g_utf8_validate(text, text.length(), NULL)))
			{
				gtk_text_buffer_insert_with_tags(buf, iter, text, text.length(), g_tags.t_ilink_target, NULL);
			}
			else
			{
				debug_warn("textview: utf8 error\n");
				gtk_text_buffer_insert(buf, iter, "<UTF8 ERROR>", -1);
				string sanitized = string::create_usurp(g_utf8_make_valid(text, text.length()));
				gtk_text_buffer_insert_with_tags(buf, iter, sanitized, sanitized.length(), g_tags.t_ilink_target, NULL);
			}
		}
		
		const span& sp = spans[i];
		if (sp.img)
		{
			gtk_text_buffer_insert_pixbuf(buf, iter, sp.img->pix);
			GtkTextIter start = *iter;
			gtk_text_iter_backward_char(&start);
			gtk_text_buffer_apply_tag(buf, g_tags.t_img, &start, iter);
		}
		
		size_t start_offset = gtk_text_iter_get_offset(iter);
		if (LIKELY(g_utf8_validate(sp.text, sp.text.length(), NULL)))
		{
			gtk_text_buffer_insert(buf, iter, sp.text, sp.text.length());
		}
		else
		{
			debug_warn("textview: utf8 error\n");
			string sanitized = (cstring)"<UTF8 ERROR>" + g_utf8_make_valid(sp.text, sp.text.length());
			gtk_text_buffer_insert(buf, iter, sanitized, sanitized.length());
		}
		
		GtkTextIter start;
		gtk_text_buffer_get_iter_at_offset(buf, &start, start_offset);
		if (sp.img)
		{
			gtk_text_buffer_apply_tag(buf, g_tags.t_imgalt, &start, iter);
			gtk_text_buffer_get_iter_at_offset(buf, &start, start_offset-1); // t_message and t_bgcol should be applied to the image too
		}
		gtk_text_buffer_apply_tag(buf, g_tags.t_message, &start, iter);
		
		if (sp.bold) gtk_text_buffer_apply_tag(buf, g_tags.t_bold, &start, iter);
		if (sp.underline) gtk_text_buffer_apply_tag(buf, g_tags.t_underline, &start, iter);
		if (sp.italics) gtk_text_buffer_apply_tag(buf, g_tags.t_italics, &start, iter);
		if (sp.strike) gtk_text_buffer_apply_tag(buf, g_tags.t_strike, &start, iter);
		if (sp.monospace) gtk_text_buffer_apply_tag(buf, g_tags.t_monospace, &start, iter);
		
		// don't apply both fgcol and hyperlink; fgcol is added to the tag table later, so it'd win, but we'd prefer if hyperlink wins
		// except for spoilers, which should have both (fgcol, being created dynamically, is newer and wins)
		if (sp.hyperlink || sp.i_link)
			gtk_text_buffer_apply_tag(buf, g_tags.t_hyperlink, &start, iter);
		if ((!(sp.hyperlink || sp.i_link) || sp.is_spoiler()) && sp.fgcol != (uint32_t)-1)
			gtk_text_buffer_apply_tag(buf, g_tags.t_fgcol(sp.fgcol), &start, iter);
		
		if (sp.bgcol != (uint32_t)-1)
			gtk_text_buffer_apply_tag(buf, g_tags.t_bgcol(sp.bgcol), &start, iter);
		
		if (sp.text.contains("\n"))
		{
			while (!gtk_text_iter_equal(&start, iter))
			{
				//this is almost gtk_text_iter_forward_find_char, but that one is left-exclusive, right-inclusive,
				// and takes no significant performance shortcuts, so it's easier to reinvent it
				if (gtk_text_iter_get_char(&start) == '\n')
				{
					gtk_text_iter_forward_char(&start);
					
					size_t end_offset = gtk_text_iter_get_offset(iter);
					gtk_text_buffer_insert_pixbuf(buf, &start, g_tags.img_indent);
					// +1 because insertion shifting everything
					gtk_text_buffer_get_iter_at_offset(buf, iter, end_offset+1);
					
					GtkTextIter imgbefore = start;
					gtk_text_iter_backward_char(&imgbefore);
					gtk_text_buffer_apply_tag(buf, g_tags.t_message, &imgbefore, &start);
					gtk_text_buffer_apply_tag(buf, g_tags.t_img,     &imgbefore, &start);
					
					//if I want same tags as previous char (replace_image), they disappear; if I'd rather have text untagged (here), they stay?
					//what are the exact rules for tag inheritance on fresh text, and what's the probability they'll cause even bigger bugs somewhere?
					if (sp.monospace) gtk_text_buffer_remove_tag(buf, g_tags.t_monospace, &imgbefore, &start);
					if (sp.bgcol != (uint32_t)-1)
						gtk_text_buffer_remove_tag(buf, g_tags.t_bgcol(sp.bgcol), &imgbefore, &start);
				}
				else gtk_text_iter_forward_char(&start);
			}
		}
	}
	//no protection is needed against U+202E RIGHT-TO-LEFT OVERRIDE, GTK+ automatically terminates its effect on linebreak
}

void textview::message_at(cstring prev, bool after, cstring newid, arrayview<span> spans, bool mark_read)
{
	g_object_freeze_notify(buf);
	bool to_bottom = scroll_at_bottom();
	
	GtkTextIter iter;
	
	if (prev)
	{
		//gtk has builtin marks 'insert' and 'selection_bound', namespace ourselves so gtk goes away
		//also to allow the lastRead mark to not collide with anything
		GtkTextMark* prevmark = gtk_text_buffer_get_mark(buf, "$"+prev);
		gtk_text_buffer_get_iter_at_mark(buf, &iter, prevmark);
		
		if (after)
		{
			if (mark_read)
			{
				GtkTextIter lastread_iter;
				gtk_text_buffer_get_iter_at_mark(buf, &lastread_iter, this->lastread);
				mark_read = (gtk_text_iter_equal(&iter, &lastread_iter));
			}
			
			gtk_text_iter_forward_to_tag_toggle(&iter, g_tags.t_message);
		}
		else
		{
			mark_read = false; // inserting before a message will put lastRead after it, as appropriate; nothing to do
			gtk_text_iter_backward_char(&iter);
		}
	}
	else
	{
		gtk_text_buffer_get_end_iter(buf, &iter);
		
		if (mark_read)
		{
			GtkTextIter lastread_iter;
			gtk_text_buffer_get_iter_at_mark(buf, &lastread_iter, this->lastread);
			mark_read = (gtk_text_iter_equal(&iter, &lastread_iter));
		}
	}
	gtk_text_buffer_insert(buf, &iter, "\n", -1);
	
	if (newid)
	{
		gtk_text_buffer_create_mark(buf, "$"+newid, &iter, true);
	}
	
	message_insert_at(&iter, spans);
	
	if (mark_read)
	{
		gtk_text_iter_forward_char(&iter); // does nothing on end iterator; if not end, goes to the next line
		gtk_text_buffer_move_mark(buf, this->lastread, &iter);
	}
	
	if (to_bottom)
		scroll_to_last_read();
	
	g_object_thaw_notify(buf);
}

bool textview::message_exists(cstring id)
{
	return gtk_text_buffer_get_mark(buf, "$"+id) != NULL;
}

void textview::message_edit_visible(cstring id, arrayview<span> spans)
{
	g_object_freeze_notify(buf);
	bool to_bottom = scroll_at_bottom();
	
	GtkTextIter iter;
	
	//gtk has builtin marks 'insert' and 'selection_bound', namespace ourselves so gtk goes away
	string idReal = "$"+id;
	
	GtkTextMark* mark = gtk_text_buffer_get_mark(buf, idReal);
	gtk_text_buffer_get_iter_at_mark(buf, &iter, mark);
	GtkTextIter iterend = iter;
	gtk_text_iter_forward_to_tag_toggle(&iterend, g_tags.t_message);
	
	int x = gtk_text_iter_get_offset(&iterend);
	if (spans.size())
	{
		gtk_text_buffer_insert(buf, &iterend, "\n", -1);
		message_insert_at(&iterend, spans);
	}
	gtk_text_iter_set_offset(&iterend, x + (bool)spans.size());
	gtk_text_buffer_get_iter_at_mark(buf, &iter, mark);
	
	// iter - start of the message
	// iterend - just after \n on the now-old message, or after its end if the message is being deleted
	
	if (gtk_text_iter_has_tag(&iter, g_tags.t_oldmessage)) // forward so images aren't shrunk twice
		gtk_text_iter_forward_to_tag_toggle(&iter, g_tags.t_oldmessage);
	gtk_text_buffer_apply_tag(buf, g_tags.t_oldmessage, &iter, &iterend);
	//treat new and old messages as a single message, with a \n in the middle
	gtk_text_buffer_apply_tag(buf, g_tags.t_message, &iter, &iterend);
	
	message_replace_image(&iter, &iterend, bind_this(&textview::shrink_image));
	
	g_object_thaw_notify(buf);
	
	if (to_bottom)
		scroll_to_last_read();
}
GdkPixbuf* textview::shrink_image(GdkPixbuf* prev)
{
	if (prev == g_tags.img_indent) // hardcode this one, to avoid some pointless duplication
		return g_tags.img_indent_small;
	return gdk_pixbuf_scale_simple(prev,
	                               tags_t::shrink_size(gdk_pixbuf_get_width(prev)),
	                               tags_t::shrink_size(gdk_pixbuf_get_height(prev)),
	                               GDK_INTERP_BILINEAR);
}


void textview::message_replace(cstring id, arrayview<span> spans)
{
	g_object_freeze_notify(buf);
	
	GtkTextIter iter;
	
	string idReal = "$"+id;
	
	GtkTextMark* mark = gtk_text_buffer_get_mark(buf, idReal);
	gtk_text_buffer_get_iter_at_mark(buf, &iter, mark);
	GtkTextIter iterend = iter;
	
	gtk_text_iter_forward_to_tag_toggle(&iterend, g_tags.t_message);
	
	gtk_text_buffer_delete(buf, &iter, &iterend);
	message_insert_at(&iter, spans);
	
	g_object_thaw_notify(buf);
}

void textview::message_delete(cstring id)
{
	g_object_freeze_notify(buf);
	
	GtkTextIter iter;
	
	string idReal = "$"+id;
	
	GtkTextMark* mark = gtk_text_buffer_get_mark(buf, idReal);
	gtk_text_buffer_get_iter_at_mark(buf, &iter, mark);
	GtkTextIter iterend = iter;
	
	gtk_text_iter_forward_to_tag_toggle(&iterend, g_tags.t_message);
	
	//the \n after a line isn't guaranteed to exist, but the one before is, and all \n are equal
	//so nuke the previous one instead
	gtk_text_iter_backward_char(&iter);
	gtk_text_buffer_delete(buf, &iter, &iterend);
	gtk_text_buffer_delete_mark(buf, mark);
	
	g_object_thaw_notify(buf);
}

void textview::message_get_bounds(cstring id, GtkTextIter* start, GtkTextIter* end)
{
	string idReal = "$"+id;
	
	GtkTextMark* mark = gtk_text_buffer_get_mark(buf, idReal);
	gtk_text_buffer_get_iter_at_mark(buf, start, mark);
	
	*end = *start;
	gtk_text_iter_forward_to_tag_toggle(end, g_tags.t_message);
}
void textview::message_replace_image(GtkTextIter* start, GtkTextIter* end, function<GdkPixbuf*(GdkPixbuf* prev)> replace)
{
	g_object_freeze_notify(buf);
	
	//all this crap just to replace some images
	array<int> indices;
	array<GdkPixbuf*> replacements;
	
	while (!gtk_text_iter_equal(start, end))
	{
		GdkPixbuf* pix = gtk_text_iter_get_pixbuf(start);
		GdkPixbuf* newpix = pix ? replace(pix) : NULL;
		if (pix != newpix)
		{
			indices.append(gtk_text_iter_get_offset(start));
			replacements.append(newpix);
		}
		gtk_text_iter_forward_char(start);
	}
	
	for (size_t i=0;i<indices.size();i++)
	{
		int index = indices[i];
		GdkPixbuf* pix = replacements[i];
		
		gtk_text_iter_set_offset(start, index);
		GSList* tags = gtk_text_iter_get_tags(start);
		
		*end = *start;
		gtk_text_iter_forward_char(end);
		gtk_text_buffer_delete(buf, start, end);
		
		gtk_text_buffer_insert_pixbuf(buf, end, pix);
		*start = *end;
		gtk_text_iter_backward_char(start);
		
		GSList* tagiter = tags;
		while (tagiter)
		{
			GtkTextTag* tag = (GtkTextTag*)tagiter->data;
			gtk_text_buffer_apply_tag(buf, tag, start, end);
			tagiter = tagiter->next;
		}
		
		g_slist_free(tags);
	}
	
	g_object_thaw_notify(buf);
}
void textview::message_replace_image(cstring id, function<GdkPixbuf*(GdkPixbuf* prev)> replace)
{
	GtkTextIter start;
	GtkTextIter end;
	message_get_bounds(id, &start, &end);
	message_replace_image(&start, &end, replace);
}


unsigned textview::lineheight() { return g_tags.line_height; }

void textview::user_input(int gdk_event_type)
{
	static_assert(GDK_KEY_PRESS == 8); // if not, update this function's default argument in textview.h
	if (gdk_event_type == GDK_MOTION_NOTIFY ||
	    gdk_event_type == GDK_BUTTON_PRESS ||
	    gdk_event_type == GDK_KEY_PRESS ||
	    gdk_event_type == GDK_FOCUS_CHANGE ||
	    gdk_event_type == GDK_SCROLL ||
	    gdk_event_type == GDK_TOUCH_UPDATE)
	{
		move_last_read();
	}
}

void textview::do_scroll(GdkEventKey* event)
{
	gtk_bindings_activate_event(G_OBJECT(this->scrollview), event);
	move_last_read();
}


textview::~textview()
{
	if (view)
		gtk_widget_destroy(GTK_WIDGET(view));
	g_object_unref(buf);
}

bool textview::is_rtl(cstring text)
{
	// deprecated, but no usable alternative offered
	// gtk itself uses fribidi, but libfribidi-dev is not a dependency of libgtk-3-dev, so not usable
	return (pango_find_base_dir((char*)text.bytes().ptr(), text.length()) == PANGO_DIRECTION_RTL);
}
