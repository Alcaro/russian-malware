#include "russian.h"
#include <gtk/gtk.h>

#define DEBUG_TEXTVIEW 1

textview::textview()
{
	tags = gtk_text_tag_table_new();
	view = GTK_TEXT_VIEW(gtk_text_view_new());
	
	gtk_text_view_set_wrap_mode(view, GTK_WRAP_WORD_CHAR);
	
#if !DEBUG_TEXTVIEW
	//known bugs if not readonly:
	//- backspacing images removes the alt-text, one character at the time
	//- left arrow has no effect if beside an image, you end up back where you started
	//no known bugs in mouse selection
	gtk_text_view_set_editable(view, false);
	gtk_text_view_set_cursor_visible(view, false);
#endif
	
	t_imgalt = gtk_text_tag_new("select-only");
#if DEBUG_TEXTVIEW
	g_object_set(t_imgalt, "scale", (gdouble)0.5, NULL);
#else
	g_object_set(t_imgalt, "scale", (gdouble)0, NULL);
#endif
	gtk_text_tag_table_add(tags, t_imgalt);
}

textview::image::image(arrayview<byte> bytes, size_t width, size_t height)
{
	GInputStream* is = g_memory_input_stream_new_from_data(bytes.ptr(), bytes.size(), NULL);
	pix = gdk_pixbuf_new_from_stream_at_scale(is, width, height, true, NULL, NULL);
	g_object_unref(is);
}
textview::image::~image()
{
	g_object_unref(pix);
}

const uint32_t textview::span::colors[16] = {
	//rrggbb
	0xcccccc, 0x000000, 0x3535b3, 0x2a8c2a,
	0xd02a2a, 0x6f2828, 0x80267f, 0xdc721d,
	0xd9a641, 0x3dcc3d, 0x195555, 0x27d6c0,
	0x4545e6, 0xda31da, 0x6c6c6c, 0xafafaf,
};

//a selection bound may not lie between a GdkPixbuf and the alt-text tag, or inside the tag
// if it does, it must be put on the far side of the image
//since the alt-text tag always lies to the right of the image, this simplifies to
// 'if a selection bound points inside, or to the start of, an alt-ext tag, move it to the end of said tag'
//which further simplifies to 'if the pointed-to character is inside the tag, move to after the tag end'
static GtkTextIter imgalt_get_iter(GtkTextBuffer* buf,
																	 GtkTextMark* mark,
																	 GtkTextTag* t_imgalt,
																	 bool* do_move)
{
	GtkTextIter ret;
	gtk_text_buffer_get_iter_at_mark(buf, &ret, mark);
	if (gtk_text_iter_has_tag(&ret, t_imgalt))
	{
		*do_move = true;
		gtk_text_iter_forward_to_tag_toggle(&ret, t_imgalt);
	}
	return ret;
}

static void imgalt_update(GtkTextBuffer* buf, GtkTextTag* t_imgalt)
{
	bool do_move = false;
	GtkTextIter insert = imgalt_get_iter(buf, gtk_text_buffer_get_insert(         buf), t_imgalt, &do_move);
	GtkTextIter sbound = imgalt_get_iter(buf, gtk_text_buffer_get_selection_bound(buf), t_imgalt, &do_move);
	
	if (do_move)
	{
		gtk_text_buffer_select_range(buf, &insert, &sbound);
	}
}

static void imgalt_cb(GObject* gobject, GParamSpec* pspec, gpointer user_data)
{
	imgalt_update(GTK_TEXT_BUFFER(gobject), GTK_TEXT_TAG(user_data));
}

textview::buffer::buffer(textview* parent)
{
	this->parent = parent;
	this->buf = gtk_text_buffer_new(parent->tags);
	//this doesn't do anything if selection-bound moves without cursor moving, but as far as I've seen,
	// user can't move it to any place other than 'right where main cursor is' which is always a valid position
	//(okay, code can move it, but it won't.)
	g_signal_connect(this->buf, "notify::cursor-position", G_CALLBACK(imgalt_cb), parent->t_imgalt);
}

//If 'id' has already been seen, it will be replaced.
//The message may contain linebreaks, but should not end with one unless you actually want that.
void textview::buffer::message(cstring id, time_t at, arrayview<span> spans)
{
	//TODO: care about id/at
	//for id, add a GtkTextMark at end, with left gravity so we can append shit
	
	GtkTextIter iter;
	gtk_text_buffer_get_end_iter(buf, &iter);
	for (size_t i=0;i<spans.size();i++)
	{
		const span& sp = spans[i];
		if (sp.img)
		{
			gtk_text_buffer_insert_pixbuf(buf, &iter, sp.img->pix);
		}
		
		size_t start_offset = gtk_text_iter_get_offset(&iter);
		gtk_text_buffer_insert(buf, &iter, sp.text, sp.text.length());
		
		GtkTextIter start;
		gtk_text_buffer_get_iter_at_offset(buf, &start, start_offset);
		if (sp.img) gtk_text_buffer_apply_tag(buf, parent->t_imgalt, &start, &iter);
		//TODO: check other formats and apply them
	}
	
	gtk_text_buffer_insert(buf, &iter, "\n", 1);
}

textview::buffer::~buffer()
{
	g_object_unref(buf);
}

void textview::set_buf(buffer* buf)
{
	gtk_text_view_set_buffer(view, buf->buf);
}

textview::~textview()
{
	g_object_unref(tags);
	g_object_unref(t_imgalt);
	gtk_widget_destroy(GTK_WIDGET(view));
}
