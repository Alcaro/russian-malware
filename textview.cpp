#ifndef ARGUI_NONE
#include "russian.h"
#include <gtk/gtk.h>

#if !GTK_CHECK_VERSION(3,16,0)
//this is somewhat glitchy (textview works fine, but channel list gets scrollbar), but there's no better option for old gtks
#define GTK_POLICY_EXTERNAL GTK_POLICY_AUTOMATIC
#endif

#if !GTK_CHECK_VERSION(3,20,0)
#define gtk_text_iter_starts_tag gtk_text_iter_begins_tag
#endif

//Gtk somehow likes to calculate wrong scroll position. It seems to not know the correct size right away.
//(To demonstrate, remove scroll_to_last_read from onscroll().)
//To delete that nonsense, I catch the 'changed' signal on the scrollbar. If it resizes such that
// the scroll position is no longer at the bottom, scroll back to the bottom.
//
//And it has some ugly 'kinetic' scroll animation. Luckily, it can be disabled - though
// I didn't find that without writing some really nasty code to work around it...

static double scrollbar_max(GtkAdjustment* scroll)
{
	return gtk_adjustment_get_upper(scroll) - gtk_adjustment_get_page_size(scroll);
}

static bool scrollbar_at_bottom(GtkAdjustment* scroll)
{
	double y = gtk_adjustment_get_value(scroll);
	double ymax = scrollbar_max(scroll);
	
	return (y >= ymax-1); // -1 to allow rounding errors
}

void textview::onscroll(bool allow_leave)
{
	GtkAdjustment* scroll = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(view));
	
	bool new_at_bottom = scrollbar_at_bottom(scroll);
	if (at_bottom && !new_at_bottom && !allow_leave)
	{
		at_bottom = true;
		cur_buf->scroll_to_last_read();
	}
	else at_bottom = new_at_bottom;
}


textview::textview()
{
	cur_buf = NULL;
	
	tags = gtk_text_tag_table_new();
	view = GTK_TEXT_VIEW(gtk_text_view_new());
	gtk_text_view_set_wrap_mode(view, GTK_WRAP_WORD_CHAR);
	
	//known bugs if not readonly:
	//- backspacing images removes the alt-text, one character at the time
	//- left arrow has no effect if beside an image, you end up back where you started
	//no known bugs in mouse selection, or if otherwise readonly
	gtk_text_view_set_editable(view, false);
	gtk_text_view_set_cursor_visible(view, false);
	
#define TAG(var, ...) \
	do { \
		var = gtk_text_tag_new(NULL); \
		g_object_set(var, __VA_ARGS__, NULL); \
		gtk_text_tag_table_add(tags, var); \
	} while(0)
	
	GdkRGBA blue;
	blue.red = 0/255.0;
	blue.green = 0/255.0;
	blue.blue = 255/255.0;
	blue.alpha = 1.0;
	TAG(t_hyperlink, "underline", PANGO_UNDERLINE_SINGLE, "foreground-rgba", &blue);
	
	TAG(t_imgalt, "scale", (gdouble)0.0);
	//three guesses whether negative indent is documented anywhere other than pango_layout_set_indent()
	//eight guesses how I got the idea of looking there
	TAG(t_message, "indent", (gint)-45);
	TAG(t_oldmessage, "scale", (gdouble)0.75);
	
	TAG(t_bold, "weight", PANGO_WEIGHT_BOLD);
	TAG(t_underline, "underline", PANGO_UNDERLINE_SINGLE);
	TAG(t_italics, "style", PANGO_STYLE_ITALIC);
	TAG(t_strike, "strikethrough", true);
#undef TAG
	
	//https://developer.gnome.org/gdk3/stable/gdk3-Cursors.html#GdkCursorType
	//"The recommended way to create cursors is to use gdk_cursor_new_from_name()"
	//except it just returns null, so screw your recommendation
	c_hyperlink = gdk_cursor_new_for_display(gdk_display_get_default(), GDK_HAND1);
	
	scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	//I'd rather have NEVER than EXTERNAL, but that makes textview refuse to
	// shrink if that would change word wrapping
	gtk_scrolled_window_set_policy(scrollview, GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(view));
	
	GtkAdjustment* scrollbar = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(view));
	void(*scrollval_cb)(GtkAdjustment* adjustment, void* user_data) =
	                 [](GtkAdjustment* adjustment, void* user_data)
	{
		((textview*)user_data)->onscroll(true);
	};
	void(*scrolled_cb)(GtkAdjustment* adjustment, void* user_data) =
	                [](GtkAdjustment* adjustment, void* user_data)
	{
		((textview*)user_data)->onscroll(false);
	};
	g_signal_connect(scrollbar, "value-changed", G_CALLBACK(scrollval_cb), this);
	g_signal_connect(scrollbar, "changed", G_CALLBACK(scrolled_cb), this);
	
	gboolean(*hyperlink_event_wrap)(GtkWidget* widget, GdkEvent* event, void* user_data) =
	                             [](GtkWidget* widget, GdkEvent* event, void* user_data) -> gboolean
	{
		return ((textview*)user_data)->hyperlink_event(widget, event);
	};
	//don't put this event on the tag, we need to unset the cursor if mouse is no longer on a link
	//also the given GtkTextIter is off by half a character; it points to where cursor would end up if mouse is clicked,
	//  not the actual pointed-to character
	g_signal_connect(view, "event", G_CALLBACK(hyperlink_event_wrap), this);
	
	gboolean(*populate_menu)(GtkTextView* text_view, GtkWidget* popup, void* user_data) =
	                      [](GtkTextView* text_view, GtkWidget* popup, void* user_data) -> gboolean
	{
		return ((textview*)user_data)->populate_menu(text_view, popup);
	};
	g_signal_connect(view, "populate-popup", G_CALLBACK(populate_menu), this);
}


//Undefined behavior if t_hyperlink is not set at the iterator. g_free() the return value when you're done.
static char* link_from_iter(GtkTextIter* iter, GtkTextTag* t_hyperlink)
{
	GtkTextIter begin = *iter;
	if (!gtk_text_iter_starts_tag(&begin, t_hyperlink)) gtk_text_iter_backward_to_tag_toggle(&begin, t_hyperlink);
	GtkTextIter end = *iter;
	if (!gtk_text_iter_ends_tag(&end, t_hyperlink)) gtk_text_iter_forward_to_tag_toggle(&end, t_hyperlink);
	
	gchar* text = gtk_text_iter_get_text(&begin, &end);
	return text;
}
static char* link_from_offset(GtkTextBuffer* buf, uint32_t offset, GtkTextTag* t_hyperlink)
{
	GtkTextIter iter;
	gtk_text_buffer_get_iter_at_offset(buf, &iter, offset);
	return link_from_iter(&iter, t_hyperlink);
}

bool textview::hyperlink_event(GtkWidget* widget, GdkEvent* event)
{
	gint x;
	gint y;
	if (event->type == GDK_MOTION_NOTIFY)
	{
		x = event->motion.x;
		y = event->motion.y;
	}
	else if (event->type == GDK_BUTTON_PRESS || event->type == GDK_BUTTON_RELEASE)
	{
		x = event->button.x;
		y = event->button.y;
	}
	else return GDK_EVENT_PROPAGATE;
	
	
	gtk_text_view_window_to_buffer_coords(view, GTK_TEXT_WINDOW_TEXT, x, y, &x, &y);
	
	GtkTextIter active_char;
#if GTK_CHECK_VERSION(3,11,0) // don't know when this return value was introduced; it's absent in 3.10 and present in 3.22
	if (!gtk_text_view_get_iter_at_position(this->view, &active_char, NULL, x, y)) goto cur_default;
#else
	gtk_text_view_get_iter_at_position(this->view, &active_char, NULL, x, y);
	GdkRectangle actual;
	gtk_text_view_get_iter_location(this->view, &active_char, &actual);
	if (x < actual.x || y < actual.y || x >= actual.x+actual.width || y >= actual.y+actual.height) goto cur_default;
#endif
	
	
	if (gtk_text_iter_has_tag(&active_char, t_hyperlink))
	{
		if (event->type == GDK_BUTTON_PRESS && event->button.button == 1) link_click = true;
		else if (event->type == GDK_BUTTON_RELEASE && event->button.button == 1 && link_click)
		{
			gchar* text = link_from_iter(&active_char, t_hyperlink);
			g_app_info_launch_default_for_uri(text, NULL, NULL);
			g_free(text);
		}
		else link_click = false;
		
		goto cur_link;
	}
	else link_click = false;
	
	
cur_default:
	link_hover_offset = -1;
	gdk_window_set_cursor(gtk_text_view_get_window(this->view, GTK_TEXT_WINDOW_TEXT), NULL);
	return GDK_EVENT_PROPAGATE;
	
cur_link:
	link_hover_offset = gtk_text_iter_get_offset(&active_char);
	gdk_window_set_cursor(gtk_text_view_get_window(this->view, GTK_TEXT_WINDOW_TEXT), this->c_hyperlink);
	return GDK_EVENT_PROPAGATE;
}


bool textview::populate_menu(GtkTextView* text_view, GtkWidget* popup)
{
	//fairly disgusting, but I can't find a better implementation
	//this widget should never be writable, even having paste/etc items is a waste of time
	void(*cb)(GtkWidget* widget, void* data) =
	       [](GtkWidget* widget, void* data)
	{
		GtkContainer* parent = GTK_CONTAINER(data);
		const char * text = gtk_menu_item_get_label(GTK_MENU_ITEM(widget));
		//could make this compare to g_dgettext("gtk30", "_Copy") instead, if i18n is desired
		//  if this happens, remember to include some static_assert(not gtk4)
		//could also make it remove the Copy, and the separator, if the item is disabled - but that can yield empty, glitchy-looking menues
		//  (in xchat, that yields the main app menu, but that one doesn't exist here)
		//  (oddly enough, separators at the end of the menu don't seem to show up)
		if (!strcmp(text, "_Copy"))
		{
			GtkWidget* item = gtk_separator_menu_item_new();
			gtk_menu_shell_append(GTK_MENU_SHELL(parent), item);
			gtk_widget_show(item);
		}
		else gtk_container_remove(parent, widget);
	};
	gtk_container_foreach(GTK_CONTAINER(popup), cb, popup);
	
	
	if (link_hover_offset != (uint32_t)-1)
	{
		this->link_click_offset = link_hover_offset;
		gchar* text = link_from_offset(cur_buf->buf, this->link_click_offset, t_hyperlink);
		
		void(*menu_cb)(GtkMenuItem* menuitem, void* user_data);
		
		GtkWidget* item = gtk_separator_menu_item_new();
		gtk_menu_shell_append(GTK_MENU_SHELL(popup), item);
		gtk_widget_show(item);
		
		item = gtk_menu_item_new_with_label(text);
		gtk_widget_set_sensitive(item, false);
		gtk_menu_shell_append(GTK_MENU_SHELL(popup), item);
		gtk_widget_show(item);
		
		item = gtk_menu_item_new_with_label("Open Link in Browser");
		menu_cb = [](GtkMenuItem* menuitem, void* user_data)
		{
			return ((textview*)user_data)->menu_open(menuitem);
		};
		g_signal_connect(item, "activate", G_CALLBACK(menu_cb), this);
		gtk_menu_shell_append(GTK_MENU_SHELL(popup), item);
		gtk_widget_show(item);
		
		item = gtk_menu_item_new_with_label("Copy Selected Link");
		menu_cb = [](GtkMenuItem* menuitem, void* user_data)
		{
			return ((textview*)user_data)->menu_copy(menuitem);
		};
		g_signal_connect(item, "activate", G_CALLBACK(menu_cb), this);
		gtk_menu_shell_append(GTK_MENU_SHELL(popup), item);
		gtk_widget_show(item);
		
		g_free(text);
		
		return GDK_EVENT_STOP;
	}
	return GDK_EVENT_PROPAGATE;
}

void textview::menu_open(GtkMenuItem* menuitem)
{
	gchar* text = link_from_offset(cur_buf->buf, this->link_click_offset, t_hyperlink);
	g_app_info_launch_default_for_uri(text, NULL, NULL);
	g_free(text);
}

void textview::menu_copy(GtkMenuItem* menuitem)
{
	gchar* text = link_from_offset(cur_buf->buf, this->link_click_offset, t_hyperlink);
	gtk_clipboard_set_text(gtk_clipboard_get(GDK_SELECTION_CLIPBOARD), text, -1);
	g_free(text);
}


GtkTextTag* textview::t_fgcol(uint32_t xrgb)
{
	if (!t_fgcol_map.contains(xrgb))
	{
		uint8_t r = xrgb>>16;
		uint8_t g = xrgb>>8;
		uint8_t b = xrgb>>0;
		
		GdkRGBA col;
		col.red = r/255.0;
		col.green = g/255.0;
		col.blue = b/255.0;
		col.alpha = 1.0;
		
		GtkTextTag* tag = gtk_text_tag_new(NULL);
		g_object_set(tag, "foreground-rgba", &col, NULL);
		gtk_text_tag_table_add(tags, tag);
		
		t_fgcol_map.insert(xrgb, tag);
	}
	return t_fgcol_map.get(xrgb);
}

GtkTextTag* textview::t_bgcol(uint32_t xrgb)
{
	if (!t_bgcol_map.contains(xrgb))
	{
		uint8_t r = xrgb>>16;
		uint8_t g = xrgb>>8;
		uint8_t b = xrgb>>0;
		
		GdkRGBA col;
		col.red = r/255.0;
		col.green = g/255.0;
		col.blue = b/255.0;
		col.alpha = 1.0;
		
		GtkTextTag* tag = gtk_text_tag_new(NULL);
		g_object_set(tag, "background-rgba", &col, NULL);
		gtk_text_tag_table_add(tags, tag);
		
		t_bgcol_map.insert(xrgb, tag);
	}
	return t_bgcol_map.get(xrgb);
}


textview::image::image(arrayview<byte> bytes, size_t width, size_t height)
{
	GInputStream* is = g_memory_input_stream_new_from_data(bytes.ptr(), bytes.size(), NULL);
	pix = gdk_pixbuf_new_from_stream_at_scale(is, width, height, true, NULL, NULL);
	g_object_unref(is);
}

textview::image::~image()
{
	g_object_unref(pix);
}


//a selection bound may not lie between a GdkPixbuf and the alt-text tag, or inside the tag
// if it does, it must be put on the far side of the image
//since the alt-text tag always lies to the right of the image, this simplifies to
// 'if a selection bound points inside, or to the start of, an alt-ext tag, move it to the end of said tag'
//which further simplifies to 'if the pointed-to character is inside the tag, move to after the tag end'
static GtkTextIter imgalt_get_iter(GtkTextBuffer* buf,
                                   GtkTextMark* mark,
                                   GtkTextTag* t_imgalt,
                                   bool* do_move)
{
	GtkTextIter ret;
	gtk_text_buffer_get_iter_at_mark(buf, &ret, mark);
	if (gtk_text_iter_has_tag(&ret, t_imgalt))
	{
		*do_move = true;
		gtk_text_iter_forward_to_tag_toggle(&ret, t_imgalt);
	}
	return ret;
}

static void imgalt_update(GtkTextBuffer* buf, GtkTextTag* t_imgalt)
{
	bool do_move = false;
	GtkTextIter insert = imgalt_get_iter(buf, gtk_text_buffer_get_insert(         buf), t_imgalt, &do_move);
	GtkTextIter sbound = imgalt_get_iter(buf, gtk_text_buffer_get_selection_bound(buf), t_imgalt, &do_move);
	
	if (do_move)
	{
		gtk_text_buffer_select_range(buf, &insert, &sbound);
	}
}

static void imgalt_cb(GObject* gobject, GParamSpec* pspec, void* user_data)
{
	imgalt_update(GTK_TEXT_BUFFER(gobject), GTK_TEXT_TAG(user_data));
}


textview::buffer::buffer(textview* parent, cstring scrollback)
{
	this->parent = parent;
	this->buf = gtk_text_buffer_new(parent->tags);
	
	GtkTextIter iter;
	gtk_text_buffer_get_end_iter(buf, &iter);
	for (int i=0;i<100;i++)
	{
		gtk_text_buffer_insert(buf, &iter, "\n", -1);
	}
	gtk_text_buffer_insert(buf, &iter, scrollback.c_str(), scrollback.length()-1); // -1 to drop the final \n
	
	//this doesn't do anything if selection-bound moves without cursor moving, but as far as I've seen,
	// user can't move it to any place other than 'right where main cursor is' which is always a valid position
	//(okay, code can move it, but it won't.)
	
	//the cursor itself is invisible, but selecting text isn't
	g_signal_connect(this->buf, "notify::cursor-position", G_CALLBACK(imgalt_cb), parent->t_imgalt);
	
	GtkTextMark* mark = gtk_text_mark_new("lastRead", true);
	gtk_text_buffer_add_mark(buf, mark, &iter);
//gtk_text_mark_set_visible(mark, true); // TODO: remove
}


void textview::buffer::scroll_to_last_read()
{
	if (parent->cur_buf == this)
	{
		bool prev_kinetic = gtk_scrolled_window_get_kinetic_scrolling(parent->scrollview);
		gtk_scrolled_window_set_kinetic_scrolling(parent->scrollview, false);
		GtkTextMark* mark = gtk_text_buffer_get_mark(buf, "lastRead");
		gtk_text_view_scroll_to_mark(parent->view, mark, 0.0, true, 0.0, 0.0);
		gtk_scrolled_window_set_kinetic_scrolling(parent->scrollview, prev_kinetic);
	}
}

void textview::buffer::move_last_read()
{
	if (gtk_text_view_get_buffer(parent->view) == this->buf)
	{
		GtkAdjustment* scroll = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(parent->view));
		GtkTextIter iter;
		if (scrollbar_at_bottom(scroll))
		{
			gtk_text_buffer_get_end_iter(this->buf, &iter);
		}
		else
		{
			gtk_text_view_get_line_at_y(parent->view, &iter, gtk_adjustment_get_value(scroll), NULL);
		}
		gtk_text_buffer_move_mark_by_name(this->buf, "lastRead", &iter);
	}
}


void textview::buffer::message_insert_at(GtkTextIter* iter, arrayview<span> spans)
{
	for (size_t i=0;i<spans.size();i++)
	{
		const span& sp = spans[i];
		if (sp.img)
		{
			gtk_text_buffer_insert_pixbuf(buf, iter, sp.img->pix);
		}
		
		size_t start_offset = gtk_text_iter_get_offset(iter);
		string newtext = sp.text;
		newtext = newtext.replace("\n", "\n               "); // TODO: fiddle with margins instead
		gtk_text_buffer_insert(buf, iter, newtext, newtext.length());
		
		GtkTextIter start;
		gtk_text_buffer_get_iter_at_offset(buf, &start, start_offset);
		if (sp.img)
		{
			gtk_text_buffer_apply_tag(buf, parent->t_imgalt, &start, iter);
			gtk_text_buffer_get_iter_at_offset(buf, &start, start_offset-1); // t_message and t_bgcol should be applied to the image too
		}
		gtk_text_buffer_apply_tag(buf, parent->t_message, &start, iter);
		
		if (sp.bold) gtk_text_buffer_apply_tag(buf, parent->t_bold, &start, iter);
		if (sp.underline) gtk_text_buffer_apply_tag(buf, parent->t_underline, &start, iter);
		if (sp.italics) gtk_text_buffer_apply_tag(buf, parent->t_italics, &start, iter);
		if (sp.strike) gtk_text_buffer_apply_tag(buf, parent->t_strike, &start, iter);
		if (sp.hyperlink) gtk_text_buffer_apply_tag(buf, parent->t_hyperlink, &start, iter);
		
		if (sp.fgcol != (uint32_t)-1)
			gtk_text_buffer_apply_tag(buf, parent->t_fgcol(sp.fgcol), &start, iter);
		if (sp.bgcol != (uint32_t)-1)
			gtk_text_buffer_apply_tag(buf, parent->t_bgcol(sp.bgcol), &start, iter);
	}
}

void textview::buffer::message(cstring id, arrayview<span> spans)
{
	GtkTextIter iter;
	
	GtkTextMark* mark = NULL;
	if (id)
	{
		//gtk has builtin marks 'insert' and 'selection_bound', namespace ourselves so gtk goes away
		//also to allow the lastRead mark to not collide with anything
		string idReal = "$"+id;
		mark = gtk_text_mark_new(idReal, true);
	}
	
	gtk_text_buffer_get_end_iter(buf, &iter);
	gtk_text_buffer_insert(buf, &iter, "\n", -1);
	
	if (mark) gtk_text_buffer_add_mark(buf, mark, &iter);
	
	message_insert_at(&iter, spans);
}

bool textview::buffer::message_exists(cstring id)
{
	return gtk_text_buffer_get_mark(buf, "$"+id) != NULL;
}

void textview::buffer::message_edit_visible(cstring id, arrayview<span> spans)
{
	GtkTextIter iter;
	
	//gtk has builtin marks 'insert' and 'selection_bound', namespace ourselves so gtk goes away
	string idReal = "$"+id;
	
	GtkTextMark* mark = gtk_text_buffer_get_mark(buf, idReal);
	gtk_text_buffer_get_iter_at_mark(buf, &iter, mark);
	GtkTextIter iterend = iter;
	//don't replace with 'go one line forward', messages can be multiline
	gtk_text_iter_forward_to_tag_toggle(&iterend, parent->t_message);
	//iter to iterend is one message, excluding \n
	gtk_text_buffer_insert(buf, &iterend, "\n", -1);
	gtk_text_buffer_get_iter_at_mark(buf, &iter, mark); // addding that \n invalidates the iterator
	gtk_text_buffer_apply_tag(buf, parent->t_oldmessage, &iter, &iterend);
	//treat new and old messages as a single message, with a \n in the middle
	gtk_text_buffer_apply_tag(buf, parent->t_message, &iter, &iterend);
	
	message_insert_at(&iterend, spans);
}

void textview::buffer::message_delete(cstring id)
{
	GtkTextIter iter;
	
	string idReal = "$"+id;
	
	GtkTextMark* mark = gtk_text_buffer_get_mark(buf, idReal);
	if (mark)
	{
		gtk_text_buffer_get_iter_at_mark(buf, &iter, mark);
		GtkTextIter iterend = iter;
		
		//don't replace with 'go one line forward', messages can be multiline
		gtk_text_iter_forward_to_tag_toggle(&iterend, parent->t_message);
		//iter to iterend is one message, excluding \n
		
		//the \n after a line isn't guaranteed to exist, but the one before is, and all \n are equal
		//so nuke the previous one instead
		gtk_text_iter_backward_char(&iter);
		gtk_text_buffer_delete(buf, &iter, &iterend);
		gtk_text_buffer_delete_mark(buf, mark);
	}
}

textview::buffer::~buffer()
{
	g_object_unref(buf);
}


void textview::user_input(int gdk_event_type)
{
	if (gdk_event_type == GDK_MOTION_NOTIFY ||
	    gdk_event_type == GDK_BUTTON_PRESS ||
	    gdk_event_type == GDK_KEY_PRESS ||
	    gdk_event_type == GDK_FOCUS_CHANGE ||
	    gdk_event_type == GDK_SCROLL ||
	    gdk_event_type == GDK_TOUCH_UPDATE)
	{
		cur_buf->move_last_read();
	}
}

void textview::do_scroll(GdkEventKey* event)
{
	gtk_bindings_activate_event(G_OBJECT(this->scrollview), event);
	cur_buf->move_last_read();
}


void textview::set_buf(buffer* buf)
{
	if (cur_buf == buf) return;
	if (cur_buf)
	{
		cur_buf->move_last_read();
	}
	gtk_text_view_set_buffer(view, buf->buf);
	cur_buf = buf;
	buf->scroll_to_last_read();
}


textview::~textview()
{
	for (auto& pair : t_fgcol_map) { g_object_unref(pair.value); }
	for (auto& pair : t_bgcol_map) { g_object_unref(pair.value); }
	
	g_object_unref(t_imgalt);
	g_object_unref(t_message);
	g_object_unref(t_oldmessage);
	
	g_object_unref(t_bold);
	g_object_unref(t_underline);
	g_object_unref(t_italics);
	g_object_unref(t_strike);
	g_object_unref(t_hyperlink);
	
	g_object_unref(c_hyperlink);
	
	g_object_unref(tags);
	gtk_widget_destroy(GTK_WIDGET(view));
}
#endif
