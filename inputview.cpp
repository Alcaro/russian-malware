#ifndef ARGUI_NONE
#include "russian.h"
#include <gtk/gtk.h>

inputview* inputview::create() { return new inputview; }
inputview::inputview()
{
	view = GTK_TEXT_VIEW(gtk_text_view_new());
	gtk_text_view_set_wrap_mode(view, GTK_WRAP_WORD_CHAR);
	
	g_signal_connect(view, "key-press-event", G_CALLBACK(inputview::onkeydown_nat), this);
	//could fiddle with signal "move-cursor" to allow messing with keybindings
	//but on the other hand, this program is designed for exactly one user, who says hardcoding pgup/pgdn is fine
	
	gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_LEFT, 4);
	gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_RIGHT, 4);
	gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_TOP, 4);
	gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_BOTTOM, 4);
	
#if GTK_CHECK_VERSION(3,22,0)
	scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	gtk_scrolled_window_set_policy(scrollview, GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(view));
	
	gtk_scrolled_window_set_propagate_natural_height(scrollview, true);
	gtk_scrolled_window_set_max_content_height(scrollview, 150);
#endif
}
bool inputview::onkeydown_nat(GtkWidget* widget, GdkEventKey* event, void* user_data)
{
	inputview* obj = (inputview*)user_data;
	if (gtk_text_view_im_context_filter_keypress(obj->view, event))
	{
		return GDK_EVENT_STOP;
	}
	
	GdkModifierType mods = (GdkModifierType)(event->state & (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_MOD1_MASK));
	
	if (mods == GDK_CONTROL_MASK)
	{
		const char * add = NULL;
		if (event->keyval == 'b') add = "\x02";
		if (event->keyval == 'k') add = "\x03";
		if (event->keyval == 'u') add = "\x1F";
		if (event->keyval == 'i') add = "\x1D";
		if (event->keyval == 'o') add = "\x0F";
		if (add) { gtk_text_buffer_insert_at_cursor(gtk_text_view_get_buffer(obj->view), add, -1); return GDK_EVENT_STOP; }
	}
	
	if (event->keyval == GDK_KEY_Return)
	{
		GtkTextBuffer* buf = gtk_text_view_get_buffer(obj->view);
		
		gchar* text;
		g_object_get(buf, "text", &text, NULL);
		obj->onactivate(text);
		g_free(text);
		
		gtk_text_buffer_set_text(buf, "", 0);
		
		return GDK_EVENT_STOP;
	}
	if (event->keyval == GDK_KEY_Page_Up || event->keyval == GDK_KEY_Page_Down)
	{
		if (mods == GDK_CONTROL_MASK)
		{
			obj->onswitchfocus((event->keyval == GDK_KEY_Page_Up) ? -1 : 1);
		}
		else
		{
			obj->onscroll(event);
		}
		return GDK_EVENT_STOP;
	}
	return GDK_EVENT_PROPAGATE;
}

void inputview::grab_focus() { gtk_widget_grab_focus(GTK_WIDGET(view)); }

void inputview::store_get(state* st)
{
	gchar* text_raw;
	g_object_get(gtk_text_view_get_buffer(view), "text", &text_raw, NULL);
	st->text = text_raw;
	g_free(text_raw);
	
	gint textpos_raw;
	g_object_get(gtk_text_view_get_buffer(view), "cursor-position", &textpos_raw, NULL);
	st->textpos = textpos_raw;
}
void inputview::store_set(const state* st)
{
	GtkTextBuffer* buf = gtk_text_view_get_buffer(view);
	gtk_text_buffer_set_text(buf, (char*)st->text.bytes().ptr(), st->text.bytes().size());
	
	GtkTextIter iter;
	gtk_text_buffer_get_iter_at_offset(buf, &iter, st->textpos);
	gtk_text_buffer_select_range(buf, &iter, &iter);
}

GtkWidget* inputview::gtkwidget()
{
#if GTK_CHECK_VERSION(3,22,0)
	return (GtkWidget*)scrollview;
#else
	return (GtkWidget*)view;
#endif
}
#endif
