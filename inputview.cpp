#ifndef ARGUI_NONE
#include "russian.h"
#include <gtk/gtk.h>

inputview* inputview::create() { return new inputview; }
inputview::inputview()
{
	view = GTK_TEXT_VIEW(gtk_text_view_new());
	gtk_text_view_set_wrap_mode(view, GTK_WRAP_WORD_CHAR);
	
	gboolean(*onkeydown_nat)(GtkWidget* widget, GdkEventKey* event, void* user_data) =
	                      [](GtkWidget* widget, GdkEventKey* event, void* user_data) -> gboolean
	{
		return ((inputview*)user_data)->onkeydown(widget, event);
	};
	g_signal_connect(view, "key-press-event", G_CALLBACK(onkeydown_nat), this);
	//could fiddle with signal "move-cursor" to allow messing with keybindings
	//but on the other hand, this program is designed for exactly one user, who says hardcoding pgup/pgdn is fine
	
	gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_LEFT, 4);
	gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_RIGHT, 4);
	gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_TOP, 4);
	gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_BOTTOM, 4);
	
#if GTK_CHECK_VERSION(3,22,0)
	scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
	gtk_scrolled_window_set_policy(scrollview, GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
	gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(view));
	
	gtk_scrolled_window_set_propagate_natural_height(scrollview, true);
	gtk_scrolled_window_set_max_content_height(scrollview, 150);
#endif
}
bool inputview::onkeydown(GtkWidget* widget, GdkEventKey* event)
{
	if (gtk_text_view_im_context_filter_keypress(this->view, event))
	{
		return GDK_EVENT_STOP;
	}
	
	if (event->keyval == GDK_KEY_Up || event->keyval == GDK_KEY_Down)
	{
		GtkTextBuffer* buf = gtk_text_view_get_buffer(this->view);
		
		if (event->keyval == GDK_KEY_Up)
		{
			if (this->scrollbackpos == -1 && gtk_text_buffer_get_char_count(buf) != 0)
				return GDK_EVENT_PROPAGATE;
			if (this->scrollbackpos == (int)(this->scrollback.size()-1))
				return GDK_EVENT_STOP;
			else
				this->scrollbackpos++;
		}
		else
		{
			if (this->scrollbackpos == -1)
				return GDK_EVENT_PROPAGATE;
			this->scrollbackpos--;
		}
		
		if (this->scrollbackpos == -1)
		{
			gtk_text_buffer_set_text(buf, "", 0);
		}
		else
		{
			string& newtext = this->scrollback[this->scrollbackpos];
			gtk_text_buffer_set_text(buf, newtext, newtext.length());
		}
		
		return GDK_EVENT_STOP;
	}
	else
	{
		this->scrollbackpos = -1;
	}
	
	GdkModifierType mods = (GdkModifierType)(event->state & (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_MOD1_MASK));
	
	if (mods == GDK_CONTROL_MASK)
	{
		const char * add = NULL;
		if (event->keyval == 'b') add = "\x02";
		if (event->keyval == 'k') add = "\x03";
		if (event->keyval == 'u') add = "\x1F";
		if (event->keyval == 'i') add = "\x1D";
		if (event->keyval == 'o') add = "\x0F";
		if (add) { gtk_text_buffer_insert_at_cursor(gtk_text_view_get_buffer(this->view), add, -1); return GDK_EVENT_STOP; }
	}
	
	if (event->keyval == GDK_KEY_Return)
	{
		GtkTextBuffer* buf = gtk_text_view_get_buffer(this->view);
		
		gchar* text;
		g_object_get(buf, "text", &text, NULL);
		this->onactivate(text);
		scrollback.insert(0, text);
		if (scrollback.size() > 100) scrollback.resize(100);
		g_free(text);
		
		gtk_text_buffer_set_text(buf, "", 0);
		
		return GDK_EVENT_STOP;
	}
	
	if (event->keyval == GDK_KEY_Page_Up || event->keyval == GDK_KEY_Page_Down)
	{
		if (mods == GDK_CONTROL_MASK)
		{
			this->onswitchfocus((event->keyval == GDK_KEY_Page_Up) ? -1 : 1);
		}
		else
		{
			this->onscroll(event);
		}
		return GDK_EVENT_STOP;
	}
	return GDK_EVENT_PROPAGATE;
}

void inputview::grab_focus() { gtk_widget_grab_focus(GTK_WIDGET(view)); }

void inputview::store_get(state* st)
{
	gchar* text_raw;
	g_object_get(gtk_text_view_get_buffer(view), "text", &text_raw, NULL);
	st->text = text_raw;
	g_free(text_raw);
	
	gint textpos_raw;
	g_object_get(gtk_text_view_get_buffer(view), "cursor-position", &textpos_raw, NULL);
	st->textpos = textpos_raw;
	
	st->scrollback = this->scrollback;
}
void inputview::store_set(const state* st)
{
	GtkTextBuffer* buf = gtk_text_view_get_buffer(view);
	gtk_text_buffer_set_text(buf, (char*)st->text.bytes().ptr(), st->text.bytes().size());
	
	GtkTextIter iter;
	gtk_text_buffer_get_iter_at_offset(buf, &iter, st->textpos);
	gtk_text_buffer_select_range(buf, &iter, &iter);
	
	this->scrollback = st->scrollback;
	this->scrollbackpos = -1;
}

GtkWidget* inputview::gtkwidget()
{
#if GTK_CHECK_VERSION(3,22,0)
	return (GtkWidget*)scrollview;
#else
	return (GtkWidget*)view;
#endif
}
#endif
