#include "inputview.h"
#include <gtk/gtk.h>

inputview::inputview(uint32_t valid_fmt)
{
	this->valid_fmt = valid_fmt;
	// making this lazy makes little difference to startup time, but fewer gtk_text_view_new means easier to measure those that exist
	view = NULL;
}

GtkWidget* inputview::gtkwidget()
{
	if (!view)
	{
		view = GTK_TEXT_VIEW(gtk_text_view_new());
		gtk_text_view_set_wrap_mode(view, GTK_WRAP_WORD_CHAR);
		
		//GtkEventController* key_ctrl = gtk_event_controller_key_new();
		//gboolean(*onkeydown_nat)(GtkWidget* widget, GdkEvent* event, void* user_data) =
		                      //[](GtkWidget* widget, GdkEvent* event, void* user_data) -> gboolean
		//{
			//return ((inputview*)user_data)->onkeydown(widget, event);
		//};
		//g_signal_connect(view, "key-press-event", G_CALLBACK(onkeydown_nat), this);
		
#ifdef ARLIB_GUI_GTK3
		gboolean(*onkeydown_nat)(GtkWidget* widget, GdkEventKey* event, void* user_data) =
		                      [](GtkWidget* widget, GdkEventKey* event, void* user_data) -> gboolean
		{
			return ((inputview*)user_data)->onkeydown(widget, (GdkEvent*)event);
		};
		g_signal_connect(view, "key-press-event", G_CALLBACK(onkeydown_nat), this);
#else
		// TODO: switch to proper key event handler
		GtkEventController* ctrl = gtk_event_controller_legacy_new();
		gtk_widget_add_controller(GTK_WIDGET(view), ctrl);
		gboolean(*onkeydown_nat)(GtkWidget* widget, GdkEvent* event, void* user_data) =
		                      [](GtkWidget* widget, GdkEvent* event, void* user_data) -> gboolean
		{
			if (gdk_event_get_event_type(event) == GDK_KEY_PRESS)
				return ((inputview*)user_data)->onkeydown(widget, event);
			return false;
		};
		g_signal_connect(ctrl, "event", G_CALLBACK(onkeydown_nat), this);
#endif
		
		//I could fiddle with signal "move-cursor" to allow messing with keybindings
		//but on the other hand, this program is designed for exactly one user, who says hardcoding pgup/pgdn is fine
		
		void(*onchange_nat)(GtkTextBuffer* textbuffer, void* user_data) =
		                 [](GtkTextBuffer* textbuffer, void* user_data)
		{
			inputview* this_ = (inputview*)user_data;
			this_->scrollbackpos = -1;
			this_->call_onmovecaret();
		};
		g_signal_connect(gtk_text_view_get_buffer(view), "changed", G_CALLBACK(onchange_nat), this);
		void(*oncurmove_nat)(GObject* gobject, GParamSpec* pspec, void* user_data) =
		                  [](GObject* gobject, GParamSpec* pspec, void* user_data)
		{
			((inputview*)user_data)->call_onmovecaret();
		};
		g_signal_connect(gtk_text_view_get_buffer(view), "notify::cursor-position", G_CALLBACK(oncurmove_nat), this);
		// TODO
/*
Adapt to GtkWidget's size allocation changes

The Gtk.WidgetClass.size_allocate vfunc takes the baseline as an argument now, so you no longer need
to call gtk_widget_get_allocated_baseline() to get it.

The ::size-allocate signal has been removed, since it is easy to misuse. If you need to learn about
sizing changes of custom drawing widgets, use the GtkDrawingArea::resize or GtkGLArea::resize
signals. If you want to track the size of toplevel windows, use property notification for
GtkWindow:default-width and GtkWindow:default-height.
*/
		//void(*onresize_nat)(GtkWidget* widget, GdkRectangle* allocation, void* user_data) =
		//                 [](GtkWidget* widget, GdkRectangle* allocation, void* user_data)
		//{
		//	((inputview*)user_data)->call_onmovecaret();
		//};
		//g_signal_connect(view, "size-allocate", G_CALLBACK(onresize_nat), this);
		
#ifdef ARLIB_GUI_GTK3
		gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_LEFT, 4);
		gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_RIGHT, 4);
		gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_TOP, 4);
		gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_BOTTOM, 4);
#else
		GtkTextWindowType spaces[] = { GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT, GTK_TEXT_WINDOW_TOP, GTK_TEXT_WINDOW_BOTTOM };
		for (GtkTextWindowType dir : spaces)
		{
			GtkWidget* space = gtk_drawing_area_new();
			gtk_widget_set_size_request(space, 4, 4);
			gtk_text_view_set_gutter(view, dir, space);
		}
#endif
		
		scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(
#ifdef ARLIB_GUI_GTK3
NULL, NULL
#endif
));
		gtk_scrolled_window_set_policy(scrollview, GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC);
#ifdef ARLIB_GUI_GTK3
		gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
		gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(view));
#else
		gtk_scrolled_window_set_has_frame(scrollview, true);
		gtk_scrolled_window_set_child(scrollview, GTK_WIDGET(view));
#endif
		
		gtk_scrolled_window_set_propagate_natural_height(scrollview, true);
		gtk_scrolled_window_set_max_content_height(scrollview, 300);
		
		gtk_widget_set_name(GTK_WIDGET(scrollview), "inputview-wrap");
		gtk_widget_set_name(GTK_WIDGET(view), "inputview");
		
		static GtkCssProvider* cssprovider = nullptr;
		if (!cssprovider)
		{
			cssprovider = gtk_css_provider_new();
			gtk_css_provider_load_from_data(cssprovider,
				"#inputview.error, #inputview.error text, #inputview.error border { background-image: none; background-color: #FBB; }"
				"#inputview-wrap scrollbar * { min-height: 0px; }"
				, -1
#ifdef ARLIB_GUI_GTK3
				, NULL
#endif
				);
			// gtk_style_context_add_provider(gtk_widget_get_style_context()) would make more sense,
			// but the scrollbars are in another style context than the scrollview
			// I could dig through the scrollview's children, but just making it global is easier
			// it won't accidentally hit anything else, every rule in the above css has an id selector
			gtk_style_context_add_provider_for_screen(gdk_screen_get_default(),
			                                          GTK_STYLE_PROVIDER(cssprovider),
			                                          GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
		}
	}
	
	return GTK_WIDGET(scrollview);
}

bool inputview::onkeydown(GtkWidget* widget, GdkEvent* event)
{
	if (gtk_text_view_im_context_filter_keypress(this->view, &event->key))
	{
		return GDK_EVENT_STOP;
	}
	
	uint32_t keyval = event->key.keyval;
	//GdkModifierType mods = (GdkModifierType)(gdk_event_get_modifier_state(event) & (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_ALT_MASK));
	GdkModifierType mods = (GdkModifierType)(event->key.state & (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_MOD1_MASK));
	
	if (mods == 0)
	{
		if (keyval == GDK_KEY_Up || keyval == GDK_KEY_Down)
		{
			GtkTextBuffer* buf = gtk_text_view_get_buffer(this->view);
			
			if (keyval == GDK_KEY_Up)
			{
				if (this->scrollbackpos == -1 && gtk_text_buffer_get_char_count(buf) != 0)
					return GDK_EVENT_PROPAGATE;
				if (this->scrollbackpos == (int)(this->scrollback.size()-1))
					return GDK_EVENT_STOP;
				else
					this->scrollbackpos++;
			}
			else
			{
				if (this->scrollbackpos == -1)
					return GDK_EVENT_PROPAGATE;
				this->scrollbackpos--;
			}
			
			if (this->scrollbackpos == -1)
			{
				gtk_text_buffer_set_text(buf, "", 0);
			}
			else
			{
				string& newtext = this->scrollback[this->scrollbackpos];
				int tmp = this->scrollbackpos;
				gtk_text_buffer_set_text(buf, newtext, newtext.length());
				this->scrollbackpos = tmp; // set_text calls 'changed' signal, which resets scrollbackpos; set it back
			}
			
			return GDK_EVENT_STOP;
		}
		else
		{
			this->scrollbackpos = -1;
		}
		
		if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
		{
			GtkTextBuffer* buf = gtk_text_view_get_buffer(this->view);
			
			gchar* text;
			g_object_get(buf, "text", &text, NULL);
			gtk_text_buffer_set_text(buf, "", 0);
			
			if (*text)
			{
				while (true)
				{
					// dropping files into the window uses \r\n instead of \n for whatever reason; throw it out
					// it's quadratic worst-case, but only for unrealistic inputs
					char* crlf = strstr(text, "\r\n");
					if (!crlf) break;
					char* end = strchr(crlf, '\0');
					memmove(crlf, crlf+1, end-crlf);
				}
				
				this->onactivate(text);
				if (scrollback.size()==0 || scrollback[0] != text)
				{
					scrollback.insert(0, text);
					if (scrollback.size() > 100) scrollback.resize(100);
				}
			}
			g_free(text);
			
			return GDK_EVENT_STOP;
		}
	}
	
	if (mods == GDK_CONTROL_MASK)
	{
		const char * add = NULL;
		if (keyval == 'b') add = "\x02";
		if (keyval == 'k') add = "\x03";
		if (keyval == 'o') add = "\x0F";
		if (keyval == 'm') add = "\x11";
		if (keyval == 'i') add = "\x1D";
		if (keyval == 's') add = "\x1E";
		if (keyval == 'u') add = "\x1F";
		if (add && valid_fmt & (1u << *add))
		{
			gtk_text_buffer_insert_at_cursor(gtk_text_view_get_buffer(this->view), add, -1);
			return GDK_EVENT_STOP;
		}
	}
	
	return GDK_EVENT_PROPAGATE;
}

void inputview::call_onmovecaret()
{
	if (!onmovecaret) return;
	
	GdkRectangle curpos;
	gtk_text_view_get_cursor_locations(view, NULL, &curpos, NULL);
	//not needed; this widget has no horizontal scrollbar, and vertical is to the right and doesn't affect X
	//gtk_text_view_buffer_to_window_coords(view, GTK_TEXT_WINDOW_TEXT, curpos.x, curpos.y, &x, NULL);
	//the +4 is the GTK_TEXT_WINDOW_LEFT size, which is hardcoded in the constructor and can be hardcoded here
	onmovecaret(curpos.x+4);
}

bool inputview::has_focus() { return gtk_widget_is_focus(GTK_WIDGET(view)); }
void inputview::grab_focus() { gtk_widget_grab_focus(GTK_WIDGET(view)); }

void inputview::text_prefix(cstring text)
{
	GtkTextBuffer* buf = gtk_text_view_get_buffer(this->view);
	GtkTextIter it;
	gtk_text_buffer_get_start_iter(buf, &it);
	gtk_text_buffer_insert(buf, &it, (char*)text.bytes().ptr(), text.length());
}
void inputview::text_replace(cstring text)
{
	GtkTextBuffer* buf = gtk_text_view_get_buffer(this->view);
	GtkTextIter it;
	gtk_text_buffer_get_start_iter(buf, &it);
	GtkTextIter it2;
	gtk_text_buffer_get_end_iter(buf, &it2);
	gtk_text_buffer_delete(buf, &it, &it2);
	gtk_text_buffer_insert(buf, &it, (char*)text.bytes().ptr(), text.length());
}

void inputview::set_warning(bool warning)
{
	gtkwidget(); // instantiate it
	
	if (warning)
	{
		GtkStyleContext* context = gtk_widget_get_style_context(GTK_WIDGET(view));
		gtk_style_context_add_class(context, "error");
	}
	else
	{
		GtkStyleContext* context = gtk_widget_get_style_context(GTK_WIDGET(view));
		gtk_style_context_remove_class(context, "error");
	}
}
