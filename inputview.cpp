#include "inputview.h"
#include <gtk/gtk.h>

inputview::inputview(uint32_t valid_fmt)
{
	this->valid_fmt = valid_fmt;
	// making this lazy makes little difference to startup time, but fewer gtk_text_view_new means easier to measure those that exist
	view = NULL;
}

GtkWidget* inputview::gtkwidget()
{
	if (!view)
	{
		view = GTK_TEXT_VIEW(gtk_text_view_new());
		gtk_text_view_set_wrap_mode(view, GTK_WRAP_WORD_CHAR);
		
		gboolean(*onkeydown_nat)(GtkWidget* widget, GdkEventKey* event, void* user_data) =
		                      [](GtkWidget* widget, GdkEventKey* event, void* user_data) -> gboolean
		{
			return ((inputview*)user_data)->onkeydown(widget, event);
		};
		g_signal_connect(view, "key-press-event", G_CALLBACK(onkeydown_nat), this);
		//I could fiddle with signal "move-cursor" to allow messing with keybindings
		//but on the other hand, this program is designed for exactly one user, who says hardcoding pgup/pgdn is fine
		
		void(*onchange_nat)(GtkTextBuffer* textbuffer, void* user_data) =
		                 [](GtkTextBuffer* textbuffer, void* user_data)
		{
			((inputview*)user_data)->call_onmovecaret();
		};
		g_signal_connect(gtk_text_view_get_buffer(view), "changed", G_CALLBACK(onchange_nat), this);
		void(*oncurmove_nat)(GObject* gobject, GParamSpec* pspec, void* user_data) =
		                  [](GObject* gobject, GParamSpec* pspec, void* user_data)
		{
			((inputview*)user_data)->call_onmovecaret();
		};
		g_signal_connect(gtk_text_view_get_buffer(view), "notify::cursor-position", G_CALLBACK(oncurmove_nat), this);
		void(*onresize_nat)(GtkWidget* widget, GdkRectangle* allocation, void* user_data) =
		                 [](GtkWidget* widget, GdkRectangle* allocation, void* user_data)
		{
			((inputview*)user_data)->call_onmovecaret();
		};
		g_signal_connect(view, "size-allocate", G_CALLBACK(onresize_nat), this);
		
		gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_LEFT, 4);
		gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_RIGHT, 4);
		gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_TOP, 4);
		gtk_text_view_set_border_window_size(view, GTK_TEXT_WINDOW_BOTTOM, 4);
		
#if GTK_CHECK_VERSION(3,22,0)
		scrollview = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new(NULL, NULL));
		gtk_scrolled_window_set_policy(scrollview, GTK_POLICY_EXTERNAL, GTK_POLICY_AUTOMATIC);
		gtk_scrolled_window_set_shadow_type(scrollview, GTK_SHADOW_IN);
		gtk_container_add(GTK_CONTAINER(scrollview), GTK_WIDGET(view));
		
		gtk_scrolled_window_set_propagate_natural_height(scrollview, true);
		gtk_scrolled_window_set_max_content_height(scrollview, 300);
		
		gtk_widget_set_name(GTK_WIDGET(scrollview), "inputview");
#else
		gtk_widget_set_name(GTK_WIDGET(view), "inputview");
#endif
	}
	
#if GTK_CHECK_VERSION(3,22,0)
	return GTK_WIDGET(scrollview);
#else
	return GTK_WIDGET(view);
#endif
}

bool inputview::onkeydown(GtkWidget* widget, GdkEventKey* event)
{
	if (gtk_text_view_im_context_filter_keypress(this->view, event))
	{
		return GDK_EVENT_STOP;
	}
	
	GdkModifierType mods = (GdkModifierType)(event->state & (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_MOD1_MASK));
	
	if (mods == 0)
	{
		if (event->keyval == GDK_KEY_Up || event->keyval == GDK_KEY_Down)
		{
			GtkTextBuffer* buf = gtk_text_view_get_buffer(this->view);
			
			if (event->keyval == GDK_KEY_Up)
			{
				if (this->scrollbackpos == -1 && gtk_text_buffer_get_char_count(buf) != 0)
					return GDK_EVENT_PROPAGATE;
				if (this->scrollbackpos == (int)(this->scrollback.size()-1))
					return GDK_EVENT_STOP;
				else
					this->scrollbackpos++;
			}
			else
			{
				if (this->scrollbackpos == -1)
					return GDK_EVENT_PROPAGATE;
				this->scrollbackpos--;
			}
			
			if (this->scrollbackpos == -1)
			{
				gtk_text_buffer_set_text(buf, "", 0);
			}
			else
			{
				string& newtext = this->scrollback[this->scrollbackpos];
				gtk_text_buffer_set_text(buf, newtext, newtext.length());
			}
			
			return GDK_EVENT_STOP;
		}
		else
		{
			this->scrollbackpos = -1;
		}
		
		if (event->keyval == GDK_KEY_Return || event->keyval == GDK_KEY_KP_Enter)
		{
			GtkTextBuffer* buf = gtk_text_view_get_buffer(this->view);
			
			gchar* text;
			g_object_get(buf, "text", &text, NULL);
			gtk_text_buffer_set_text(buf, "", 0);
			
			if (*text)
			{
				this->onactivate(text);
				if (scrollback.size()==0 || scrollback[0] != text)
				{
					scrollback.insert(0, text);
					if (scrollback.size() > 100) scrollback.resize(100);
				}
			}
			g_free(text);
			
			return GDK_EVENT_STOP;
		}
	}
	
	if (mods == GDK_CONTROL_MASK)
	{
		const char * add = NULL;
		if (event->keyval == 'b') add = "\x02";
		if (event->keyval == 'k') add = "\x03";
		if (event->keyval == 'o') add = "\x0F";
		if (event->keyval == 'm') add = "\x11";
		if (event->keyval == 'i') add = "\x1D";
		if (event->keyval == 's') add = "\x1E";
		if (event->keyval == 'u') add = "\x1F";
		if (add && valid_fmt & (1u << *add))
		{
			gtk_text_buffer_insert_at_cursor(gtk_text_view_get_buffer(this->view), add, -1);
			return GDK_EVENT_STOP;
		}
	}
	
	return GDK_EVENT_PROPAGATE;
}

void inputview::call_onmovecaret()
{
	if (!onmovecaret) return;
	
	GdkRectangle curpos;
	gtk_text_view_get_cursor_locations(view, NULL, &curpos, NULL);
	//not needed, this widget has no horizontal scrollbar, and vertical is to the right and doesn't affect X
	//gtk_text_view_buffer_to_window_coords(view, GTK_TEXT_WINDOW_TEXT, curpos.x, curpos.y, &x, NULL);
	//the +4 is the GTK_TEXT_WINDOW_LEFT size, which is hardcoded in the constructor and can be hardcoded here
	onmovecaret(curpos.x+4);
}

bool inputview::has_focus() { return gtk_widget_is_focus(GTK_WIDGET(view)); }
void inputview::grab_focus() { gtk_widget_grab_focus(GTK_WIDGET(view)); }

void inputview::set_warning(bool warning)
{
	gtkwidget(); // instantiate it
	
	if (warning)
	{
		static GtkCssProvider* cssprovider = NULL;
		if (!cssprovider)
		{
			cssprovider = gtk_css_provider_new();
			gtk_css_provider_load_from_data(cssprovider,
				"GtkTextView#inputview.error { background-image: none; background-color: #FCC; }"
#if GTK_CHECK_VERSION(3,22,0) // spaghetticode(tm), is there any better way to make selection use the default color?
				"GtkTextView#inputview.error:selected { background-color: #9ab9d4; }"
#else
				"GtkTextView#inputview.error:selected { background-color: #9ab87c; }"
#endif
				//this selection doesn't look too good, but not terrible either.
				, -1, NULL);
		}
		GtkStyleContext* context = gtk_widget_get_style_context(GTK_WIDGET(view));
		gtk_style_context_add_provider(context, GTK_STYLE_PROVIDER(cssprovider), GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
		gtk_style_context_add_class(context, "error");
	}
	else
	{
		GtkStyleContext* context = gtk_widget_get_style_context(GTK_WIDGET(view));
		gtk_style_context_remove_class(context, "error");
	}
}
