#pragma once
#include "russian.h"

namespace russian {

class discord_emoji {
public:
	//data must be a ZIP file.
	//While every member is conceptually const, the object contains an internal mutable cache, so it's not thread safe.
	static discord_emoji* create(bytesr data, unsigned imgsize);
	
	//If given a valid emoji name (colons included), appends it to the array and returns true. If invalid, returns false and does nothing.
	//Uses the given span's background color, and other formatting if applicable.
	virtual bool insert_by_name(array<span>& out, const span& fmt, cstring name) const = 0;
	
	//Inserts the given text using the given span's formatting, except Unicode emoji in the input are replaced with images.
	virtual void insert_by_unicode(array<span>& out, const span& fmt, cstring text) const = 0;
	
	struct emoji {
		string unicode; // "ðŸ’©"
		array<string> names; // [ ":poop:", ":hankey:" ] - first one is the primary. Guaranteed nonempty.
		
		bool has_image() const { return zipidx != (size_t)-1; }
		
		// These members are considered private. Only the discord_emoji implementation should touch them.
		size_t zipidx; // index to the zip, or -1 if no image
		mutable autoptr<textview::image> img; // image; null for most entries, non-null for anything that's been used
		bool delete_fe0f;
	};
	// Sorted alphabetically by the primary name without colons, i.e. :cat: goes before :cat2: even though 2 goes before :.
	virtual arrayview<const emoji*> list() const = 0;
	
	virtual textview::image* get_image(const emoji* em) const = 0;
	
	virtual const emoji* find_by_unicode(cstring text) const = 0;
	
	virtual ~discord_emoji() {}
};

class discord_format : nocopy {
public:
	//While every member is conceptually const, the object maintains some internal state while parsing, so it's not thread safe.
	
	enum source_t {
		normal,
		webhook,
		embed_body = webhook,
		embed_title,
		topic,
	};
	
	//cb_external should append one or more spans to the given array. 'content' will be a user, channel, or group mention,
	// or a guild emoji, as seen on the wire, without the <>s.
	//For example, it can be "@123" (user) or ":thonk:379295935689392148" (guild emoji).
	static discord_format* create(discord_emoji* emoji,
	                              function<void(array<span>& out, const span& fmt, cstring content)> cb_external,
	                              uint32_t spoiler_col);
	
	//The span array can be nonempty. The parsed string will be appended to it.
	//You're welcome to paint the message red by editing fmt. Or bold the entire thing, but that will make bolds in the input disappear.
	//Discord supports multiple flavors of markdown; pick the right one.
	//If the input is not valid UTF-8 or WTF-8, undefined behavior. NUL is allowed.
	virtual void parse(source_t source, array<span>& out, const span& fmt, cstring text) const = 0;
	
	//Takes a string with IRC formatting (\x02, etc). Returns a Discord markdown string representing the same formatting.
	//Does not escape emoji; a U+1F4A9 in the input is left that way, and will be parsed as emoji.
	//May insert a few U+200B ZERO WIDTH SPACE and/or U+FEFF ZERO WIDTH NO-BREAK SPACE, to override markdown 'smarts'.
	//May emit incorrect output if input is too crazy, like "<STRIKE><MONO>foo~~bar".
	static string unparse_irc(cstring in);
	static string unparse(arrayvieww<span> in); // Will alter the input spans.
	
	virtual ~discord_format() {}
};

}
