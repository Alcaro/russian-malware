#pragma once
#include "russian.h"

namespace russian {

class discord_emoji {
public:
	//data must be a ZIP file.
	//While every member is conceptually const, the object contains an internal mutable cache, so it's not thread safe.
	static discord_emoji* create(bytesr data, unsigned imgsize);
	
	//Replaces all known Unicode emoji with their ASCII names, for example "abcðŸ’©123" -> "abc:poop:123".
	//Yes, insert+translate is silly, but that's what's needed to be accurate.
	//Input must be valid UTF-8, except the first byte may be a continuation character (second byte may not).
	virtual string translate(cstring in) const = 0;
	
	//If given a valid emoji name (colons included), appends it to the array and returns true. If invalid, returns false.
	//If the emoji should be inserted as text (like :copyright:, or images disabled), it will use the given span's formatting.
	virtual bool insert(array<span>& out, const span& fmt, cstring name) const = 0;
	
	struct emoji {
		string unicode; // "ðŸ’©"
		array<string> names; // [ ":poop:", ":hankey:" ] - first one is the primary. Guaranteed nonempty.
		
		bool has_image() const { return zipidx != (size_t)-1; }
		
		// These two are considered private. Only the discord_emoji implementation should touch them.
		size_t zipidx; // index to the zip, or -1 if no image
		mutable autoptr<textview::image> img; // image; null for most entries, non-null for anything that's been used
	};
	// Sorted alphabetically by the primary name without colons, i.e. :cat: goes before :cat2: even though 2 goes before :.
	virtual arrayview<const emoji*> list() const = 0;
	virtual textview::image* get_image(const emoji* em) const = 0;
	
	virtual ~discord_emoji() {}
};

class discord_format : nocopy {
public:
	//While every member is conceptually const, the object maintains some internal state while parsing, so it's not thread safe.
	
	enum source_t {
		normal,
		webhook,
		embed_body = webhook,
		embed_title,
		topic,
	};
	
	//cb_external should append one or more spans to the given array. 'content' will be a user, channel, or group mention,
	// or a guild emoji, as seen on the wire, without the <>s.
	//For example, it can be "@123" (user) or ":thonk:379295935689392148" (guild emoji).
	static discord_format* create(discord_emoji* emoji,
	                              function<void(array<span>& out, const span& fmt, cstring content)> cb_external,
	                              uint32_t spoiler_col);
	
	//The span array can be nonempty. The parsed string will be appended to it.
	//You're welcome to paint the message red by editing fmt. Or bold the entire thing, but that will make bolds in the input disappear.
	//Discord supports multiple flavors of markdown; pick the right one.
	//If the input is not valid UTF-8 or WTF-8, undefined behavior. NUL is allowed.
	virtual void parse(source_t source, array<span>& out, const span& fmt, cstring text) const = 0;
	
	//Takes a string with IRC formatting (\x02, etc). Returns a Discord markdown string representing the same formatting.
	//Does not escape emoji; a U+1F4A9 in the input is left that way, and will be parsed as emoji.
	//May insert a few U+200B ZERO WIDTH SPACE and/or U+FEFF ZERO WIDTH NO-BREAK SPACE, to override markdown 'smarts'.
	//May emit incorrect output if input is too crazy, like "<STRIKE><MONO>foo~~bar".
	static string unparse_irc(cstring in);
	static string unparse(arrayvieww<span> in); // Will alter the input spans.
	
	virtual ~discord_format() {}
};

}
