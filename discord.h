#pragma once
#include "russian.h"

namespace russian {

class discord_emoji {
public:
	//data must be a ZIP file.
	//While every member is conceptually const, the object contains an internal mutable cache, so it's not thread safe.
	static discord_emoji* create(arrayview<byte> data, unsigned imgsize);
	
	//Returns a sorted list of all known names, colons included.
	virtual arrayview<cstring> names() const = 0;
	
	//If given a valid emoji name (colons included), appends it to the array and returns true. If invalid, returns false.
	//If the emoji should be inserted as text (like :copyright:, or images disabled), it will use the given span's formatting.
	virtual bool insert(array<span>& out, const span& fmt, cstring name) const = 0;
	
	//Replaces all known Unicode emoji with their ASCII names, for example "abcðŸ’©123" -> "abc:poop:123".
	//Yes, insert+translate is silly, but that's what's needed to be accurate.
	virtual string translate(cstring in) const = 0;
	
	//Returns an arbitrary emoji, suitable for use as someone's avatar.
	//Must yield the same pixel data given the same seed and same input zip, across program runs.
	//To maximize recognizability, this should pick from reasonably large number of emoji,
	// but should avoid too similar ones (like skin color).
	//Can return NULL if no image emoji are loaded.
	virtual textview::image* pick_avatar(uint64_t seed) const = 0;
	
	virtual ~discord_emoji() {}
};

class discord_format : nocopy {
public:
	//While every member is conceptually const, the object maintains some internal state while parsing, so it's not thread safe.
	
	enum source_t {
		normal,
		webhook,
		embed_body = webhook,
		embed_title,
		topic,
	};
	
	//cb_external should append one or more spans to the given array. 'content' will be a user, channel, or group mention,
	// or a guild emoji, as seen on the wire, without the <>s.
	//For example, it can be "@123" (user) or ":thonk:379295935689392148" (guild emoji).
	static discord_format* create(discord_emoji* emoji,
	                              function<void(array<span>& out, const span& fmt, cstring content)> cb_external,
	                              uint32_t spoiler_col);
	
	//The span array can be nonempty. The parsed string will be appended to it.
	//You're welcome to paint the message red by editing fmt. Or bold the entire thing, but that will make bolds in the input disappear.
	//Discord supports multiple flavors of markdown; pick the right one.
	//If the input is not valid UTF-8 or WTF-8, undefined behavior. NUL is allowed.
	virtual void parse(source_t source, array<span>& out, const span& fmt, cstring text) const = 0;
	
	//Takes a string with IRC formatting (U+0002, etc). Turns all IRC formatting into Discord markdown,
	// and escapes all input markup. May insert a few U+200B ZERO WIDTH SPACE to override markdown 'smarts'.
	//TODO: figure out what http links should do
	//TODO: figure out how to represent ||spoilers||
	//Does not escape emoji; a U+1F4A9 in the input is left that way, and will be parsed as emoji.
	virtual string unparse_irc(cstring in) const = 0;
	
	virtual ~discord_format() {}
};

}
