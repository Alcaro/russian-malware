#pragma once
#include "russian.h"

namespace russian {
#define UNWRAP(x) ([&](){ if constexpr(requires { x(); }) return x(); else return x; }())

#if __cplusplus >= 202300
#error "replace crtp with deducing this and delete Tinner"
#endif

template<typename Tinner> class chatbase;
template<typename Tinner> class chatbase_impl;

// complications:
// - discord has multiple channel groups, show_channel can't take channel only
//    may want to remove channel/group distinction entirely before doing this
//    should just give channels a parent pointer
// - matrix' lack of online/offline distinction is easier than slack/discord, but also hard to unify with anything else
// - matrix message ids are unorderable, long, and not alphanumeric
//    though message id structure is specified - $ followed by 43 chars from A-Za-z0-9_- (base64 encoding of sha256 of whatever)
//    version 3 rooms use +/ instead of -_
//    version 1 and 2 is $, 24 hex digits, colon, domain name
//    https://spec.matrix.org/unstable/rooms/v10/#event-ids
//    the 'fetch more scrollback' event can safely have ilink equal to "scrollback" \x01 id1 \x01 id2
//    (or I can make it two mid members of struct channel)
// - slack ids' null is nonempty (and the thread thing is kinda weird)

// Usage:
/*
class my_chat : public chatbase<my_chat> {
};
protocol* create() { return new chatbase_impl<my_chat>(); }
*/

template<typename Tinner>
class chatbase : public russian::protocol
{
public:
	using uid = string;
	using cid = string;
	using mid = string;
	using uidref = cstring;
	using cidref = cstring;
	using midref = cstring;
	
	using protocol::protocol;
	
	co_holder m_misc_waiters;
	
private:
	chatbase_impl<Tinner>* self()
	{
		static_assert(std::is_base_of_v<chatbase, chatbase_impl<Tinner>>);
		return (chatbase_impl<Tinner>*)this;
	}
	
public:
	template<typename T> auto& user_for(const T& id) { return self()->user_for(id); }
	template<typename T> auto& channel_for(const T& id) { return self()->channel_for(id); }
	
	template<typename T> auto* try_user_for(const T& id) { return self()->try_user_for(id); }
	template<typename T> auto* try_channel_for(const T& id) { return self()->try_channel_for(id); }
	
	auto& users() { return self()->m_users; }
	auto& channels() { return self()->m_channels; }
	
	void reconnect_in(int ms = 30000) { self()->reconnect_in(ms); }
	void ping_in(int ms = 30000) { self()->ping_in(ms); }
	
	template<typename Ti = Tinner>
	void show_channel(Ti::channel& ch) { self()->show_channel(ch); }
	// The array must be sorted with the oldest message first.
	template<typename Ti = Tinner>
	void scrollback_segment(Ti::channel& ch, arrayvieww<typename Ti::message> ms) { self()->scrollback_segment(ch, ms); }
	template<typename Ti = Tinner>
	void append_message(Ti::channel& ch, Ti::message& m) { self()->append_message(ch, m); }
	template<typename Ti = Tinner>
	void edit_message(Ti::channel& ch, Ti::message& m, bool known_edited) { self()->edit_message(ch, m, known_edited); }
	template<typename Ti = Tinner>
	void delete_message(Ti::channel& ch, Ti::midref mr) { self()->delete_message(ch, mr); }
	template<typename Ti = Tinner>
	void channel_member_join(Ti::channel& ch, Ti::user& u) { self()->channel_member_join(ch, u); }
	template<typename Ti = Tinner>
	void channel_member_leave(Ti::channel& ch, Ti::user& u) { self()->channel_member_leave(ch, u); }
	
	void terminate() { self()->terminate(); }
	
	// The protocol must implement this.
	async<void> network() = delete;
};

template<typename Tinner>
class chatbase_impl : public Tinner {
public:
	using uid = typename Tinner::uid;
	using cid = typename Tinner::cid;
	using mid = typename Tinner::mid;
	using uidref = typename Tinner::uidref;
	using cidref = typename Tinner::cidref;
	using midref = typename Tinner::midref;
	
	using user = typename Tinner::user;
	using channel = typename Tinner::channel;
	using message = typename Tinner::message;
	
	// these two structs contain members that this chatbase object needs, but which the protocol handler shouldn't care about
	// every user and channel are owned by the below container_t, protocol doesn't care if it's a subobject (it's already in a map<>::node)
	// can't do the same with messages, since they live in array<message> in channel, but they don't need any augmentations either
	struct augmented_user {
		user main;
		// nothing else
	};
	struct augmented_channel {
		channel main;
		
		file log_file;
		time_t log_rotate_at = 0;
	};
	
	augmented_user& augment(user& u) { return *container_of<&augmented_user::main>(&u); }
	augmented_channel& augment(channel& ch) { return *container_of<&augmented_channel::main>(&ch); }
	
	template<typename Tidref, typename Tobj, typename Tpublic>
	class container_t {
		// the id is also present in the object
		// I could change to a set whose hash function returns that; it would save some ram, but would also mean an extra memory indirection
		// (and set doesn't have a 'get the object equal to this' function, just a 'does it exist')
		map<Tidref, autoptr<Tobj>> inner;
		
	public:
		Tobj* create(Tidref id)
		{
			autoptr<Tobj> obj = new Tobj();
			obj->main.id = id;
			autoptr<Tobj>& ret = inner.insert(obj->main.id);
			ret = std::move(obj);
			return ret;
		}
		
		Tobj* get_or_null(Tidref id)
		{
			autoptr<Tobj>* retw = inner.get_or_null(id);
			if (retw)
				return *retw;
			else
				return nullptr;
		}
		
		Tobj* get_create(Tidref id)
		{
			Tobj* ret = get_or_null(id);
			if (ret)
				return ret;
			else
				return create(id);
		}
		
		void serialize2(auto& s)
		{
			if constexpr (std::remove_reference_t<decltype(s)>::serializing) // can't change to s.serializing, Clang rejects that
			{
				SER_ENTER(s)
				{
					for (auto& pair : inner)
					{
						// todo: find a way to delete dead elements
						// add undo function to serializer or something?
						s.item(pair.value->main.id, pair.value->main);
					}
				}
			}
			else
			{
				SER_ENTER(s)
				{
					cstring id = s.get_name();
					Tobj* item = get_create(id);
					s.item(item->main);
				}
			}
		}
		
		struct iterator {
			decltype(inner.begin()) it;
		public:
			iterator(decltype(inner.begin()) it) : it(it) {}
			
			Tpublic& operator*() { return (*it).value->main; }
			void operator++() { ++it; }
			bool operator!=(const end_iterator& other) { return it != other; }
		};
		iterator begin() { return inner.begin(); }
		end_iterator end() { return {}; }
	};
	container_t<uidref, augmented_user, user> m_users;
	container_t<cidref, augmented_channel, channel> m_channels;
	
	template<typename Tr, typename Tar, typename Titems, typename Tidref>
	Tr& lookup_or_create(Titems& items, Tidref id)
	{
		Tar* ret = items.get_create(id);
		ret->main.used = true;
		return ret->main;
	}
	
	template<typename Tr, typename Tar, typename Titems, typename Tidref>
	Tr* lookup_or_null(Titems& items, Tidref id)
	{
		Tar* ret = items.get_or_null(id);
		if (!ret)
			return nullptr;
		ret->main.used = true;
		return &ret->main;
	}
	
	user&        user_for(   uidref id) { return lookup_or_create<user, augmented_user>(m_users, id); }
	channel&     channel_for(cidref id) { return lookup_or_create<channel, augmented_channel>(m_channels, id); }
	user*    try_user_for(   uidref id) { return lookup_or_null<user, augmented_user>(m_users, id); }
	channel* try_channel_for(cidref id) { return lookup_or_null<channel, augmented_channel>(m_channels, id); }
	
	auto id_to_string(cstring id)
	{
		return id;
	}
	auto id_to_string(uidref id)
		requires (!std::is_same_v<uidref, cstring>)
	{
		return this->Tinner::id_to_string(id);
	}
	auto id_to_string(cidref id)
		requires (!std::is_same_v<cidref, cstring> && !std::is_same_v<cidref, uidref>)
	{
		return this->Tinner::id_to_string(id);
	}
	auto id_to_string(midref id)
		requires (!std::is_same_v<midref, cstring> && !std::is_same_v<midref, uidref> && !std::is_same_v<midref, cidref>)
	{
		return this->Tinner::id_to_string(id);
	}
	
	chatbase_impl(impl* parent, json5deserializer2& s) : Tinner(parent)
	{
		// base class is constructed before member variables; can't load the user list before it's constructed
		// so the real constructor work goes in a separate function
		this->init(s);
		for (channel& ch : m_channels)
		{
			if (show_channel_initial(ch))
				show_channel(ch);
		}
		start_network();
	}
	
	~chatbase_impl()
	{
		// dtor order is reverse ctor, i.e. also wrong
		this->deinit();
	}
	
	waiter<void> m_wait_network; // may complete on network failure; ignore the result, the reconnect timer will reset it
	waiter_polymorph<void> m_wait_ping;
	
	void reconnect_in(int ms)
	{
		m_wait_ping.cancel();
		runloop2::in_ms(ms).then(m_wait_ping.with(make_waiter<&chatbase_impl::m_wait_ping, &chatbase_impl::start_network>()));
	}
	void ping_in(int ms)
	{
		m_wait_ping.cancel();
		runloop2::in_ms(ms).then(m_wait_ping.with(make_waiter<&chatbase_impl::m_wait_ping, &chatbase_impl::send_ping>()));
	}
	void send_ping()
	{
		reconnect_in(10000);
		this->ping();
	}
	
	void start_network()
	{
		m_wait_network.cancel();
		reconnect_in(30000);
		this->network().then(&m_wait_network);
	}
	
	void terminate()
	{
		m_wait_ping.cancel();
		// extra indirection, so network() calling terminate() doesn't UAF its coroutine frame
		runloop2::in_ms(0).then(m_wait_ping.with(make_waiter<&chatbase_impl::m_wait_ping, &chatbase_impl::terminate_cb>()));
	}
	void terminate_cb()
	{
		m_wait_network.cancel();
	}
	
	void action(chanbase& at, cstrnul text) override
	{
		auto simple_message = [&at](cstring text) {
			span sp[1] = { { text } };
			at.message(chanbase::imp_scrollback, time(NULL), sp);
		};
		
		channel* ch = at.userdata;
		
		if (LIKELY(text[0] != '/'))
		{
			if (!ch) return simple_message("* Can't talk here");
			
		normal_send:
			this->m_misc_waiters.add(this->send_message(*ch, text));
			return;
		}
		if (text[1] == '/')
		{
			if (!ch) return simple_message("* Can't talk here");
			text = text.substr_nul(1);
			goto normal_send;
		}
		
		array<cstring> parts = text.substr_nul(1).csplit<1>(REGEX(" |(?=\\n)"));
		cstring command = parts[0];
		cstring param = parts.size()==2 ? parts[1] : "";
		
		if (this->command(ch, command, param)) {}
		else if (command == "join")
		{
			array<channel*> matches;
			
			for (int type : range(3))
			{
				for (channel& c : m_channels)
				{
					auto name = UNWRAP(c.name);
					if (type == 0)
					{
						if (name.matches_globi(param+"*") || name.matches_globi("#"+param+"*"))
							matches.append(&c);
					}
					if (type == 1)
					{
						if (name.matches_globi(param+"*"))
							matches.append(&c);
					}
					if (type == 2)
					{
						if (name.matches_globi("*"+param+"*"))
							matches.append(&c);
					}
				}
				if (matches) break;
			}
			
			if (!matches)
				return simple_message("No such channel");
			
			if (matches.size() == 1 && matches[0] != ch)
			{
				channel* c = matches[0];
				show_channel(*c);
				c->host->focus();
			}
			else
			{
				for (channel* c : matches)
					simple_message(UNWRAP(c->name));
			}
		}
		else
		{
			simple_message("* Unknown command");
		}
	}
	
	void close_chan(chanbase& at) override
	{
		channel* chp = at.userdata;
		if (!chp) return; // it's the server tab
		channel& ch = *chp;
		ch.host = nullptr;
	}
	
	group* parent_for(channel& ch)
	{
		if constexpr (requires { sizeof(ch.parent); })
			return ch.parent;
		else if constexpr (requires { ch.parent(); })
			return ch.parent();
		else
			return this->m_root;
	}
	
	void show_channel(channel& ch)
	{
		if (ch.host)
			return;
		group* parent = parent_for(ch);
		ch.host = parent->child(UNWRAP(ch.name), chanbase::f_no_logs, &ch);
		ch.host->sort_idx(ch.is_dm() ? 0 : 1);
		ch.host->set_available(this->m_online);
		if constexpr (requires { ch.members; })
		{
			for (user* u : ch.members)
			{
				ch.host->user_add(UNWRAP(u->name));
			}
		}
		for (message& m : ch.messages)
		{
			ch.host->message(id_to_string(m.id), chanbase::imp_scrollback, UNWRAP(m.time).sec, this->message_render(ch, m));
		}
		if (ch.scrollback_partial)
			set_scrollback_notice(ch, 1);
	}
	
	// type 0 - remove
	// type 1 - [scrollback not loaded]
	// type 2 - [loading scrollback]
	// type 3 - [loading failed, retry?]
	// call only if host is nonnull
	void set_scrollback_notice(channel& ch, int type)
	{
		ch.host->message_delete_true("\1russian-scrollback");
		if (type == 0)
			return;
		if (type == 1)
		{
			span sp[] = {
				{ .text="\1russian-scrollback", .hidden=true, .i_link=true },
				{ .text="[scrollback not loaded]", .i_link=true },
			};
			ch.host->message_before(id_to_string(ch.scrollback_pos), "\1russian-scrollback", chanbase::imp_scrollback, 0, sp);
		}
		if (type == 2)
		{
			span sp[] = {
				{ .text="[loading scrollback]" },
			};
			ch.host->message_before(id_to_string(ch.scrollback_pos), "\1russian-scrollback", chanbase::imp_scrollback, 0, sp);
		}
		if (type == 3)
		{
			span sp[] = {
				{ .text="\1russian-scrollback", .hidden=true, .i_link=true },
				{ .text="[loading failed, retry?]", .i_link=true },
			};
			ch.host->message_before(id_to_string(ch.scrollback_pos), "\1russian-scrollback", chanbase::imp_scrollback, 0, sp);
		}
	}
	
	void ilink(chanbase& at, string text) override
	{
		channel& ch = *(channel*)at.userdata;
		if (text == "\1russian-scrollback")
		{
			auto fn = [](chatbase_impl* self, channel& ch) -> async<void> {
				self->set_scrollback_notice(ch, 2);
				mid prev_pos = ch.scrollback_pos;
				co_await self->request_scrollback(ch);
				if (ch.scrollback_partial && prev_pos == ch.scrollback_pos)
					self->set_scrollback_notice(ch, 3);
				else if (ch.scrollback_partial)
					self->set_scrollback_notice(ch, 1);
				else
					self->set_scrollback_notice(ch, 0);
			};
			this->m_misc_waiters.add(fn(this, ch));
		}
		// todo: other ilinks
	}
	
	// not the fastest, but good enough
	ssize_t message_idx_or(arrayview<message> ms, midref id, ssize_t def)
	{
		for (size_t n=0;n<ms.size();n++)
		{
			if (ms[n].id == id)
				return n;
		}
		return def;
	}
	
	message* message_or_null(arrayvieww<message> ms, midref id)
	{
		for (size_t n=0;n<ms.size();n++)
		{
			if (ms[n].id == id)
				return &ms[n];
		}
		return nullptr;
	}
	
	message& insert_message(channel& ch, size_t idx, cstring before, message& m)
	{
		message& newm = ch.messages.insert(idx, std::move(m));
		array<span> spans = this->message_render(ch, newm);
		chanbase::importance_t imp = this->message_importance(ch, m);
		if (ch.host)
			ch.host->message_before(before, id_to_string(newm.id), imp, UNWRAP(newm.time).sec, spans);
		log_message(ch, UNWRAP(newm.time).sec, spans, false);
		return newm;
	}
	
	// todo: should never show if that's a dm
	bool show_channel_initial(channel& ch)
	{
		time_t now = time(nullptr);
		for (size_t n=ch.messages.size();n>0;n--)
		{
			message& m = ch.messages[n-1];
			if (UNWRAP(m.time).sec <= now-16*3600)
				return false;
			if (show_channel_for(ch, m))
				return true;
		}
		return false;
	}
	
	// todo: should show for my own messages, but not if an ignored user speaks
	bool show_channel_for(channel& ch, message& m)
	{
		return this->message_importance(ch, m) > chanbase::imp_none;
	}
	
	void append_message(channel& ch, message& m)
	{
		// to avoid trouble if the same message shows up in scrollback_segment then websocket
		message* prev = message_or_null(ch.messages, m.id);
		if (prev)
		{
			return edit_message(ch, *prev, m, false);
		}
		
		if (show_channel_for(ch, m))
			show_channel(ch); // must show before appending message, so channel unread state is set properly
		
		if (ch.scrollback_partial && ch.scrollback_pos == midref{})
			ch.scrollback_pos = m.id;
		
		insert_message(ch, ch.messages.size(), "", m);
	}
	
	// prevmsg must be in ch.messages, newmsg must be elsewhere
	void edit_message(channel& ch, message& prevmsg, message& newmsg, bool known_edited)
	{
		size_t editspan;
		array<span> sp_prev = this->message_render(ch, prevmsg, &editspan);
		array<span> sp_new = this->message_render(ch, newmsg, &editspan);
		
		bool edited = (known_edited || !spans_eq(sp_prev, sp_new));
		
		if (edited && show_channel_for(ch, newmsg))
			show_channel(ch); // must show before editing prevmsg, otherwise old one won't show up
		
		// mostly unnecessary if not edited, but maybe there's something invisible
		newmsg.id = std::move(prevmsg.id); // in case scrollback_pos or something points to here
		prevmsg = std::move(newmsg);
		
		if (!edited)
			return;
		
		if (ch.host)
			ch.host->message_edit(id_to_string(prevmsg.id), UNWRAP(prevmsg.time).sec, sp_new, editspan);
		
		log_message(ch, UNWRAP(prevmsg.time).sec, sp_new, true, editspan);
	}
	
	void edit_message(channel& ch, message& newmsg, bool known_edited)
	{
		message* prev = message_or_null(ch.messages, newmsg.id);
		if (prev && UNWRAP(prev->time).sec > time(nullptr) - 4*3600)
		{
			edit_message(ch, *prev, newmsg, known_edited);
		}
		else
		{
			if (show_channel_for(ch, newmsg))
				show_channel(ch);
			
			size_t editspan;
			array<span> spans = this->message_render(ch, newmsg, &editspan);
			
			spans[editspan].text = "EDIT: ";
			if (ch.host)
			{
				chanbase::importance_t imp = this->message_importance(ch, newmsg);
				// don't give it an ID, it'd screw up if edited twice
				ch.host->message(imp, UNWRAP(newmsg.time).sec, spans);
			}
			
			log_message(ch, UNWRAP(newmsg.time).sec, spans, true, editspan);
			
			if (prev)
			{
				newmsg.id = std::move(prev->id); // in case scrollback_pos or something points to here
				*prev = std::move(newmsg);
			}
		}
	}
	
	void delete_message(channel& ch, midref mr)
	{
		ssize_t idx = message_idx_or(ch.messages, mr, -1);
		if (idx < 0)
			return;
		
		if (ch.host)
			ch.host->message_delete(id_to_string(mr));
		ch.messages.remove(idx);
	}
	
	// The array must be sorted with the oldest message first.
	void scrollback_segment(channel& ch, arrayvieww<message> ms)
	{
		if (!ms)
			return; // shouldn't happen
		size_t insert_at_idx = message_idx_or(ch.messages, ch.scrollback_pos, ch.messages.size());
		mid insert_at = ch.scrollback_pos;
		string insert_at_str = id_to_string(insert_at);
		midref new_scrollback_pos = ms[0].id;
		if (insert_at_idx > 0 && UNWRAP(ms[0].time) + duration::ms(30000) < UNWRAP(ch.messages[insert_at_idx-1].time))
		{
			ch.scrollback_partial = false;
		}
		else
		{
			ch.scrollback_pos = midref();
		}
		for (message& m : ms)
		{
			ssize_t existing_msg = message_idx_or(ch.messages, m.id, -1);
			if (existing_msg >= 0)
			{
				// todo: this is wrong if
				// - client thinks latest message is 100
				// - server says latest is 200
				// - client asks for the latest 50 messages
				// - client sees message 201 in websocket
				// - client gets messages 152-201 in response
				// that case is exceedingly unlikely, since standard scrollback loading blocks the websocket coroutine
				// but it is possible if the channel is muted, and user manually clicks the fetch button
				ch.scrollback_partial = false;
				edit_message(ch, ch.messages[existing_msg], m, false);
			}
			else
			{
				if (show_channel_for(ch, m))
					show_channel(ch);
				insert_message(ch, insert_at_idx, insert_at_str, m);
				insert_at_idx++;
			}
		}
		// must be down here, so scrollback_notice isn't inserted at a message that doesn't exist yet
		ch.scrollback_pos = new_scrollback_pos;
	}
	
	static string log_name_for(cstring name)
	{
		string name_fn = "";
		for (size_t i=0;i<name.length();i++)
		{
			if (name[i] == '/') {}
			else if (name[i] == '.' && !name_fn) {}
			else name_fn += name[i];
		}
		if (!name_fn) name_fn = "_";
		return name_fn;
	}
	
	void log_message(channel& ch, time_t at, arrayview<span> spans, bool is_edit, size_t editspan = 0)
	{
		augmented_channel& ach = augment(ch);
		
		if (!ach.log_file || at >= ach.log_rotate_at)
		{
			group* parent = parent_for(ch); // should always exist
			string root_fn = log_name_for(parent->get_name());
			string chan_fn = log_name_for(UNWRAP(ch.name));
			
			file::mkdir(file::exedir()+"logs/");
			file::mkdir(file::exedir()+"logs/"+root_fn+"/");
			
			struct tm stm;
			localtime_r(&at, &stm);
			
			char timebuf[64];
			strftime(timebuf, sizeof(timebuf), " %Y-%m", &stm);
			ach.log_file.open(file::exedir()+"logs/"+root_fn+"/"+chan_fn+timebuf+".log", file::m_write);
			ach.log_file.seek(ach.log_file.size());
			
			stm.tm_sec = 0;
			stm.tm_min = 0;
			stm.tm_hour = 0;
			stm.tm_mday = 1;
			stm.tm_mon++;
			if (stm.tm_mon == 12)
			{
				stm.tm_year++;
				stm.tm_mon = 0;
			}
			
			ach.log_rotate_at = mktime(&stm);
		}
		
		string tmp;
		if (at != 0) tmp = "["+time_to_str(at, "%Y-%m-%d %H:%M:%S")+"] ";
		for (size_t i=0;i<spans.size();i++)
		{
			tmp += spans[i].text.replace("\n", "\n               ");
			if (is_edit && i == editspan)
				tmp += "EDIT: ";
		}
		tmp += "\n";
		
		ach.log_file.write(tmp);
	}
	
	void channel_member_join(channel& ch, user& u)
	{
		// todo:
		// - this screws up if a user is renamed
		// - double clicking a user should pass user*, not name
		// - only active users (one message in two weeks, maybe?) should show up, and currently typing should be on top
		// - may be trouble if user list is thousands of entries in a big discord guild (though if so, server won't send user list at all...)
		// I'll need to rewrite the user list handler entirely
		if (ch.host)
			ch.host->user_add(UNWRAP(u.name));
		ch.members.add(&u);
	}
	void channel_member_leave(channel& ch, user& u)
	{
		if (ch.host)
			ch.host->user_del(UNWRAP(u.name));
		ch.members.remove(&u);
	}
	
	// todo: move this function somewhere better
	static bool spans_eq(arrayview<span> a, arrayview<span> b)
	{
		if (a.size() != b.size())
			return false;
		
		for (size_t i=0;i<a.size();i++)
		{
			if (!a[i].equal(b[i]))
				return false;
		}
		
		return true;
	}
};

// todo: serialize user/channel references as integer indices instead, to save some space in json and to speed up program start
// (maybe. only after I've finished everything more important, and I've checked if that part has a performance impact)
template<typename Tp, bool is_uid>
class ser_id_t {
	using Tobj = std::conditional_t<is_uid, typename Tp::user, typename Tp::channel>;
	using Tid = std::conditional_t<is_uid, typename Tp::uidref, typename Tp::cidref>;
	Tobj*& obj;
	Tp* parent;
	
public:
	using serialize_as = Tid;
	ser_id_t(Tobj*& obj, Tp* parent) : obj(obj), parent(parent) {}
	void operator=(const Tid& id) const // const here is kinda ugly, but the ser_user return value is a temporary
	{
		if constexpr (is_uid)
			obj = &parent->user_for(id);
		else
			obj = &parent->channel_for(id);
	}
	operator Tid() const { return obj->id; }
};
// usage:
// s.item("author", ser_user(parent, this->author));
template<typename Tp> auto ser_user(   Tp* parent, typename Tp::user*&    u) { return ser_id_t<Tp, true >(u, parent); }
template<typename Tp> auto ser_channel(Tp* parent, typename Tp::channel*& u) { return ser_id_t<Tp, false>(u, parent); }
template<typename Tp, typename Tc, bool is_uid>
class ser_id_list_t {
	using Tobj = std::conditional_t<is_uid, typename Tp::user, typename Tp::channel>;
	using Tid = std::conditional_t<is_uid, typename Tp::uidref, typename Tp::cidref>;
	Tc& container;
	Tp* parent;
	
public:
	ser_id_list_t(Tc& container, Tp* parent) : container(container), parent(parent) {}
	void serialize(auto& s) const
	{
		if constexpr (s.serializing)
		{
			s.enter_array();
			for (Tobj* item : container)
				s.item(ser_id_t<Tp, is_uid>(item, parent));
			s.exit_array();
		}
		else
		{
			SER_ENTER_ARRAY(s)
			{
				Tobj* item;
				s.item(ser_id_t<Tp, is_uid>(item, parent));
				if constexpr (requires { container.append(item); }) // array
					container.append(item);
				else if constexpr (requires { container.add(item); }) // set
					container.add(item);
				else static_assert(sizeof(s) < 0);
			}
		}
	}
};
template<typename Tp, typename Tc> auto ser_users(Tp* parent, Tc& us) requires requires { us.begin(); }
{
	return ser_id_list_t<Tp, Tc, true>(us, parent);
}

template<typename Ts, typename Ti>
array<Ti>& ser_tail(Ts& s, array<Ti>& arr, size_t n) requires (!Ts::serializing)
{
	return arr;
}
template<typename Ts, typename Ti>
arrayview<Ti> ser_tail(Ts& s, array<Ti>& arr, size_t n) requires (Ts::serializing)
{
	size_t len = arr.size();
	if (len > n)
		return arr.slice(len-n, n);
	else
		return arr;
}

template<typename Ts, typename Ti>
array<Ti>& ser_messages(Ts& s, array<Ti>& arr) requires (!Ts::serializing)
{
	return arr;
}
template<typename Ts, typename Ti>
arrayview<Ti> ser_messages(Ts& s, array<Ti>& messages) requires (Ts::serializing)
{
	time_t now = time(nullptr);
	size_t n_msgs = 5; // always keep at least five messages
	if (messages.size() >= 1 && UNWRAP(messages[messages.size()-1].time).sec > now-365*86400)
		n_msgs = 75; // if latest message exists and is less than a year old, keep 75 messages
	if (messages.size() >= 200 && UNWRAP(messages[messages.size()-200].time).sec > now-48*3600)
		n_msgs = 200; // if at least 200 messages, and first minus 200 is less than 48 hours old, keep 200
	return ser_tail(s, messages, n_msgs);
}

#undef UNWRAP

}
