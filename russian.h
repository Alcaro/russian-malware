#pragma once
#include "arlib.h"

#include "inputview.h"
#include "chanview.h"
#include "textview.h"
#include "userview.h"

//don't know if this is guaranteed stable, but I'd rather not include the gtk header here
typedef struct _GtkGrid GtkGrid;

#define APPNAME "ЯUSSIAN MALWДRE"

namespace russian {
class chanbase;
class channel;
class group;
class protocol;
class impl;

using span = textview::span;

class chanbase : nocopy {
	friend class impl;
	friend class channel;
	friend class group;
	friend class protocol;
	
private:
	protocol* parent;
	group* pgroup;
	
	chanview::chanbase* cvb;
	GtkGrid* grid;
	textview* tv;
	userview* uv;
	inputview* iv;
	
public:
	enum flags_t {
		f_no_focus      = 0x0001, // Messages and users are not allowed in unfocusable channels. They can have children and be renamed.
		f_no_logs       = 0x0002, // Blocks both reading and writing logs.
		f_no_scrollback = 0x0004, // Logs are written, but not read to produce a scrollback; protocol keeps scrollback in some other way.
		f_no_users      = 0x0008,
		f_hidden        = 0x00010000, // This just affects the default state. Channels only, not groups.
	};
private:
	uint32_t flags;
	bool hidden = false;
	
	uintptr_t userdata;
	
	string name;
	string name_fn;
	
	file logfile;
	time_t logrotate = 0;
	time_t last_activity = 0;
	
	bool now_at_bottom = true;
	
	void tv_scroll_cb(bool now_at_bottom);
	void input_cb(cstring text);
	void uv_activate_cb(cstring name);
	
	static time_t month_prev(time_t t); // These three return 20xx-xx-01 00:00:00.
	static time_t month_start(time_t t);
	static time_t month_next(time_t t);
	void log_open(file& f, time_t at, bool create) const; // Does not seek to the end, it remains at the start.
	void log(time_t at, arrayview<span> spans);
	
public:
	//imp_scrollback is like imp_none, but not logged, and marked read immediately if the prior message was read.
	//imp_idle is for internal use only.
	enum importance_t { imp_idle=-2, imp_scrollback=-1, imp_none=0, imp_status=1, imp_msg=2, imp_highlight=3 };
private:
	importance_t cvb_imp = imp_none; // imp_idle if no activity for 30min, and marked read; can't be imp_scrollback
	void set_color()
	{
		static const uint32_t colors[] = { (uint32_t)-1, 0x990000, 0xFF0000, 0x00C0FF };
		if (cvb_imp == chanbase::imp_idle)
			cvb->color_fg(0x666666);
		else
			cvb->color_fg(colors[cvb_imp]);
	}
	void message_at(cstring prev, bool after, cstring newid, bool is_scrollback, importance_t imp, time_t at, arrayview<span> spans);
public:
	
	//An ID, if provided, allows the message to be edited or deleted.
	//IDs can be any alphanumeric string, plus dash and underscore.
	//IDs may not be reused within a channel, unless message_delete_true is used.
	void message(importance_t imp, time_t at, arrayview<span> spans) { message("", imp, at, spans); }
	void message(cstring id, importance_t imp, time_t at, arrayview<span> spans) { message_at("", false, id, imp, at, spans); }
	//Inserts a new message before or after 'prev', which must exist.
	//Importance should be imp_scrollback if the message was seen previously, imp_none if it's by the program's user,
	// or imp_msg if the message was sent since the protocol was last instantiated.
	void message_at(cstring prev, bool after, cstring newid, importance_t imp, time_t at, arrayview<span> spans)
	{
		message_at(prev, after, newid, (imp == imp_scrollback), (imp == imp_scrollback ? imp_none : imp), at, spans);
	}
	//These two replace an existing message. The old version stays around, but is deemphasized.
	//If the message doesn't exist, it's put at the bottom, prefixed with EDIT:. This can happen if an old message was edited.
	//The editslot must be an empty span. It's replaced with the EDIT: message, if needed. Can be formatted.
	void message_edit(cstring id, time_t at, arrayview<span> spans, unsigned editslot);
	void message_delete(cstring id, time_t at);
	//These are the same as the above, but don't leave the deemphasized versions around. For the latter, IDs can be reused afterwards.
	//ID must previously exist.
	void message_edit_true(cstring id, time_t at, arrayview<span> spans);
	void message_delete_true(cstring id) { tv->message_delete(id); }
	//Replaces every instance of 'prev' with 'next' in the given message. Message must exist.
	void message_replace_image(cstring id, textview::image* prev, textview::image* next);
	bool message_exists(cstring id) { return tv->message_exists(id); }
	
	//Adding or deleting users that already exist or don't exist isn't recommended, but works and does nothing.
	void user_add(cstring user) { uv->add(user); }
	void user_del(cstring user) { uv->remove(user); }
	void user_clear() { uv->clear(); } // Deletes all users.
	bool user_exists(cstring user) { return uv->contains(user); }
	auto users() -> iterwrap<decltype(uv->begin())> { return iterwrap<decltype(uv->begin())>(*uv); }
	
	//The original name remains used for logs.
	void rename(cstring newname);
	
	//Unavailable channels are rendered with strikethrough in the channel list. The channel starts out available.
	void set_available(bool available) { cvb->set_strike((flags&f_no_focus) || !available); }
	
	//Newly created channels are not focused.
	//Only call this as a result of explicit user action (the virtual functions in your protocol object),
	// never as a result of network activity.
	void focus() { cvb->focus(); }
	
	~chanbase();
private:
	void set_name();
	chanbase(protocol* parent, group* pgroup, cstring name, uint32_t flags, uintptr_t userdata);
};
class channel : public chanbase {
	friend class group;
	channel(protocol* parent, group* pgroup, chanview::group* pchan, cstring name, uint32_t flags, uintptr_t userdata);
public:
	//Channels are sorted by sort key, then the sort name. If the sort name is blank, the visible name is used.
	//Groups are sorted by creation order.
	void sort_as(cstring name) { sort_as(0, name); }
	void sort_as(int key, cstring name) { cvb->sort_as(key, name); }
	
	//Hidden channels can be revealed at any time. Default is visible.
	bool is_hidden() const { return this->hidden; }
	void set_hidden(bool hidden) { this->hidden = hidden; ((chanview::channel*)cvb)->set_hidden(hidden); }
};

class group : public chanbase {
	friend class protocol;
	friend class impl;
	group(protocol* parent, cstring name, uint32_t flags, uintptr_t userdata);
	chanbase* last_focus;
	
public:
	channel* child(cstring name, uintptr_t userdata)
	{
		return new channel(parent, this, (chanview::group*)cvb, name, 0, userdata);
	}
	channel* child(cstring name, uint32_t flags, uintptr_t userdata)
	{
		return new channel(parent, this, (chanview::group*)cvb, name, flags, userdata);
	}
	
	//A temporary message is not logged, and shows up in the currently active (or last focused) channel in the group.
	//Do not use imp_scrollback.
	void message_temp(importance_t imp, time_t at, arrayview<span> spans)
	{
		last_focus->message_at("", false, "", true, imp, at, spans);
	}
};


class protocol : public nocopy {
	// nocopy must be public, so things implementing protocol can use nocopy themselves
	// no clue what exact rules of C++ would cause such a strange restriction,
	//  private inheritance isn't supposed to be noticable by subclasses
	
	friend class group;
	friend class chanbase;
	
	impl* parent;
	uint32_t valid_fmt;
	
	protocol() = delete;
	
protected:
	//valid_fmt must be the color codes this one supports. (Their large values are chosen deliberately.)
	//0 is valid.
	protocol(impl* parent, uint32_t valid_fmt) : parent(parent), valid_fmt(valid_fmt) {}
	enum : uint32_t {
		fmt_b = 1u<<0x02,
		fmt_k = 1u<<0x03,
		fmt_o = 1u<<0x0F,
		fmt_m = 1u<<0x11,
		fmt_i = 1u<<0x1D,
		fmt_s = 1u<<0x1E,
		fmt_u = 1u<<0x1F,
	};
	
public:
	//Userdata should be unique unless the f_no_focus flag is set, otherwise ignored.
	//Can be whatever you want, including a casted pointer.
	group* mkgroup(cstring name, uintptr_t userdata)
	{
		return new group(this, name, 0, userdata);
	}
	group* mkgroup(cstring name, uint32_t flags, uintptr_t userdata)
	{
		return new group(this, name, flags, userdata);
	}
	
	//If your protocol wants to render images in the text, make sure they're this size or smaller, so line size remains constant.
	unsigned get_line_height();
	
	//An action is anything typed into the input box.
	virtual void action(cstring text, uintptr_t userdata) = 0;
	
	//Used when double clicking someone in the user list.
	virtual void begin_private(cstring name) = 0;
	
	virtual void close_chan(uintptr_t userdata) = 0;
	
	//Only PNG available for now, since no protocol needs anything else.
	//Yes, the interface sucks, and causes bugs (things get repainted before callback is called, giving visible flicker).
	//Ask GTK why it is that way. (They'll probably tell you to ask X11.)
	void clipboard_get_image_png(function<void(arrayview<byte>)> callback);
	
	////If an image is requested, call image_resolve with the given ID at some point. 'result' should be a PNG or other image file.
	////ID is whatever you passed in {channel,group}::message, and can be (for example) a HTTP address.
	////Requesting the same file twice should give the same result. If the image is no longer accessible, resolve with a blank array.
	//virtual void image_req(cstring id) {}
	//void image_resolve(cstring id, arrayview<byte> result);
	
	virtual ~protocol() {}
	
	//Pass the parent parameter to the 'protocol' constructor. Don't do anything else with it.
	//Config parameters are given via the serializer. You're required to read them using
	// s.item("name", *this) or ser_enter(s) (though your ser_enter() body may be blank),
	// otherwise your handler may be instantiated multiple times.
	//No runloop is provided, use the global one.
	static protocol* create_testp(impl* parent, bmldeserializer& s);
	static protocol* create_discord(impl* parent, bmldeserializer& s);
	static protocol* create_irc(impl* parent, bmldeserializer& s);
	
	//There are things the protocol handler doesn't know, for example what channel is currently active.
	//They will be added if I deem it appropriate.
};
}
