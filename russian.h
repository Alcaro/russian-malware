#pragma once
#include "arlib.h"

#include "chanview.h"
#include "textview.h"

namespace russian {
class chanbase;
class channel;
class group;
class protocol;
class impl;

using span = textview::span;

class chanbase : nocopy {
	friend class impl;
protected:
	protocol* parent;
	textview::buffer* buf;
	chanview::chanbase* cvb;
	void* userdata;
	
	friend class channel;
	friend class group;
public:
	//The protocol is expected to format its own message, except the timestamp.
	//TODO: importance (join, message, highlight)
	//TODO: cross-channel message (join)
	//TODO: another kind of span, for the image request protocol
	void message(time_t at, arrayview<span> spans) { message("", at, spans); }
	//An ID, if provided, allows the message to be edited or deleted (latter by using a blank spans array).
	void message(cstring id, time_t at, arrayview<span> spans);
	
	virtual ~chanbase() {}
	
	chanbase(protocol* parent, void* userdata);
};
class channel : public chanbase {
public:
	channel(protocol* parent, chanview::group* pchan, cstring name, void* userdata);
};

class group : public chanbase {
public:
	group(protocol* parent, cstring name, void* userdata);
	channel* child(cstring name, void* userdata) { return new channel(parent, (chanview::group*)cvb, name, userdata); }
};

//A protocol implementation is expected to use the global runloop.
class protocol : nocopy {
	friend class group;
	friend class chanbase;
	
	impl* parent;
	protocol();
	
protected:
	protocol(impl* parent) : parent(parent) {}
	
public:
	//If userdata is NULL, the group root can't be focused. Use if there is no obvious equivalent of IRC's server tab.
	//Use whatever pointer you want, it doesn't make any difference.
	group* mkgroup(cstring name, void* userdata) { return new group(this, name, userdata); }
	
	//An action is anything typed into the input box.
	virtual void action(cstring text, void* userdata) = 0;
	
	//If an image is requested, call image_resolve with the given ID at some point.
	//ID is whatever you passed in {channel,group}::message, and can be (for example) a HTTP address.
	//Requesting the same file twice should give the same result. If the image is no longer accessible, resolve with a blank array.
	virtual void image_req(cstring id) {}
	void image_resolve(cstring id, arrayview<byte> result);
	
	virtual ~protocol() {}
	
	//Pass the parent parameter to the 'protocol' constructor. Don't do anything else with it.
	//You're welcome to read config parameters from the given serializer. Recommended usage: s.item("name", *this);
	static protocol* create_testp(impl* parent, bmlunserialize_impl& s);
	static protocol* create_discord(impl* parent, bmlunserialize_impl& s);
	static protocol* create_irc(impl* parent, bmlunserialize_impl& s);
};
}
