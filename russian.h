#pragma once
#include "arlib.h"

#include "inputview.h"
#include "chanview.h"
#include "textview.h"
#include "userview.h"

namespace russian {
class chanbase;
class channel;
class group;
class protocol;
class impl;

using span = textview::span;

class chanbase : nocopy {
	friend class impl;
	friend class channel;
	friend class group;
	
private:
	protocol* parent;
	group* pgroup;
	textview::buffer* buf;
	chanview::chanbase* cvb;
	
public:
	enum flags_t {
		f_no_focus = 0x0001, // Messages and users are not allowed in unfocusable channels. They may have children and be renamed.
		f_no_logs  = 0x0002,
		f_no_users = 0x0004, // TODO: unimplemented
	};
private:
	uint32_t flags;
	
	userview::data userdat;
	inputview::state inputst;
	void* userdata;
	
	string name;
	string name_fn;
	
	file logfile;
	time_t logrotate = 0;
	
	static time_t month_prev(time_t t); // All of these return 20xx-xx-01 00:00:00.
	static time_t month_start(time_t t);
	static time_t month_next(time_t t);
	void log_open(file& f, time_t at, bool create) const; // Does not seek to the end, it remains at the start.
	void log(time_t at, arrayview<span> spans);
	
public:
	enum importance_t { imp_none, imp_status, imp_msg, imp_highlight };
private:
	importance_t cvb_imp = imp_none;
public:
	
	//TODO: cross-channel message (join)
	//TODO: another kind of span, for the image request protocol
	void message(importance_t imp, time_t at, arrayview<span> spans) { message("", imp, at, spans); }
	//An ID, if provided, allows the message to be edited or deleted.
	//IDs can be any alphanumeric string, plus dash and underscore.
	//If the same ID is sent to multiple channels, it's a cross-post; reading it in one channel marks it read in all others.
	//If the same ID is sent multiple times to the same channel, including if the old one was deleted, undefined behavior.
	// Use message_edit/delete instead, or a better ID generation policy.
	void message(cstring id, importance_t imp, time_t at, arrayview<span> spans);
	//These two replace an existing message. The old version stays around, but is deemphasized.
	//If the message doesn't exist, it's put at the bottom, prefixed with EDIT:. This can happen if an old message was edited.
	//The editslot must be an empty span. It's replaced with the EDIT: message, if needed.
	void message_edit(cstring id, time_t at, arrayview<span> spans, unsigned editslot);
	void message_delete(cstring id, time_t at);
	//This fully deletes a message. Use it for temporary status messages. IDs can be reused after this.
	void message_delete_true(cstring id);
	
	//Adding or deleting users that already exist or don't exist isn't recommended, but works and does nothing.
	void user_add(cstring user);
	void user_del(cstring user);
	void user_clear(); // Deletes all users.
	bool user_exists(cstring user);
	auto users() -> iterwrap<decltype(userdat.begin())> { return iterwrap<decltype(userdat.begin())>(userdat); }
	
	////The channel status is a temporary message printed at the bottom.
	////If !available, a 'Disconnected' is printed. The channel name is also surrounded in parentheses.
	////If available && !had_gap, the 'Disconnected' message (if any) is removed.
	////If available && had_gap, a 'Now talking on' message is printed.
	////A channel starts out unavailable.
	//void set_available(time_t at, bool available);
	//void status(time_t at, bool available, arrayview<span> spans);
	
	//The original name remains used for logs.
	void rename(cstring newname);
	
private:
	chanbase(protocol* parent, group* pgroup, cstring name, uint32_t flags, void* userdata);
};
class channel : public chanbase {
	friend class group;
	channel(protocol* parent, group* pgroup, chanview::group* pchan, cstring name, uint32_t flags, void* userdata);
};

class group : public chanbase {
	friend class protocol;
	friend class impl;
	group(protocol* parent, cstring name, uint32_t flags, void* userdata);
	chanbase* last_focus;
	
public:
	channel* child(cstring name, void* userdata)
	{
		return new channel(parent, this, (chanview::group*)cvb, name, 0, userdata);
	}
	channel* child(cstring name, uint32_t flags, void* userdata)
	{
		return new channel(parent, this, (chanview::group*)cvb, name, flags, userdata);
	}
	
	//A temporary message is not logged, and shows up in the currently active (or last focused) channel in the group.
	void message_temp(importance_t imp, time_t at, arrayview<span> spans);
};


class protocol : nocopy {
	friend class group;
	friend class chanbase;
	
	impl* parent;
	protocol();
	
protected:
	protocol(impl* parent) : parent(parent) {}
	
public:
	//Use whatever pointer you want, it doesn't make any difference.
	group* mkgroup(cstring name, void* userdata)
	{
		return new group(this, name, 0, userdata);
	}
	group* mkgroup(cstring name, uint32_t flags, void* userdata)
	{
		return new group(this, name, flags, userdata);
	}
	
	//An action is anything typed into the input box.
	virtual void action(cstring text, void* userdata) = 0;
	
	//If an image is requested, call image_resolve with the given ID at some point. 'result' should be a PNG or other image file.
	//ID is whatever you passed in {channel,group}::message, and can be (for example) a HTTP address.
	//Requesting the same file twice should give the same result. If the image is no longer accessible, resolve with a blank array.
	virtual void image_req(cstring id) {}
	void image_resolve(cstring id, arrayview<byte> result);
	
	virtual ~protocol() {}
	
	//Pass the parent parameter to the 'protocol' constructor. Don't do anything else with it.
	//Config parameters are given via the serializer. You're required to read them using
	// s.item("name", *this) or ser_enter(s) (though your ser_enter() body may be blank),
	// otherwise your handler may be instantiated multiple times.
	//No runloop is provided, use the global one.
	static protocol* create_testp(impl* parent, bmlunserialize_impl& s);
	static protocol* create_discord(impl* parent, bmlunserialize_impl& s);
	static protocol* create_irc(impl* parent, bmlunserialize_impl& s);
};

void do_irc_bouncer(cstring path);
}
