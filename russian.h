#pragma once
#include "arlib.h"

#include "chanview.h"
#include "textview.h"

namespace russian {
class chanbase;
class channel;
class group;
class protocol;
class impl;

using span = textview::span;

class chanbase : nocopy {
	friend class impl;
protected:
	protocol* parent;
	textview::buffer* buf;
	chanview::chanbase* cvb;
	string input_text;
	size_t input_pos = 0;
	void* userdata;
	
	string name;
	
	friend class channel;
	friend class group;
public:
	//TODO: importance (join, message, highlight)
	//TODO: cross-channel message (join)
	//TODO: another kind of span, for the image request protocol
	void message(time_t at, cstring source, arrayview<span> spans) { message("", at, source, spans); }
	//An ID, if provided, allows the message to be edited or deleted.
	//IDs can be any ASCII string (20-7E), except that they may not start with @russian::.
	//If the same ID is sent to multiple channels, it's a cross-post; reading it in one channel marks it read in all others.
	//If the same ID is sent multiple times to the same channel, including if the old one was deleted, undefined behavior.
	//Use message_edit/delete instead, or a less absurd ID generation policy.
	void message(cstring id, time_t at, cstring source, arrayview<span> spans);
	//These two replace an existing message. The old version stays around, but is deemphasized.
	//If the message doesn't exist, undefined behavior.
	void message_edit(cstring id, time_t at, cstring source, arrayview<span> spans);
	void message_delete(cstring id, time_t at);
	//This fully deletes a message. Use it for temporary status messages.
	void message_delete_true(cstring id);
	
	//The channel status is a temporary message printed at the bottom.
	//If !available, a 'Disconnected' is printed. The channel name is also surrounded in parentheses.
	//If available && !had_gap, the 'Disconnected' message (if any) is removed.
	//If available && had_gap, a 'Now talking on' message is printed.
	//A channel starts out unavailable.
	void set_available(time_t at, bool available);
	void status(time_t at, bool available, arrayview<span> spans);
	
	virtual ~chanbase() {}
	
	chanbase(protocol* parent, cstring name, void* userdata);
};
class channel : public chanbase {
	friend class group;
	channel(protocol* parent, chanview::group* pchan, cstring name, void* userdata);
};

class group : public chanbase {
	friend class protocol;
	group(protocol* parent, cstring name, void* userdata);
public:
	channel* child(cstring name, void* userdata)
	{
		return new channel(parent, (chanview::group*)cvb, name, userdata);
	}
};


class protocol : nocopy {
	friend class group;
	friend class chanbase;
	
	impl* parent;
	protocol();
	
protected:
	protocol(impl* parent) : parent(parent) {}
	
public:
	//If userdata is NULL, the group root can't be focused. Use if there is no obvious equivalent of IRC's server tab.
	//Use whatever pointer you want, it doesn't make any difference.
	group* mkgroup(cstring name, void* userdata) { return new group(this, name, userdata); }
	
	//An action is anything typed into the input box.
	virtual void action(cstring text, void* userdata) = 0;
	
	//If an image is requested, call image_resolve with the given ID at some point.
	//ID is whatever you passed in {channel,group}::message, and can be (for example) a HTTP address.
	//Requesting the same file twice should give the same result. If the image is no longer accessible, resolve with a blank array.
	virtual void image_req(cstring id) {}
	void image_resolve(cstring id, arrayview<byte> result);
	
	virtual ~protocol() {}
	
	//Pass the parent parameter to the 'protocol' constructor. Don't do anything else with it.
	//Config parameters are given via the serializer. You're required to read them using
	// s.item("name", *this) or ser_enter(s) (though your ser_enter() body may be blank),
	// otherwise your handler may be instantiated multiple times.
	//No runloop is provided, use the global one.
	static protocol* create_testp(impl* parent, bmlunserialize_impl& s);
	static protocol* create_discord(impl* parent, bmlunserialize_impl& s);
	static protocol* create_irc(impl* parent, bmlunserialize_impl& s);
};
}
