#pragma once
#include "arlib.h"

#include "inputview.h"
#include "chanview.h"
#include "textview.h"
#include "userview.h"

//don't know if this is guaranteed stable, but I'd rather not include the gtk header here
typedef struct _GtkGrid GtkGrid;

#define APPNAME "UKЯAINIAN MALWДRE"

namespace russian {
class chanbase;
class channel;
class group;
class protocol;
class impl;

using span = textview::span;

class chanbase : nocopy {
	friend class impl;
	friend class channel;
	friend class group;
	friend class protocol;
	
private:
	protocol* parent;
	group* pgroup;
	
	chanview::chanbase* cvb;
	GtkGrid* grid;
	textview* tv;
	userview* uv;
	inputview* iv;
	
public:
	enum flags_t {
		f_no_focus      =     0x0001, // Messages and users are not allowed in unfocusable channels. They can have children and be renamed.
		f_no_logs       =     0x0002, // Blocks both reading and writing logs.
		f_no_scrollback =     0x0004, // Logs are written, but not read; protocol will produce its own scrollback.
		f_no_users      =     0x0008,
		f_less_indent   =     0x0010, // Removes indentation after \n in a message, and halves indentation after word wrap.
		f_hidden        = 0x00010000, // This just affects the default state. Channels only, not groups.
	};
	static_assert(chanbase::f_less_indent == textview::f_less_indent);
	
	anyptr userdata;
	bool is_group() { return (chanbase*)pgroup == this; }
	
private:
	uint32_t serial;
	
	uint32_t flags;
	bool hidden = false;
	
	string name;
	string name_fn;
	
	file logfile;
	time_t logrotate = 0;
	time_t last_activity = 0;
	
	bool now_at_bottom = true;
	
	static time_t month_prev(time_t t); // These three return 20xx-xx-01 00:00:00.
	static time_t month_start(time_t t);
	static time_t month_next(time_t t);
	void log_open(file& f, time_t at, bool create) const; // Does not seek to the end, it remains at the start.
	void log(time_t at, arrayview<span> spans);
	
public:
	// imp_scrollback is like imp_none, but not logged, and marked read immediately if the prior message was read.
	// imp_idle is for internal use only.
	enum importance_t { imp_idle=-2, imp_scrollback=-1, imp_none=0, imp_status=1, imp_msg=2, imp_highlight=3 };
private:
	importance_t cvb_imp = imp_none; // imp_idle if no activity for 30min, and marked read; can't be imp_scrollback
	void set_color()
	{
		static const uint32_t colors[] = { (uint32_t)-1, 0x990000, 0xFF0000, 0x00FF00 };
		if (cvb_imp == chanbase::imp_idle)
			cvb->color_fg(0x666666);
		else
			cvb->color_fg(colors[cvb_imp]);
	}
	void message_at(cstring prev, bool after, cstring newid, bool is_scrollback, importance_t imp, time_t at, arrayview<span> spans);
public:
	
	// An ID, if provided, allows the message to be edited or deleted.
	// IDs can be any alphanumeric string, plus dash and underscore.
	// IDs may not be reused within a channel, unless message_delete_true is used.
	void message(importance_t imp, time_t at, arrayview<span> spans) { message("", imp, at, spans); }
	void message(cstring id, importance_t imp, time_t at, arrayview<span> spans) { message_at("", false, id, imp, at, spans); }
	// Inserts a new message before or after 'prev', which must exist.
	// Importance should be imp_scrollback if the message was seen previously, imp_none if it's by the program's user,
	//  or imp_msg if the message was sent since the protocol was last instantiated.
	void message_at(cstring prev, bool after, cstring newid, importance_t imp, time_t at, arrayview<span> spans)
	{
		message_at(prev, after, newid, (imp == imp_scrollback), (imp == imp_scrollback ? imp_none : imp), at, spans);
	}
	void message_before(cstring prev, cstring newid, importance_t imp, time_t at, arrayview<span> spans)
	{
		message_at(prev, false, newid, (imp == imp_scrollback), (imp == imp_scrollback ? imp_none : imp), at, spans);
	}
	void message_after(cstring prev, cstring newid, importance_t imp, time_t at, arrayview<span> spans)
	{
		message_at(prev, true, newid, (imp == imp_scrollback), (imp == imp_scrollback ? imp_none : imp), at, spans);
	}
	// These two replace an existing message. The old version stays around, but is deemphasized.
	// If the message doesn't exist, it's put at the bottom, prefixed with EDIT:. This can happen if an old message was edited.
	// The editslot must be an empty span. It's replaced with the EDIT: message, if needed. Can be formatted.
	void message_edit(cstring id, time_t at, arrayview<span> spans, unsigned editslot);
	void message_delete(cstring id, time_t at);
	// These are the same as the above, but don't leave the deemphasized versions around. For the latter, IDs can be reused afterwards.
	// ID must previously exist.
	void message_edit_true(cstring id, time_t at, arrayview<span> spans);
	void message_delete_true(cstring id) { tv->message_delete(id); }
	// Replaces every instance of 'prev' with 'next' in the given message. Message must exist.
	void message_replace_image(cstring id, textview::image* prev, textview::image* next);
	bool message_exists(cstring id) { return tv->message_exists(id); }
	
	// Adding or deleting users that already exist or don't exist isn't recommended, but works and does nothing.
	void user_add(cstring user) { uv->add(user); }
	void user_del(cstring user) { uv->remove(user); }
	void user_clear() { uv->clear(); } // Deletes all users.
	bool user_exists(cstring user) { return uv->contains(user); }
	auto users() -> iterwrap<decltype(uv->begin())> { return iterwrap<decltype(uv->begin())>(*uv); }
	
	// The original name remains used for logs.
	void rename(cstring newname);
	
	// Unavailable channels are rendered with strikethrough in the channel list. The channel starts out available.
	void set_available(bool available) { cvb->set_strike((flags&f_no_focus) || !available); }
	
	// Newly created channels are not focused.
	// Only call this as a result of explicit user action (the virtual functions in your protocol object),
	//  never as a result of network activity.
	void focus() { cvb->focus(); }
	
	// Adds the given text to the start of the input field, or replaces the content completely.
	// As above, never call this as a result of network activity.
	void input_prefix(cstring text) { iv->text_prefix(text); }
	void input_replace(cstring text) { iv->text_replace(text); }
	
	~chanbase();
private:
	void set_name();
	chanbase(protocol* parent, group* pgroup, cstring name, uint32_t flags, anyptr userdata);
};
class channel : public chanbase {
	friend class group;
	channel(protocol* parent, group* pgroup, chanview::group* pchan, cstring name, uint32_t flags, anyptr userdata);
public:
	//Channels are sorted by sort key (ascending), then the sort name (ascending, case insensitive, bytewise (not natural)).
	//If the sort name is blank, the visible name is used.
	//Groups are sorted by creation order.
	void sort_as(cstring name) { sort_as(0, name); }
	void sort_as(int key, cstring name) { cvb->sort_as(key, name); }
	
	//Hidden channels can be revealed at any time. Default is visible.
	bool is_hidden() const { return this->hidden; }
	void set_hidden(bool hidden) { this->hidden = hidden; ((chanview::channel*)cvb)->set_hidden(hidden); }
};

class group : public chanbase {
	friend class protocol;
	friend class impl;
	group(protocol* parent, cstring name, uint32_t flags, anyptr userdata);
	chanbase* last_focus;
	
public:
	channel* child(cstring name, anyptr userdata)
	{
		return new channel(parent, this, (chanview::group*)cvb, name, 0, userdata);
	}
	channel* child(cstring name, uint32_t flags, anyptr userdata)
	{
		return new channel(parent, this, (chanview::group*)cvb, name, flags, userdata);
	}
	
	//A temporary message is not logged, and shows up in the currently active (or last focused) channel in the group.
	//Do not use imp_scrollback.
	void message_temp(importance_t imp, time_t at, arrayview<span> spans)
	{
		last_focus->message_at("", false, "", true, imp, at, spans);
	}
};


class protocol : public nocopy {
	// nocopy must be public, so things implementing protocol can use nocopy themselves
	// no clue what exact rules of C++ would cause such a strange restriction,
	//  private inheritance isn't supposed to be noticable by subclasses
	
	friend class group;
	friend class chanbase;
	
	impl* parent;
	uint32_t valid_fmt;
	
	protocol() = delete;
	
protected:
	// valid_fmt must be the color codes this one supports, OR'd together. (Their large values are chosen deliberately.)
	// 0 is valid. Setting any bits not present in this enum is undefined behavior.
	protocol(impl* parent, uint32_t valid_fmt) : parent(parent), valid_fmt(valid_fmt) {}
	enum : uint32_t {
		fmt_b = 1u<<0x02,
		fmt_k = 1u<<0x03,
		fmt_o = 1u<<0x0F,
		fmt_m = 1u<<0x11,
		fmt_i = 1u<<0x1D,
		fmt_s = 1u<<0x1E,
		fmt_u = 1u<<0x1F,
	};
	
public:
	// Userdata will be ignored if the f_no_focus flag is set.
	// Can be a casted integer if you'd prefer that.
	group* mkgroup(cstring name, anyptr userdata)
	{
		return new group(this, name, 0, userdata);
	}
	group* mkgroup(cstring name, uint32_t flags, anyptr userdata)
	{
		return new group(this, name, flags, userdata);
	}
	
	// If your protocol wants to render images in the text, make sure they're this size or smaller, so line size remains constant.
	unsigned get_line_height();
	
	// An action is anything typed into the input box.
	virtual void action(chanbase& at, cstring text) = 0;
	
	// Global actions allow a protocol to insert its commands into channels belonging to other protocols.
	// As such, the chanbase does not necessarily belong to this protocol, and its userdata may not be touched.
	enum ga_handle_t { ga_handled, ga_not_handled };
	virtual ga_handle_t global_action(chanbase& at, uint32_t serial, cstring text) { return ga_not_handled; }
	// If your global handler doesn't respond immediately, use this, to safeguard against the protocol deleting the channel.
	// Not needed within your own protocol handler.
	// If your global handler does respond immediately, it's safe to ignore the serial.
	bool channel_valid(chanbase* at, uint32_t serial);
	
	// The actions list will, by default, contain _Copy (possibly disabled),
	//  and (if applicable) link target (disabled), Open Link in Browser, and Copy Selected Link.
	// They can all be removed, if desired.
	// Can be modified, but the list should not be left empty.
	virtual void contextmenu(chanbase& at, cstring msgid, array<textview::ctxaction>& actions) {}
	
	virtual void ilink(string text) { abort(); }
	
	// Used when double clicking someone in the user list.
	virtual void begin_private(chanbase& at, cstring name) = 0;
	
	virtual void close_chan(chanbase& at) = 0;
	
	// Only PNG available for now, since no protocol needs anything else.
	// Yes, the interface sucks, and causes bugs (things get repainted before callback is called, giving visible flicker).
	// Ask GTK why it is that way. (They'll probably tell you to ask X11.)
	void clipboard_get_image_png(function<void(arrayview<uint8_t>)> callback);
	
	void clipboard_set_text(cstring text);
	
	// Tells the ЯUSSIAN MALWДRE frontend that you may have an internet outage, allowing automatic reset.
	// TODO: represent this in a less hardcoded and me-specific way
	void disconnected();
	
	void open_link(cstring url);
	void open_links(arrayview<cstring> urls);
	
	//Takes an http or https url. The returned image will be resized to the exact given size.
	//Will not necessarily send an HTTP request; things may be cached.
	//Will render transparently until fetched, then automatically change.
	//Calling the function twice with the same address will return the same image, not a copy. Do not delete the returned image.
	//Don't cache the image either; if it had to be fetched, it will be replaced later. After said replacement, the placeholder will be freed.
	textview::image* image_create_url(cstring addr, size_t width, size_t height);
	textview::image* image_create_url(cstring addr, size_t size) { return image_create_url(addr, size, size); }
	
	virtual ~protocol() {}
	
	// Pass the parent parameter to the 'protocol' constructor. Don't do anything else with it.
	// Config parameters are given via the serializer. No runloop is provided, use the global one.
	static protocol* create_testp(impl* parent, bmldeserializer& s, cstring name);
	static protocol* create_irc(impl* parent, bmldeserializer& s, cstring name);
	static protocol* create_matrix(impl* parent, bmldeserializer& s, cstring name);
	static protocol* create_discord(impl* parent, bmldeserializer& s, cstring name);
	static protocol* create_todo(impl* parent, bmldeserializer& s, cstring name);
	static protocol* create_webhook(impl* parent, bmldeserializer& s, cstring name);
	
	// There are things the protocol handler doesn't know, for example what channel is currently active.
	// They will be added if I deem it appropriate.
};

string time_to_str(time_t t, const char * fmt = NULL);

// The span array can be nonempty. If so, 'text' will be appended.
void parse_irc(array<span>& out, span fmt, cstring text);
}
