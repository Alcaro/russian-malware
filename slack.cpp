#include "chatbase.h"
#include "firefox.h"

namespace russian {
namespace {

class slack : public chatbase<slack> {
public:

using mid = timestamp;
using midref = timestamp;

template<typename Ts>
struct my_serializer : public Ts {
	slack* parent;
};
template<typename Ts>
static slack* this_from_serializer(Ts& serializer)
{
	return ((my_serializer<Ts>*)&serializer)->parent;
}

struct user {
	uid id;
	string name;
	bool used = false;
	
	void serialize(auto& s)
	{
		slack* parent = this_from_serializer(s);
		//if (s.serializing && !used && parent->m_online_ever)
			//return s.cancel();
		SER_ENTER(s)
		{
			s.item("name", name);
			//SER_IF(s, avatar) s.item("avatar", avatar);
		}
	}
};
struct message {
	mid id;
	user* author;
	timestamp time() { return id; }
	timestamp in_thread = {};
	string text;
	
	void serialize(auto& s)
	{
		slack* parent = this_from_serializer(s);
		SER_ENTER(s)
		{
			s.item("time", id);
			s.item("author", ser_user(parent, author));
			SER_IF(s, in_thread.sec != 0) s.item("thread", in_thread);
			s.item("text", text);
		}
	}
};
struct channel {
	cid id;
	string name;
	bool used = false;
	autoptr<russian::channel> host = nullptr;
	array<message> messages;
	
	bool scrollback_partial = false; // if false, the below member is empty or invalid
	midref scrollback_pos; // where to insert scrollback
	
	bool is_dm() const
	{
		return id[0] != 'C';
	}
	
	timestamp last_msg_at()
	{
		if (messages) return messages[messages.size()-1].time();
		else return { 0,0 };
	}
	
	message* find_by_id(midref id)
	{
		for (message& m : messages)
		{
			if (id == m.id)
				return &m;
		}
		return nullptr;
	}
	
	void serialize(auto& s)
	{
		slack* parent = this_from_serializer(s);
		// todo
		//if (s.serializing && !used && parent->m_online_ever)
			//return;
		SER_ENTER(s)
		{
			s.item("name", name);
			s.item("messages", ser_messages(s, messages));
		}
	}
};

string id_to_string(timestamp ts)
{
	if (ts.sec == 0)
		return "";
	char ret[64];
	sprintf(ret, "%zd.%06d", (size_t)ts.sec, (int)(ts.nsec/1000));
	return ret;
}

chanbase::importance_t message_importance(channel& ch, message& m)
{
	if (m.author == m_self)
		return chanbase::imp_none;
	if (m.text.contains(m_self->id))
		return chanbase::imp_highlight;
	return chanbase::imp_msg;
}

array<span> message_render(channel& ch, message& m, size_t* editspan = nullptr)
{
	bool highlight = (m.text.contains(m_self->id));
	uint32_t fgcol = highlight ? 0xFF0000 : -1;
	
	array<span> ret;
	ret.append({ .text="<"+m.author->name+"> ", .bold=highlight, .fgcol=fgcol });
	if (editspan)
	{
		*editspan = ret.size();
		ret.append();
	}
	if (m.in_thread.sec != 0)
	{
		ret.append({ .text="^"+time_to_str(m.in_thread.sec)+"\n", .fgcol=0xC04000 });
	}
	ret.append({ .text=m.text, .fgcol=fgcol });
	return ret;
}

autoptr<russian::group> m_root;

string m_api_addr; // https://slack.com/api/
string m_workspace_id; // T1234567890
string m_token_xoxc; // xoxc-1234567890123-4567890123456-7890123456789-0123456789abcdef0123456789abcdef
string m_cookie_xoxd; // xoxd-AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8= (but longer)
bool m_token_is_config;

http_t m_http;
websocket m_ws;

int m_connect_failures = 0;
bool m_online = false;
bool m_online_ever = false;
struct {
	timestamp expiry = {};
	string primary;
	string secondary;
	string gateway;
	string reconnect; // not serialized
	void serialize(auto& s)
	{
		s.items("primary", primary, "secondary", secondary, "gateway", gateway, "expiry", expiry);
	}
} m_ws_addr;

file m_rawlog;

user* m_self = nullptr;

string m_cachename;

void fatal(cstring text)
{
	span sp[1] = { { text } };
	sp[0].fgcol = 0xFF0000;
	m_root->message(chanbase::imp_highlight, time(NULL), sp);
	m_root->rename("ERROR - Slack");
	
	terminate();
}

slack(impl* parent) : chatbase(parent, 0) {}
void init(json5deserializer2& s)
{
	cstring email_addr;
	cstring rawlog_fname;
	cstring root_name;
	s.items(
		"name", root_name,
		"email", email_addr,
		"server", m_api_addr,
		"workspace", m_workspace_id,
		"xoxc", m_token_xoxc,
		"xoxd", m_cookie_xoxd,
		"rawlog", rawlog_fname,
		"cache", m_cachename);
	
	m_root = mkgroup(root_name, chanbase::f_no_logs|chanbase::f_no_users, nullptr);
	m_root->set_available(false);
	
	if (rawlog_fname)
		m_rawlog.open(file::resolve(file::exedir(), rawlog_fname), file::m_replace);
	m_cachename = file::resolve(file::exedir(), m_cachename);
	
	if (!m_api_addr)
	{
		fatal("Missing server in config");
		return;
	}
	if (!m_workspace_id.startswith("T"))
	{
		fatal("Missing workspace in config");
		return;
	}
	if (!email_addr)
	{
		fatal("Missing email in config"); // not actually used (yet?)
		return;
	}
	
	my_serializer<jsondeserializer2> sw = { file::readallt(m_cachename), this };
	process_cache(sw);
	
	auto tokens_are_valid = [this]() { return m_token_xoxc.startswith("xoxc-") && m_cookie_xoxd.startswith("xoxd-"); };
	
	m_token_is_config = tokens_are_valid();
	
	if (!m_token_is_config)
	{
		firefox_profile prof = firefox_profile::get_default();
		JSON json(prof.get_localstorage("app.slack.com", "localConfig_v2"));
		m_token_xoxc = json["teams"][m_workspace_id]["token"];
		m_cookie_xoxd = prof.get_cookie(".slack.com", "d");
	}
	if (!tokens_are_valid())
	{
		fatal("No token found");
		return;
	}
	
	m_http.wrap_socks(&autoproxy::socket_create_sslmaybe);
	m_ws.wrap_socks(&autoproxy::socket_create_sslmaybe);
}
void deinit()
{
	my_serializer<jsonserializer2> sw = { {}, this };
	process_cache(sw);
	file::writeall(m_cachename, sw.finish());
}

template<typename T> void process_cache(T& s)
{
	SER_ENTER(s)
	{
		s.item("self", ser_user(this, m_self));
		s.item("ws", m_ws_addr);
		s.item("users", users());
		s.item("channels", channels());
	}
}

string logdate(time_t rawtime)
{
	struct tm * timeinfo = localtime(&rawtime);
	char out[64];
	strftime(out, 64, "[%H:%M:%S]", timeinfo);
	return out;
}
string logdate()
{
	return logdate(time(NULL));
}

void status(time_t at, cstring text, chanbase::importance_t imp = chanbase::imp_status)
{
	span sp[1] = { { text } };
	if (imp == chanbase::imp_highlight) sp[0].fgcol = 0xFF0000;
	m_root->message(imp, at, sp);
}
void status(cstring text, chanbase::importance_t imp = chanbase::imp_status)
{
	status(time(NULL), text, imp);
}

async<http_t::rsp> http_api(cstring endpoint, http_t::form& f) // do not accept the form by value until gcc bug 98401 is fixed
{
	http_t::req q = { m_api_addr+endpoint };
	q.method = "POST";
	q.headers.append("Cookie: d="+http_t::urlencode(m_cookie_xoxd));
	f.value("token", m_token_xoxc);
	f.attach(q);
	http_rawlog(q);
	return m_http.request(q);
}
async<http_t::rsp> http_api(cstring endpoint)
{
	http_t::form f;
	return http_api(endpoint, f);
}

void http_rawlog(http_t::req& q)
{
	if (m_rawlog)
	{
		cstring method = (q.method ? q.method : q.body ? (cstring)"POST" : (cstring)"GET");
		if (q.body.contains('\0') || q.body.size() > 10000)
			m_rawlog.write(logdate()+" << "+method+" "+q.loc.stringify()+" <snip>\n");
		else
			m_rawlog.write(logdate()+" << "+method+" "+q.loc.stringify()+" "+cstring(q.body)+"\n");
	}
}
void http_rawlog(http_t::rsp& r)
{
	if (m_rawlog)
		m_rawlog.write(logdate()+" >> "+tostring(r.status)+" "+r.text_unsafe()+"\n");
}

void set_online(bool online)
{
	m_online = online;
	if (online)
		m_online_ever = online;
	m_root->set_available(m_online);
	for (channel& ch : channels())
	{
		if (ch.host)
			ch.host->set_available(m_online);
	}
}

async<void> network()
{
	status("Connecting", chanbase::imp_none);
	
	set_online(false);
	m_ws.reset();
	
	m_connect_failures++;
	if (m_ws_addr.reconnect)
	{
		if (m_rawlog)
			m_rawlog.write(logdate()+" ** Reconnecting to "+m_ws_addr.reconnect+"\n");
		string headers[] = { "Cookie: d="+http_t::urlencode(m_cookie_xoxd) };
		co_await m_ws.connect(m_ws_addr.reconnect, headers);
		if (!m_ws)
		{
			if (m_connect_failures >= 3)
				m_ws_addr.reconnect = "";
			co_return;
		}
	}
	if (!m_ws)
	{
		if (m_ws_addr.expiry < timestamp::now())
		{
			if (m_rawlog)
				m_rawlog.write(logdate()+" ** Fetching websocket address\n");
			http_t::rsp r = co_await http_api("client.getWebSocketURL");
			http_rawlog(r);
			
			JSON json(r.text());
			if (!json["ok"])
				co_return status("client.getWebSocketURL failed", chanbase::imp_none);
			
			m_ws_addr.primary = json["primary_websocket_url"];
			m_ws_addr.secondary = json["fallback_websocket_url"];
			m_ws_addr.gateway = json["routing_context"];
			m_ws_addr.expiry = timestamp::in_sec(json["ttl_seconds"]);
		}
		
		if (m_rawlog)
			m_rawlog.write(logdate()+" ** Connecting to "+m_ws_addr.primary+"\n");
		
		string headers[] = { "Cookie: d="+http_t::urlencode(m_cookie_xoxd) };
		if (!co_await m_ws.connect(m_ws_addr.primary+"?token="+m_token_xoxc+"&gateway_server="+m_ws_addr.gateway, headers))
			co_return status("websocket connect failed", chanbase::imp_none);
		
		if (m_rawlog)
			m_rawlog.write(logdate()+" ** Fetching scrollbacks\n");
		
		http_t::rsp r = co_await http_api("client.counts");
		http_rawlog(r);
		
		JSON json(r.text());
		if (!json["ok"])
			co_return status("client.counts failed", chanbase::imp_none);
		
		bool channels_fetched = false;
		static const char * channel_types[] = { "channels", "ims" };
		for (const char * ch_type : channel_types)
		{
			for (JSON& jc : json[ch_type].list())
			{
				channel& c = channel_for(jc["id"]);
				if (!c.name)
				{
					if (channels_fetched)
						status("* anonymous channel encountered?");
					else if (!co_await fetch_all_channel_names())
						co_return;
					channels_fetched = true;
					if (!c.name)
						status("* encountered a channel "+jc["id"].str()+" that doesn't exist");
				}
				if (try_fromstring<timestamp>(jc["latest"]) > c.last_msg_at() && jc["updated"] != "0000000000.000000")
				{
					c.scrollback_partial = true;
					c.scrollback_pos = {};
				}
			}
		}
		for (channel& c : channels())
		{
			if (c.scrollback_partial)
				co_await request_scrollback(c);
		}
	}
	
	ping_in(10000);
	if (m_rawlog)
		m_rawlog.write(logdate()+" ** Connected\n");
	
	while (true)
	{
		bytesr by = co_await m_ws.msg();
		if (m_rawlog)
			m_rawlog.write(logdate()+" >> "+by+"\n");
		if (!m_ws)
			co_return status("websocket failed", chanbase::imp_none);
		
		JSON json(by);
		
		if (json["type"] == "pong")
		{
			ping_in(10000);
		}
		else if (json["type"] == "hello")
		{
			status("Connected", chanbase::imp_none);
			m_connect_failures = 0;
			set_online(true);
			// connecting to the reconnect_url yields a hello, with "fast_reconnect":true
		}
		else if (json["type"] == "user_typing") {}
		else if (json["type"] == "reconnect_url")
		{
			// this url changes every two minutes; I believe it tells server how many messages were received before the disconnect
			m_ws_addr.reconnect = json["url"];
		}
		else if (json["type"] == "message")
		{
			if (json["subtype"] == "message_replied") // this one is just a refresher on what message it is
				continue;
			if (json["is_ephemeral"]) // this is just Slackbot and other noise
				continue;
			channel& c = channel_for(json["channel"]);
			if (!c.name)
			{
				if (!co_await fetch_all_channel_names())
					co_return;
				if (!c.name)
					status("* encountered a channel that doesn't exist");
			}
			JSON& jm = (json["message"] ? json["message"] : json["previous_message"] ? json["previous_message"] : json);
			if (!user_for(jm["user"]).name)
			{
				if (jm["user"] == "")
					status("** couldn't parse message, check raw log");
				else if (!co_await fetch_user_list())
					co_return;
			}
			if (json["subtype"] == "message_changed")
			{
				message m;
				parse_message(jm, m);
				if (m.id.sec)
					edit_message(c, m, false);
			}
			else if (json["subtype"] == "message_deleted")
			{
				timestamp ts;
				fromstring(json["deleted_ts"], ts);
				delete_message(c, ts);
			}
			else
			{
				message m;
				parse_message(jm, m);
				if (m.id.sec)
					append_message(c, m);
			}
		}
		else if (json["type"] == "goodbye")
		{
			status("server said goodbye", chanbase::imp_none);
			reconnect_in(0);
			co_return;
		}
		else if (json["type"] == "channel_created")
		{
			if (!co_await fetch_all_channel_names())
				co_return;
		}
		else if (json["type"] == "activity") {}
		else if (json["type"] == "app_actions_updated") {}
		else if (json["type"] == "apps_changed") {}
		else if (json["type"] == "badge_counts_updated") {}
		else if (json["type"] == "bookmark_added") {}
		else if (json["type"] == "bot_added") {}
		else if (json["type"] == "bot_changed") {}
		else if (json["type"] == "channel_marked") {}
		else if (json["type"] == "channel_section_reset") {}
		else if (json["type"] == "channel_section_upserted") {}
		else if (json["type"] == "clear_mention_notification") {}
		else if (json["type"] == "desktop_notification") {} // why is this controlled server side
		else if (json["type"] == "dnd_updated_user") {}
		else if (json["type"] == "draft_create") {}
		else if (json["type"] == "draft_delete") {}
		else if (json["type"] == "draft_send") {}
		else if (json["type"] == "draft_update") {}
		else if (json["type"] == "file_change") {}
		else if (json["type"] == "file_created") {}
		else if (json["type"] == "file_deleted") {}
		else if (json["type"] == "file_public") {}
		else if (json["type"] == "file_shared") {}
		else if (json["type"] == "file_unshared") {}
		else if (json["type"] == "im_close") {}
		// there is an im_created event, but it arrives before the team_join event, so it doesn't say anything useful
		else if (json["type"] == "im_marked") {}
		else if (json["type"] == "im_open") {}
		else if (json["type"] == "megaphone_notifications_team_refresh") {}
		else if (json["type"] == "member_joined_channel") {}
		else if (json["type"] == "mobile_in_app_notification") {}
		else if (json["type"] == "pin_added") {}
		else if (json["type"] == "pref_change") {}
		else if (json["type"] == "reaction_added") {}
		else if (json["type"] == "reaction_removed") {}
		else if (json["type"] == "team_join") {}
		else if (json["type"] == "team_plan_change") {}
		else if (json["type"] == "team_pref_change") {}
		else if (json["type"] == "thread_marked") {}
		else if (json["type"] == "thread_subscribed") {}
		else if (json["type"] == "unfurl_preview_updated") {}
		else if (json["type"] == "update_global_thread_state") {}
		else if (json["type"] == "update_thread_state") {}
		else if (json["type"] == "user_interaction_changed") {} // may be emoji related
		else status("unknown event "+json["type"].str()+" "+by);
	}
}

void ping()
{
	if (!m_ws)
		return reconnect_in(0);
	
	JSONw j;
	j["type"] = "ping";
	j["id"] = 1;
	if (m_rawlog)
		m_rawlog.write(logdate()+" << "+j.serialize()+"\n");
	m_ws.send(j.serialize());
}

async<bool> fetch_user_list()
{
	http_t::rsp r = co_await http_api("users.list");
	http_rawlog(r);
	JSON json(r.text());
	if (!json["ok"])
	{
		status("users.list failed", chanbase::imp_none);
		co_return false;
	}
	for (JSON& ju : json["members"].list())
	{
		user_for(ju["id"]).name = ju["real_name"];
	}
	co_return true;
}

async<bool> fetch_all_channel_names()
{
	http_t::form f;
	f.value("flannel_api_ver", "4");
	http_t::rsp r = co_await http_api("client.boot", f);
	http_rawlog(r);
	
	JSON json(r.text());
	if (!json["ok"])
	{
		status("client.boot failed", chanbase::imp_none);
		co_return false;
	}
	m_self = &user_for(json["self"]["id"]);
	for (JSON& jdm : json["ims"].list())
	{
		channel& ci = channel_for(jdm["id"]);
		user& ui = user_for(jdm["user"]);
		if (!ui.name)
		{
			if (jdm["user"] == "")
				status("* couldn't parse dm list, check raw log");
			else if (!co_await fetch_user_list())
				co_return false;
		}
		ci.name = ui.name;
	}
	for (JSON& jc : json["channels"].list())
	{
		channel& ci = channel_for(jc["id"]);
		ci.name = "#"+jc["name"].str();
	}
	co_return true;
}

void parse_message(const JSON& jm, message& m)
{
	fromstring(jm["ts"], m.id);
	m.author = &user_for(jm["user"]);
	m.text = jm["text"];
	timestamp thread_ts;
	if (fromstring(jm["thread_ts"], thread_ts) && thread_ts != m.id)
	{
		m.in_thread = thread_ts;
	}
	for (const JSON& jf : jm["files"].list())
	{
		m.text += "\n"+jf["url_private"].str();
	}
	// this is just link embeds
	//for (const JSON& ja : jm["attachments"].list())
	//{
	//	if (ja["text"])
	//		m.text += "\n"+ja["text"].str();
	//}
	if (jm["reply_count"])
	{
		int replies = jm["reply_count"];
		if (replies == 1)
			m.text += "\n(1 reply)";
		else
			m.text += "\n("+tostring(replies)+" replies)";
	}
}

async<void> request_scrollback(channel& ch)
{
	http_t::form f;
	f.value("channel", ch.id);
	f.value("limit", "28");
	if (ch.scrollback_pos.sec)
		f.value("latest", id_to_string(ch.scrollback_pos));
	// TODO: where to fetch from
	http_t::rsp r = co_await http_api("conversations.history", f);
	http_rawlog(r);
	
	JSON json(r.text());
	if (!json["ok"])
		co_return status("conversations.history failed", chanbase::imp_none);
	
	arrayview<JSON> jms = json["messages"].list();
	array<message> messages;
	for (size_t n=jms.size();n>0;n--)
		parse_message(jms[n-1], messages.append());
	if (messages)
		scrollback_segment(ch, messages);
}

async<void> send_message(channel& ch, cstring text)
{
	http_t::form f;
	f.value("channel", ch.id);
	f.value("text", text);
	http_t::rsp r = co_await http_api("chat.postMessage", f);
	http_rawlog(r);
}

//async<void> co_command_http(channel* ch, string param)
//{
	//auto simple_message = [ch](cstring text) {
		//span sp[1] = { { text } };
		//ch->host->message(chanbase::imp_scrollback, time(NULL), sp);
	//};
	
	//if (!param)
		//co_return simple_message("* Example: /http PUT profile/@alice:example.com/displayname {\"displayname\":\"Alice Margatroid\"}");
	
	//string method;
	//string path;
	//string json;
	
	//if (isupper(param[0]))
	//{
		//array<cstring> parts = param.csplit<2>(" ");
		//method = parts[0];
		//path = parts[1];
		//if (parts.size() == 3)
			//json = parts[2];
	//}
	//else
	//{
		//array<cstring> parts = param.csplit<1>(" ");
		//path = parts[0];
		//if (parts.size() == 2)
			//json = parts[1];
	//}
	
	//JSON jsonobj;
	//if (json && !jsonobj.parse(json))
		//co_return simple_message("* Invalid JSON");
	
	//http_t::rsp r = co_await http_api(method, path, jsonobj);
	//simple_message("* " + (r.body_unsafe() ? r.body_unsafe() : tostring(r.status)));
//}

bool command(channel* ch, cstring command, cstring param)
{
	russian::chanbase* target = ch ? (russian::chanbase*)ch->host : (russian::chanbase*)m_root;
	auto simple_message = [target](cstring text) {
		span sp[1] = { { text } };
		target->message(chanbase::imp_scrollback, time(NULL), sp);
		return true;
	};
	
	if(0);
	else if (command == "sync")
	{
		if (param)
			return simple_message("* This command doesn't take arguments");
		
		timer t;
		
		my_serializer<jsonserializer2> sw = { {}, this };
		process_cache(sw);
		file::writeall(m_cachename, sw.finish());
		
		simple_message("* State synchronized in "+tostring(t.ms())+"ms");
	}
	//else if (command == "http")
	//{
		//m_misc_waiters.add(co_command_http(ch, param));
	//}
	else return false;
	return true;
}

};

}
protocol*
protocol::create_slack(impl* parent, json5deserializer2& s) { return new chatbase_impl<slack>(parent, s); }
}
