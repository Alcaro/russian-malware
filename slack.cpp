#include "russian.h"
#include "firefox.h"

namespace russian { namespace {
class slack : public protocol {
public:

autoptr<russian::group> m_root; // keep this above m_channels, destructor order is important

file m_rawlog;
string m_cachename;

http_t m_http;
string m_api_addr; // https://slack.com/api/
string m_workspace_id; // T1234567890
string m_token_xoxc; // xoxc-1234567890123-4567890123456-7890123456789-0123456789abcdef0123456789abcdef
string m_cookie_xoxd; // xoxd-AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8= (but longer)
bool m_token_is_config;

int m_connect_failures = 0;
bool m_online = false;
waiter<void> m_recv_coro;
waiter<void> m_ping_coro;
bool m_ping_sent;
websocket m_ws;
struct {
	timestamp expiry = {};
	string primary;
	string secondary;
	string gateway;
	string reconnect; // not serialized
	void serialize(auto& s)
	{
		s.items("primary", primary, "secondary", secondary, "gateway", gateway, "expiry", expiry);
	}
} m_ws_addr;

using u_id = string; // U012AB3CDE
using c_id = string; // C012AB3CDE (channel) or D012AB3CDE (dm)
using u_id_ref = cstring;
using c_id_ref = cstring;

struct user {
	//u_id id;
	bool used = false;
	string name; // Chuck Norris
	
	void serialize(auto& s)
	{
		s.items("name", name);
	}
};
struct message {
	u_id author;
	timestamp time; // also used as unique message identifier, for edits and threads and stuff
	timestamp in_thread;
	string text;
	
	void serialize(auto& s)
	{
		s.items("author", author, "time", time, "thread", ser_include_if(in_thread.sec != 0, in_thread), "text", text);
	}
};
struct channel {
	c_id id;
	bool used = false; // todo: use this to garbage collect deleted channels
	string name; // #general
	array<message> messages;
	
	autoptr<russian::channel> host;
	
	bool is_dm() const
	{
		return id[0] != 'C';
	}
	
	message* message_find(timestamp time)
	{
		for (message& m : messages)
		{
			if (m.time == time)
				return &m;
		}
		return nullptr;
	}
	
	timestamp last_msg_at()
	{
		if (messages) return messages[messages.size()-1].time;
		else return { 0,0 };
	}
	
	void serialize(auto& s)
	{
		s.items("name", name, "messages", messages);
	}
};

u_id m_my_uid;
map<u_id, user> m_users;
map<c_id, channel> m_channels;
array<c_id_ref> m_channel_keys;

void status(cstring text, chanbase::importance_t imp = chanbase::imp_status)
{
	if (m_rawlog)
		m_rawlog.write(logdate()+" ** "+text+"\n");
	span sp[1] = { { text } };
	if (imp == chanbase::imp_highlight) sp[0].fgcol = 0xFF0000;
	m_root->message(imp, time(nullptr), sp);
}

void fatal(cstring text)
{
	m_api_addr = "";
	m_root->rename("ERROR - Slack");
	status(text, chanbase::imp_highlight);
}

template<typename T> void process_cache(T& s)
{
	s.items(
		"self", m_my_uid,
		"ws", m_ws_addr,
		"users", m_users,
		"channels", m_channels
		);
}

slack(impl* parent, bmldeserializer& s, cstring name) : protocol(parent, 0)
{
	m_root = mkgroup(name, chanbase::f_no_logs|chanbase::f_no_users, (void*)(uintptr_t)m_channel_keys.size());
	m_channel_keys.append("");
	
	m_root->set_available(false);
	
	string email_addr;
	string rawlog_fname;
	s.items(
		"email", email_addr,
		"server", m_api_addr,
		"workspace", m_workspace_id,
		"xoxc", m_token_xoxc,
		"xoxd", m_cookie_xoxd,
		"rawlog", rawlog_fname,
		"cache", m_cachename);
	
	if (rawlog_fname)
		m_rawlog.open(file::resolve(file::exedir(), rawlog_fname), file::m_replace);
	
	if (!m_api_addr)
	{
		fatal("Missing server in config");
		return;
	}
	if (!m_workspace_id.startswith("T"))
	{
		fatal("Missing workspace in config");
		return;
	}
	if (!email_addr)
	{
		fatal("Missing email in config"); // not actually used (yet?)
		return;
	}
	
	jsondeserialize(cstring(file::readall(file::resolve(file::exedir(), m_cachename))),
		[this](jsondeserializer& s)
	{
		process_cache(s);
	});
	
	for (auto& pair : m_channels)
		pair.value.id = pair.key;
	
	auto tokens_are_valid = [this]() { return m_token_xoxc.startswith("xoxc-") && m_cookie_xoxd.startswith("xoxd-"); };
	
	m_token_is_config = tokens_are_valid();
	
	if (!tokens_are_valid())
	{
		firefox_profile prof = firefox_profile::get_default();
		JSON json;
		json.parse(prof.get_localstorage("app.slack.com", "localConfig_v2"));
		m_token_xoxc = json["teams"][m_workspace_id]["token"];
		m_cookie_xoxd = prof.get_cookie(".slack.com", "d");
	}
	if (!tokens_are_valid())
	{
		fatal("No token found");
		return;
	}
	
	m_http.wrap_socks(&autoproxy::socket_create_sslmaybe);
	m_ws.wrap_socks(&autoproxy::socket_create_sslmaybe);
	
	process().then(&m_recv_coro);
}

string logdate(time_t rawtime)
{
	struct tm * timeinfo = localtime(&rawtime);
	char out[64];
	strftime(out, 64, "[%H:%M:%S]", timeinfo);
	return out;
}
string logdate()
{
	return logdate(time(NULL));
}

void http_rawlog(http_t::req& q)
{
	if (m_rawlog)
	{
		cstring method = (q.method ? q.method : q.body ? (cstring)"POST" : (cstring)"GET");
		if (q.body.contains('\0') || q.body.size() > 10000)
			m_rawlog.write(logdate()+" << "+method+" "+q.loc.stringify()+" <snip>\n");
		else
			m_rawlog.write(logdate()+" << "+method+" "+q.loc.stringify()+" "+cstring(q.body)+"\n");
	}
}
void http_rawlog(http_t::rsp& r)
{
	if (m_rawlog)
		m_rawlog.write(logdate()+" >> "+tostring(r.status)+" "+r.text_unsafe()+"\n");
}

async<http_t::rsp> http_api(cstring endpoint, http_t::form& f) // do not accept the form by value until gcc bug 98401 is fixed
{
	http_t::req q = { m_api_addr+endpoint };
	q.method = "POST";
	q.headers.append("Cookie: d="+http_t::urlencode(m_cookie_xoxd));
	f.value("token", m_token_xoxc);
	f.attach(q);
	http_rawlog(q);
	return m_http.request(q);
}
async<http_t::rsp> http_api(cstring endpoint)
{
	http_t::form f;
	return http_api(endpoint, f);
}

array<span> render_message_inner(message& m)
{
	user& u = m_users.get(m.author);
	span sp[4] = { { "<"+u.name+"> " }, {}, {}, { m.text } };
	if (m.text.contains(m_my_uid))
	{
		for (span& s : sp)
			s.fgcol = 0xFF0000;
	}
	if (m.in_thread.sec != 0)
	{
		sp[2].text = "^"+time_to_str(m.in_thread.sec)+"\n";
		sp[2].fgcol = 0xC04000;
	}
	return sp;
}

void render_message(channel* ch, message& m, bool is_scrollback = false)
{
	user& u = m_users.get(m.author);
	u.used = true;
	chanbase::importance_t imp = is_scrollback ? chanbase::imp_scrollback : m.author == m_my_uid ? chanbase::imp_none : chanbase::imp_msg;
	ch->host->message(tostring(m.time), imp, m.time.sec, render_message_inner(m));
}

void render_message_edit(channel* ch, message& m)
{
	user& u = m_users.get(m.author);
	u.used = true;
	ch->host->message_edit(tostring(m.time), m.time.sec, render_message_inner(m), 1);
}

user* user_for(u_id_ref id)
{
	user* u = &m_users.get_create(id);
	//if (!u->id) u->id = id;
	return u;
}

channel* channel_for(c_id_ref id)
{
	channel* c = &m_channels.get_create(id);
	if (!c->id) c->id = id;
	return c;
}

void channel_host(channel* ch)
{
	if (!ch->host)
	{
		if (!ch->name)
			status("warning: nameless channel "+ch->id);
		ch->host = m_root->child(ch->name, chanbase::f_no_scrollback, (void*)(uintptr_t)m_channel_keys.size());
		m_channel_keys.append(ch->id);
		for (message& m : ch->messages.skip(max(0, ch->messages.size()-250)))
			render_message(ch, m, true);
	}
	ch->host->sort_idx(ch->is_dm() ? 0 : 1);
	ch->host->set_available(m_online);
}

void channels_available()
{
	m_root->set_available(m_online);
	for (auto& pair : m_channels)
	{
		if (pair.value.host)
			channel_host(&pair.value);
	}
}

async<bool> fetch_user_list()
{
	http_t::rsp r = co_await http_api("users.list");
	http_rawlog(r);
	JSON json(r.text());
	if (!json["ok"])
	{
		status("users.list failed", chanbase::imp_none);
		co_return false;
	}
	for (JSON& ju : json["members"].list())
	{
		user_for(ju["id"])->name = ju["real_name"];
	}
	// reenable this stuff if I discover strangers, or other users who aren't in users.list
	/*
	if (missing_users.size() == 1)
	{
		http_t::form f;
		f.value("user", missing_users[0]);
		http_t::rsp r = co_await http_api("users.info", f);
		http_rawlog(r);
		JSON json(r.text());
		if (!json["ok"])
		{
			status("users.info failed");
			co_return false;
		}
		
		JSON& ju = json["user"];
		if (ju["id"] != missing_users[0])
		{
			fatal("users/info returned unexpected data");
			co_return false;
		}
		user_for(ju["id"])->name = ju["real_name"];
		
		co_return true;
	}
	
	http_t::form f;
	f.value("flannel_api_ver", "4");
	http_t::rsp r = co_await http_api("api.getFlannelHttpUrl", f);
	http_rawlog(r);
	JSON json(r.text());
	if (!json["ok"])
	{
		status("api.getFlannelHttpUrl failed");
		co_return false;
	}
	
	http_t::req q = { json["url"].str()+"/users/info" };
	q.method = "POST";
	q.headers.append("Cookie: d="+http_t::urlencode(m_cookie_xoxd));
	JSONw qj;
	qj["token"] = m_token_xoxc;
	for (u_id_ref uid : missing_users)
		qj["updated_ids"][uid] = 0;
	q.body = qj.serialize().bytes();
	http_rawlog(q);
	
	r = co_await m_http.request(q);
	http_rawlog(r);
	json.parse(r.text());
	if (!json["ok"])
	{
		status("users/info failed");
		co_return false;
	}
	for (JSON& ju : json["results"].list())
	{
		if (!m_users.contains(ju["id"].str()))
		{
			fatal("users/info returned unexpected data");
			co_return false;
		}
		user_for(ju["id"])->name = ju["real_name"];
	}
	*/
	co_return true;
}

async<bool> fetch_all_channel_names()
{
	http_t::form f;
	f.value("flannel_api_ver", "4");
	http_t::rsp r = co_await http_api("client.boot", f);
	http_rawlog(r);
	
	JSON json(r.text());
	if (!json["ok"])
	{
		status("client.boot failed", chanbase::imp_none);
		co_return false;
	}
	m_my_uid = json["self"]["id"];
	for (JSON& jdm : json["ims"].list())
	{
		channel* c = channel_for(jdm["id"]);
		user* u = user_for(jdm["user"]);
		if (!u->name)
		{
			if (jdm["user"] == "")
				status("** couldn't parse message, check raw log");
			else if (!co_await fetch_user_list())
				co_return false;
			u = user_for(jdm["user"]);
		}
		c->name = u->name;
	}
	for (JSON& jc : json["channels"].list())
	{
		channel* c = channel_for(jc["id"]);
		c->name = "#"+jc["name"].str();
	}
	co_return true;
}

void parse_message(message& m, JSON& jm)
{
	timestamp ts;
	fromstring(jm["ts"], ts);
	m.author = jm["user"];
	m.time = ts;
	m.text = jm["text"];
	timestamp thread_ts;
	if (fromstring(jm["thread_ts"], thread_ts) && thread_ts != ts)
	{
		m.in_thread = thread_ts;
	}
	for (JSON& jf : jm["files"].list())
	{
		m.text += "\n"+jf["url_private"].str();
	}
	for (JSON& ja : jm["attachments"].list())
	{
		m.text += "\n"+ja["text"].str();
	}
	if (jm["reply_count"])
	{
		int replies = jm["reply_count"];
		if (replies == 1)
			m.text += "\n(1 reply)";
		else
			m.text += "\n("+tostring(replies)+" replies)";
	}
}

async<bool> fetch_channel_backlog(channel* c)
{
	http_t::form f;
	f.value("channel", c->id);
	f.value("limit", "28");
	http_t::rsp r = co_await http_api("conversations.history", f);
	http_rawlog(r);
	
	JSON json(r.text());
	if (!json["ok"])
	{
		status("conversations.history failed", chanbase::imp_none);
		co_return false;
	}
	
	arrayvieww<JSON> jms = json["messages"].list();
	timestamp last = c->last_msg_at();
	for (ssize_t n=jms.size()-1;n>=0;n--)
	{
		JSON& jm = jms[n];
		timestamp ts;
		fromstring(jm["ts"], ts);
		if (ts > last)
		{
			if (!user_for(jm["user"])->name)
			{
				if (jm["user"] == "")
					status("** couldn't parse message, check raw log");
				else if (!co_await fetch_user_list())
					co_return false;
			}
			channel_host(c);
			message& m = c->messages.append();
			parse_message(m, jm);
			render_message(c, m, false);
		}
	}
	
	if (c->messages.size() > 500)
		c->messages.remove_range(0, c->messages.size()-300);
	
	co_return true;
}

async<void> process()
{
reconnect:
	status("Connecting", chanbase::imp_none);
	m_ping_sent = true;
	co_await runloop2::in_ms(0); // so m_ping_coro can return
	
	m_online = false;
	channels_available();
	m_ping_coro.cancel();
	m_ws.reset();
	
	if (!m_api_addr)
		co_return;
	
	if (m_connect_failures >= 1)
	{
		protocol::disconnected();
		co_await runloop2::in_ms(30000);
	}
	m_connect_failures++;
	
	[](slack* self)->async<void> {
		int seq = 1;
		while (true)
		{
			co_await runloop2::in_ms(10000);
			
			if (self->m_ping_sent)
			{
				self->status("ping timeout", chanbase::imp_none);
				self->m_recv_coro.cancel();
				self->process().then(&self->m_recv_coro);
				co_return;
			}
			if (!self->m_ws)
			{
				self->m_recv_coro.cancel();
				self->process().then(&self->m_recv_coro);
				co_return;
			}
			JSONw j;
			j["type"] = "ping";
			j["id"] = seq++;
			if (self->m_rawlog)
				self->m_rawlog.write(self->logdate()+" << "+j.serialize()+"\n");
			self->m_ws.send(j.serialize());
			self->m_ping_sent = true;
		}
	}(this).then(&m_ping_coro);
	
	if (m_ws_addr.reconnect)
	{
		if (m_rawlog)
			m_rawlog.write(logdate()+" ** Reconnecting to "+m_ws_addr.reconnect+"\n");
		string headers[] = { "Cookie: d="+http_t::urlencode(m_cookie_xoxd) };
		co_await m_ws.connect(m_ws_addr.reconnect, headers);
		if (!m_ws)
		{
			if (m_connect_failures >= 3)
				m_ws_addr.reconnect = "";
			goto reconnect;
		}
	}
	if (!m_ws)
	{
		if (m_ws_addr.expiry < timestamp::now())
		{
			if (m_rawlog)
				m_rawlog.write(logdate()+" ** Fetching websocket address\n");
			http_t::rsp r = co_await http_api("client.getWebSocketURL");
			http_rawlog(r);
			
			JSON json(r.text());
			if (!json["ok"])
			{
				status("client.getWebSocketURL failed", chanbase::imp_none);
				goto reconnect;
			}
			
			m_ws_addr.primary = json["primary_websocket_url"];
			m_ws_addr.secondary = json["fallback_websocket_url"];
			m_ws_addr.gateway = json["routing_context"];
			m_ws_addr.expiry = timestamp::in_sec(json["ttl_seconds"]);
		}
		
		if (m_rawlog)
			m_rawlog.write(logdate()+" ** Connecting to "+m_ws_addr.primary+"\n");
		
		string headers[] = { "Cookie: d="+http_t::urlencode(m_cookie_xoxd) };
		if (!co_await m_ws.connect(m_ws_addr.primary+"?token="+m_token_xoxc+"&gateway_server="+m_ws_addr.gateway, headers))
		{
			status("websocket connect failed", chanbase::imp_none);
			goto reconnect;
		}
		
		if (m_rawlog)
			m_rawlog.write(logdate()+" ** Fetching scrollbacks\n");
		
		http_t::rsp r = co_await http_api("client.counts");
		http_rawlog(r);
		
		JSON json(r.text());
		if (!json["ok"])
		{
			status("client.counts failed", chanbase::imp_none);
			goto reconnect;
		}
		
		bool channels_fetched = false;
		for (JSON& jc : json["channels"].list())
		{
			channel* c = channel_for(jc["id"]);
			c->used = true;
			if (!c->name)
			{
				if (channels_fetched)
					status("anonymous channel encountered?");
				else if (!co_await fetch_all_channel_names())
					goto reconnect;
				channels_fetched = true;
				c = channel_for(jc["id"]);
				if (!c->name)
				{
					status("* encountered a channel that doesn't exist");
				}
			}
			if (try_fromstring<timestamp>(jc["latest"]) > c->last_msg_at() && jc["updated"] != "0000000000.000000")
			{
				if (!co_await fetch_channel_backlog(c))
					goto reconnect;
			}
		}
		for (JSON& jc : json["ims"].list())
		{
			channel* c = channel_for(jc["id"]);
			c->used = true;
			if (!c->name)
			{
				if (channels_fetched)
					status("anonymous channel encountered?");
				else if (!co_await fetch_all_channel_names())
					goto reconnect;
				channels_fetched = true;
				c = channel_for(jc["id"]);
				if (!c->name)
				{
					status("* encountered a channel that doesn't exist");
				}
			}
			if (try_fromstring<timestamp>(jc["latest"]) > c->last_msg_at() && jc["updated"] != "0000000000.000000")
			{
				if (!co_await fetch_channel_backlog(c))
					goto reconnect;
			}
		}
	}
	
	m_ping_sent = false;
	if (m_rawlog)
		m_rawlog.write(logdate()+" ** Connected\n");
	
	while (true)
	{
		bytesr by = co_await m_ws.msg();
		if (m_rawlog)
			m_rawlog.write(logdate()+" >> "+by+"\n");
		if (!m_ws)
		{
			status("websocket failed", chanbase::imp_none);
			goto reconnect;
		}
		m_ping_sent = false;
		
		JSON json(by);
//		timestamp event_ts;
//		if (fromstring(json["event_ts"], event_ts))
//		{
//			if (event_ts <= m_ws_last)
//			{
//if (m_rawlog)
//	m_rawlog.write(logdate()+" ** skipped\n");
//				continue;
//			}
//			m_ws_last = event_ts;
//		}
		
		if (json["type"] == "pong") {}
		else if (json["type"] == "hello")
		{
			status("Connected", chanbase::imp_none);
			m_connect_failures = 0;
			m_online = true;
			channels_available();
			// connecting to the reconnect_url yields a hello, with "fast_reconnect":true
		}
		else if (json["type"] == "user_typing") {}
		else if (json["type"] == "reconnect_url")
		{
			// this url changes every two minutes; I believe it tells server how many messages were received before the disconnect
			m_ws_addr.reconnect = json["url"];
		}
		else if (json["type"] == "message")
		{
			if (json["subtype"] == "message_replied") // this one is just a refresher on what message it is
				continue;
			if (json["is_ephemeral"]) // this is just Slackbot and other noise
				continue;
			channel* c = channel_for(json["channel"]);
			if (!c->name)
			{
				if (!co_await fetch_all_channel_names())
					goto reconnect;
				c = channel_for(json["channel"]);
				if (!c->name)
				{
					status("* encountered a channel that doesn't exist");
				}
			}
			JSON& jm = (json["message"] ? json["message"] : json["previous_message"] ? json["previous_message"] : json);
			if (!user_for(jm["user"])->name)
			{
				if (jm["user"] == "")
					status("** couldn't parse message, check raw log");
				else if (!co_await fetch_user_list())
					goto reconnect;
			}
			channel_host(c);
			if (json["subtype"] == "message_changed")
			{
				timestamp ts;
				fromstring(json["ts"], ts);
				message* m = c->message_find(ts);
				if (!m) continue;
				if (!jm["edited"]) continue; // if that's an add embeds edit, just discard it
				//timestamp new_ts;
				//fromstring(json["event_ts"], new_ts);
				parse_message(*m, jm);
				render_message_edit(c, *m);
			}
			else if (json["subtype"] == "message_deleted")
			{
				timestamp ts;
				fromstring(json["ts"], ts);
				message* m = c->message_find(ts);
				if (!m) continue;
				c->host->message_delete(tostring(ts));
				c->messages.remove(m - c->messages.ptr());
			}
			else
			{
				message* m = &c->messages.append();
				parse_message(*m, jm);
				render_message(c, *m, false);
			}
		}
		else if (json["type"] == "goodbye")
		{
			status("server said goodbye", chanbase::imp_none);
			goto reconnect;
		}
		else if (json["type"] == "channel_marked") {}
		else if (json["type"] == "channel_section_upserted") {}
		else if (json["type"] == "channel_section_reset") {}
		else if (json["type"] == "im_marked") {}
		else if (json["type"] == "im_open") {}
		else if (json["type"] == "im_close") {}
		else if (json["type"] == "dnd_updated_user") {}
		else if (json["type"] == "draft_create") {}
		else if (json["type"] == "draft_update") {}
		else if (json["type"] == "draft_send") {}
		else if (json["type"] == "draft_delete") {}
		else if (json["type"] == "file_created") {}
		else if (json["type"] == "file_change") {}
		else if (json["type"] == "file_deleted") {}
		else if (json["type"] == "file_public") {}
		else if (json["type"] == "file_shared") {}
		else if (json["type"] == "file_unshared") {}
		else if (json["type"] == "member_joined_channel") {}
		else if (json["type"] == "update_thread_state") {}
		else if (json["type"] == "thread_subscribed") {}
		else if (json["type"] == "thread_marked") {}
		else if (json["type"] == "reaction_added") {}
		else if (json["type"] == "reaction_removed") {}
		else if (json["type"] == "unfurl_preview_updated") {}
		else if (json["type"] == "team_plan_change") {}
		else if (json["type"] == "team_pref_change") {}
		else if (json["type"] == "apps_changed") {}
		else if (json["type"] == "app_actions_updated") {}
		else if (json["type"] == "megaphone_notifications_team_refresh") {}
		else if (json["type"] == "user_interaction_changed") {} // may be emoji related
		else if (json["type"] == "desktop_notification") {} // why is this controlled server side
		else if (json["type"] == "clear_mention_notification") {}
		else if (json["type"] == "pref_change") {}
		else if (json["type"] == "bot_changed") {}
		else status("unknown event "+json["type"].str()+" "+by);
	}
}

void action(chanbase& at, cstrnul text) override
{
	auto simple_message = [&at](cstring text) {
		span sp[1] = { { text } };
		at.message(chanbase::imp_scrollback, time(NULL), sp);
	};
	
	c_id_ref c_id = m_channel_keys[(uintptr_t)(void*)at.userdata];
	channel* c = c_id ? &m_channels.get(c_id) : nullptr;
	
	if (LIKELY(text[0] != '/'))
	{
		if (!c) return simple_message("* Can't talk here");
		
	normal_send:
		http_t::form f;
		f.value("channel", c->id);
		f.value("text", text);
		runloop2::detach([](slack* self, http_t::form& f)->async<void> {
			http_t::rsp r = co_await self->http_api("chat.postMessage", f);
			self->http_rawlog(r);
		}(this, f));
		return;
	}
	if (text[1] == '/')
	{
		if (!c) return simple_message("* Can't talk here");
		text = text.substr_nul(1);
		goto normal_send;
	}
	
	array<cstring> parts = text.substr_nul(1).csplit<1>(REGEX(" |(?=\\n)"));
	cstring command = parts[0];
	cstring param = parts.size()==2 ? parts[1] : "";
	
	if(0);
	else if (command == "sync")
	{
		if (param)
			return simple_message("* This command doesn't take arguments");
		
		timer t;
		
		file::writeall(file::resolve(file::exedir(), m_cachename), jsonserialize([this](jsonserializer& s) { process_cache(s); }));
		
		simple_message("* State synchronized in "+tostring(t.ms())+"ms");
	}
	else if (command == "reply")
	{
		if (!c) return simple_message("* Can't talk here");
		
		array<cstring> parts = param.csplit<1>(REGEX(" |(?=\\n)"));
		if (!parts[0])
			return simple_message("* Invalid input");
		
		http_t::form f;
		f.value("channel", c->id);
		f.value("text", parts[1]);
		f.value("thread_ts", parts[0]);
		f.value("reply_broadcast", "false");
		runloop2::detach([](slack* self, http_t::form& f)->async<void> {
			http_t::rsp r = co_await self->http_api("chat.postMessage", f);
			self->http_rawlog(r);
		}(this, f));
	}
	else if (command == "join")
	{
		array<channel*> matches;
		
		for (int type : range(3))
		{
			for (auto& c : m_channels)
			{
				cstring name = c.value.name;
				if (type == 0)
				{
					if (name.matches_globi(param+"*") || name.matches_globi("#"+param+"*"))
						matches.append(&c.value);
				}
				if (type == 1)
				{
					if (name.matches_globi(param+"*"))
						matches.append(&c.value);
				}
				if (type == 2)
				{
					if (name.matches_globi("*"+param+"*"))
						matches.append(&c.value);
				}
			}
			if (matches) break;
		}
		
		if (!matches)
			return simple_message("No such channel");
		
		if (matches.size() == 1 && matches[0] != c)
		{
			channel* ch = matches[0];
			channel_host(ch);
			ch->host->focus();
		}
		else
		{
			for (channel* c : matches)
				simple_message(c->name);
		}
	}
	else
	{
		simple_message("* Unknown command");
	}
}
void close_chan(chanbase& at) override
{
	c_id_ref c_id = m_channel_keys[(uintptr_t)(void*)at.userdata];
	if (!c_id)
		return;
	channel* c = &m_channels.get(c_id);
	c->host = nullptr;
}

void contextmenu(chanbase& at, cstrnul msgid, array<textview::ctxaction>& actions) override
{
	c_id_ref c_id = m_channel_keys[(uintptr_t)(void*)at.userdata];
	if (!c_id)
		return;
	channel* chan = c_id ? &m_channels.get(c_id) : nullptr;
	if (!chan)
		return;
	timestamp ts;
	if (!fromstring(msgid, ts))
		return;
	
	message* msg = chan->message_find(ts);
	if (!msg)
		return;
	
	// todo:
	// - check if slack requires six digits after comma, or if trailing zeroes are optional
	// - check how slack reacts if I try to create nested threads
	actions.append({ "Reply", [chan, msg](){
		chan->host->input_prefix("/reply "+tostring(msg->time)+"\n");
	} });
}

~slack()
{
	file::writeall(file::resolve(file::exedir(), m_cachename), jsonserialize([this](jsonserializer& s) { process_cache(s); }));
}

};
}
russian::protocol* russian::protocol::create_slack(impl* parent, bmldeserializer& s, cstring name) { return new slack(parent, s, name); }

}
