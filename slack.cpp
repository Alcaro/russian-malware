#include "russian.h"

namespace russian { namespace {
class slack : public protocol {
public:

autoptr<russian::group> m_root; // keep this above m_channels, destructor order is important

file m_rawlog;
string m_cachename;

socks5 m_proxy;

http_t m_http;
string m_token_xoxp;

string m_token_xapp;
waiter<void> m_recv_coro;

slack(impl* parent, bmldeserializer& s, cstring name) : protocol(parent, 0)
{
	m_root = mkgroup(name, chanbase::f_no_logs|chanbase::f_no_users, (void*)0);
	
	m_root->set_available(false);
	
	string rawlog_fname;
	string proxy_addr;
	s.items(
		//"email", username_full,
		"xoxp", m_token_xoxp,
		"xapp", m_token_xapp,
		"rawlog", rawlog_fname,
		"cache", m_cachename,
		"socks5", proxy_addr);
	
	if (rawlog_fname)
		m_rawlog.open(file::resolve(file::exedir(), rawlog_fname), file::m_replace);
	
	if (proxy_addr)
	{
		m_proxy.configure(proxy_addr);
		//m_http.wrap_socks(bind_ptr(&socks5::create_sslmaybe, &m_proxy));
		//m_http_poll.wrap_socks(bind_ptr(&socks5::create_sslmaybe, &m_proxy));
	}
	
	my_coro().then(&m_recv_coro);
}

async<void> my_coro()
{
	http_t::req q = { "https://slack.com/api/apps.connections.open" };
	q.method = "POST";
	q.headers.append("Authorization: Bearer "+m_token_xapp);
	http_t::rsp r = co_await m_http.request(q);
	string rt = r.text_unsafe();
	puts(rt);
	JSON json;
	if (!json.parse(rt))
		co_return;
	string url = json["url"];
	if (!url.startswith("wss://"))
		co_return;
	
	websocket ws;
	bool ws_ok = co_await ws.connect(url + "&debug_reconnects=true");
	printf("ok=%d\n", ws_ok);
	while (ws)
	{
		int type;
		bytesr by = co_await ws.msg(&type, true);
		puts(tostring(type)+" "+tostringhex_dbg(by));
	}
	co_return;
}

void action(chanbase& at, cstrnul text) override
{
	
}
void begin_private(chanbase& at, cstrnul name) override {}
void close_chan(chanbase& at) override {}

};
}
russian::protocol* russian::protocol::create_slack(impl* parent, bmldeserializer& s, cstring name) { return new slack(parent, s, name); }

}

